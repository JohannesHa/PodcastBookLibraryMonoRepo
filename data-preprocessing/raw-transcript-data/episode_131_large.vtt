WEBVTT

00:00.000 --> 00:02.640
 The following is a conversation with Chris Latner,

00:02.640 --> 00:04.680
 his second time on the podcast.

00:04.680 --> 00:06.600
 He's one of the most brilliant engineers

00:06.600 --> 00:08.780
 in modern computing, having created

00:08.780 --> 00:11.460
 LLVM compiler infrastructure project,

00:11.460 --> 00:14.640
 the Clang compiler, the Swift programming language,

00:14.640 --> 00:17.640
 a lot of key contributions to TensorFlow and TPUs

00:17.640 --> 00:19.040
 as part of Google.

00:19.040 --> 00:23.500
 He served as vice president of autopilot software at Tesla,

00:23.500 --> 00:26.180
 was a software innovator and leader at Apple,

00:26.180 --> 00:29.320
 and now is at SciFive as senior vice president

00:29.320 --> 00:32.500
 of platform engineering, looking to revolutionize

00:32.500 --> 00:36.560
 chip design to make it faster, better, and cheaper.

00:36.560 --> 00:39.180
 Quick mention of each sponsor, followed by some thoughts

00:39.180 --> 00:40.900
 related to the episode.

00:40.900 --> 00:43.480
 First sponsor is Blinkist, an app that summarizes

00:43.480 --> 00:45.380
 key ideas from thousands of books.

00:45.380 --> 00:48.020
 I use it almost every day to learn new things

00:48.020 --> 00:52.280
 or to pick which books I want to read or listen to next.

00:52.280 --> 00:55.860
 Second is Neuro, the maker of functional sugar free gum

00:55.860 --> 00:58.520
 and mints that I use to supercharge my mind

00:58.520 --> 01:01.620
 with caffeine, altheanine, and B vitamins.

01:01.620 --> 01:05.940
 Third is Masterclass, online courses from the best people

01:05.940 --> 01:08.360
 in the world on each of the topics covered,

01:08.360 --> 01:11.140
 from rockets, to game design, to poker,

01:11.140 --> 01:13.920
 to writing, and to guitar.

01:13.920 --> 01:16.960
 And finally, Cash App, the app I use to send money

01:16.960 --> 01:21.780
 to friends for food, drinks, and unfortunately, lost bets.

01:21.780 --> 01:23.740
 Please check out the sponsors in the description

01:23.740 --> 01:27.320
 to get a discount and to support this podcast.

01:27.320 --> 01:29.800
 As a side note, let me say that Chris has been

01:29.800 --> 01:32.560
 an inspiration to me on a human level

01:32.560 --> 01:35.240
 because he is so damn good as an engineer

01:35.240 --> 01:38.600
 and leader of engineers, and yet he's able to stay humble,

01:38.600 --> 01:41.040
 especially humble enough to hear the voices

01:41.040 --> 01:43.800
 of disagreement and to learn from them.

01:43.800 --> 01:46.080
 He was supportive of me and this podcast

01:46.080 --> 01:49.520
 from the early days, and for that, I'm forever grateful.

01:49.520 --> 01:52.280
 To be honest, most of my life, no one really believed

01:52.280 --> 01:53.920
 that I would amount to much.

01:53.920 --> 01:56.500
 So when another human being looks at me,

01:56.500 --> 01:58.920
 it makes me feel like I might be someone special,

01:58.920 --> 02:00.840
 it can be truly inspiring.

02:00.840 --> 02:02.780
 That's a lesson for educators.

02:02.780 --> 02:05.640
 The weird kid in the corner with a dream

02:05.640 --> 02:08.160
 is someone who might need your love and support

02:08.160 --> 02:10.080
 in order for that dream to flourish.

02:10.920 --> 02:13.320
 If you enjoy this thing, subscribe on YouTube,

02:13.320 --> 02:15.480
 review it with five stars on Apple Podcast,

02:15.480 --> 02:17.960
 follow on Spotify, support on Patreon,

02:17.960 --> 02:21.320
 or connect with me on Twitter at Lex Friedman.

02:21.320 --> 02:24.780
 And now, here's my conversation with Chris Latner.

02:24.780 --> 02:28.960
 What are the strongest qualities of Steve Jobs,

02:28.960 --> 02:32.960
 Elon Musk, and the great and powerful Jeff Dean

02:32.960 --> 02:36.000
 since you've gotten the chance to work with each?

02:36.000 --> 02:38.560
 You're starting with an easy question there.

02:38.560 --> 02:40.680
 These are three very different people.

02:40.680 --> 02:43.840
 I guess you could do maybe a pairwise comparison

02:43.840 --> 02:45.720
 between them instead of a group comparison.

02:45.720 --> 02:48.200
 So if you look at Steve Jobs and Elon,

02:48.200 --> 02:51.000
 I worked a lot more with Elon than I did with Steve.

02:51.000 --> 02:52.360
 They have a lot of commonality.

02:52.360 --> 02:55.400
 They're both visionary in their own way.

02:55.400 --> 02:57.600
 They're both very demanding in their own way.

02:58.680 --> 03:02.400
 My sense is Steve is much more human factor focused

03:02.400 --> 03:04.620
 where Elon is more technology focused.

03:04.620 --> 03:05.960
 What does human factor mean?

03:05.960 --> 03:08.440
 Steve's trying to build things that feel good,

03:08.440 --> 03:11.560
 that people love, that affect people's lives, how they live.

03:11.560 --> 03:14.640
 He's looking into the future a little bit

03:14.640 --> 03:17.760
 in terms of what people want.

03:17.760 --> 03:20.240
 Where I think that Elon focuses more on

03:20.240 --> 03:22.360
 learning how exponentials work and predicting

03:22.360 --> 03:24.080
 the development of those.

03:24.080 --> 03:26.240
 Steve worked with a lot of engineers.

03:26.240 --> 03:29.480
 That was one of the things that are reading the biography.

03:29.480 --> 03:33.280
 How can a designer essentially talk to engineers

03:33.280 --> 03:35.580
 and get their respect?

03:35.580 --> 03:37.760
 I think, so I did not work very closely with Steve.

03:37.760 --> 03:38.600
 I'm not an expert at all.

03:38.600 --> 03:41.840
 My sense is that he pushed people really hard,

03:41.840 --> 03:44.420
 but then when he got an explanation that made sense to him,

03:44.420 --> 03:45.720
 then he would let go.

03:45.720 --> 03:49.200
 And he did actually have a lot of respect for engineering,

03:49.200 --> 03:51.480
 but he also knew when to push.

03:51.480 --> 03:54.160
 And when you can read people well,

03:54.160 --> 03:56.880
 you can know when they're holding back

03:56.880 --> 03:58.440
 and when you can get a little bit more out of them.

03:58.440 --> 04:00.340
 And I think he was very good at that.

04:01.200 --> 04:03.240
 I mean, if you compare the other folks,

04:03.240 --> 04:05.180
 so Jeff Dean, right?

04:05.180 --> 04:06.280
 Jeff Dean's an amazing guy.

04:06.280 --> 04:09.060
 He's super smart, as are the other guys.

04:10.440 --> 04:13.820
 Jeff is a really, really, really nice guy, well meaning.

04:13.820 --> 04:15.280
 He's a classic Googler.

04:15.280 --> 04:17.720
 He wants people to be happy.

04:17.720 --> 04:19.760
 He combines it with brilliance

04:19.760 --> 04:22.580
 so he can pull people together in a really great way.

04:22.580 --> 04:24.640
 He's definitely not a CEO type.

04:24.640 --> 04:28.040
 I don't think he would even want to be that.

04:28.040 --> 04:29.280
 Do you know if he still programs?

04:29.280 --> 04:30.560
 Oh yeah, he definitely programs.

04:30.560 --> 04:32.840
 Jeff is an amazing engineer today, right?

04:32.840 --> 04:34.080
 And that has never changed.

04:34.080 --> 04:38.040
 So it's really hard to compare Jeff to either of those two.

04:40.360 --> 04:43.680
 I think that Jeff leads through technology

04:43.680 --> 04:45.800
 and building it himself and then pulling people in

04:45.800 --> 04:46.800
 and inspiring them.

04:46.800 --> 04:50.080
 And so I think that that's one of the amazing things

04:50.080 --> 04:50.920
 about Jeff.

04:50.920 --> 04:53.240
 But each of these people, with their pros and cons,

04:53.240 --> 04:55.040
 all are really inspirational

04:55.040 --> 04:56.800
 and have achieved amazing things.

04:56.800 --> 05:00.760
 So I've been very fortunate to get to work with these guys.

05:00.760 --> 05:03.880
 For yourself, you've led large teams,

05:03.880 --> 05:06.240
 you've done so many incredible,

05:06.240 --> 05:08.440
 difficult technical challenges.

05:08.440 --> 05:10.940
 Is there something you've picked up from them

05:10.940 --> 05:12.560
 about how to lead?

05:12.560 --> 05:14.700
 Yeah, so I mean, I think leadership is really hard.

05:14.700 --> 05:17.240
 It really depends on what you're looking for there.

05:17.240 --> 05:20.240
 I think you really need to know what you're talking about.

05:20.240 --> 05:23.040
 So being grounded on the product, on the technology,

05:23.040 --> 05:26.360
 on the business, on the mission is really important.

05:28.360 --> 05:29.880
 Understanding what people are looking for,

05:29.880 --> 05:30.800
 why they're there.

05:30.800 --> 05:32.440
 One of the most amazing things about Tesla

05:32.440 --> 05:34.680
 is the unifying vision, right?

05:34.680 --> 05:37.280
 People are there because they believe in clean energy

05:37.280 --> 05:39.700
 and electrification, all these kinds of things.

05:39.700 --> 05:42.700
 The other is to understand what really motivates people,

05:42.700 --> 05:43.860
 how to get the best people,

05:43.860 --> 05:46.820
 how to build a plan that actually can be executed, right?

05:46.820 --> 05:48.420
 There's so many different aspects of leadership

05:48.420 --> 05:51.420
 and it really depends on the time, the place, the problems.

05:52.820 --> 05:54.820
 There's a lot of issues that don't need to be solved.

05:54.820 --> 05:57.780
 And so if you focus on the right things and prioritize well,

05:57.780 --> 05:59.380
 that can really help move things.

05:59.380 --> 06:01.140
 Two interesting things you mentioned.

06:01.140 --> 06:03.940
 One is you really have to know what you're talking about.

06:03.940 --> 06:08.940
 How you've worked on your business,

06:08.940 --> 06:12.260
 you've worked on a lot of very challenging technical things.

06:12.260 --> 06:17.260
 So I kind of assume you were born technically savvy,

06:18.000 --> 06:20.760
 but assuming that's not the case,

06:20.760 --> 06:24.980
 how did you develop technical expertise?

06:24.980 --> 06:27.380
 Like even at Google you worked on,

06:27.380 --> 06:28.980
 I don't know how many projects,

06:28.980 --> 06:32.260
 but really challenging, very varied.

06:32.260 --> 06:34.660
 Compilers, TPUs, hardware, cloud stuff,

06:34.660 --> 06:36.420
 bunch of different things.

06:36.420 --> 06:37.780
 The thing that I've become comfortable

06:37.780 --> 06:42.300
 as I've more comfortable with as I've gained experience

06:42.300 --> 06:45.100
 is being okay with not knowing.

06:45.980 --> 06:49.100
 And so a major part of leadership is actually,

06:49.100 --> 06:50.860
 it's not about having the right answer,

06:50.860 --> 06:52.860
 it's about getting the right answer.

06:52.860 --> 06:56.340
 And so if you're working in a team of amazing people, right?

06:56.340 --> 06:58.740
 And many of these places, many of these companies

06:58.740 --> 07:00.320
 all have amazing people.

07:00.320 --> 07:02.100
 It's the question of how do you get people together?

07:02.100 --> 07:04.140
 How do you build trust?

07:04.140 --> 07:05.900
 How do you get people to open up?

07:05.900 --> 07:10.000
 How do you get people to be vulnerable sometimes

07:10.000 --> 07:11.760
 with an idea that maybe isn't good enough,

07:11.760 --> 07:13.880
 but it's the start of something beautiful?

07:13.880 --> 07:17.380
 How do you provide an environment

07:17.380 --> 07:18.820
 where you're not just like top down,

07:18.820 --> 07:21.100
 thou shalt do the thing that I tell you to do, right?

07:21.100 --> 07:23.720
 But you're encouraging people to be part of the solution

07:23.720 --> 07:26.420
 and providing a safe space

07:26.420 --> 07:27.900
 where if you're not doing the right thing,

07:27.900 --> 07:29.660
 they're willing to tell you about it, right?

07:29.660 --> 07:31.420
 So you're asking dumb questions?

07:31.420 --> 07:33.520
 Yeah, dumb questions are my specialty, yeah.

07:33.520 --> 07:35.820
 Well, so I've been in the hardware realm recently

07:35.820 --> 07:39.060
 and I don't know much at all about how chips are designed.

07:39.060 --> 07:40.060
 I know a lot about using them.

07:40.060 --> 07:41.100
 I know some of the principles

07:41.100 --> 07:43.260
 and the art's technical level of this,

07:43.260 --> 07:47.220
 but it turns out that if you ask a lot of dumb questions,

07:47.220 --> 07:48.940
 you get smarter really, really quick.

07:48.940 --> 07:51.040
 And when you're surrounded by people that want to teach

07:51.040 --> 07:54.060
 and learn themselves, it can be a beautiful thing.

07:56.100 --> 07:58.460
 So let's talk about programming languages, if it's okay.

07:58.460 --> 07:59.300
 Sure, sure.

07:59.300 --> 08:01.460
 At the highest absurd philosophical level,

08:01.460 --> 08:02.300
 because I...

08:02.300 --> 08:03.380
 Don't get romantic on me, Lex.

08:03.380 --> 08:08.380
 I will forever get romantic and torture you, I apologize.

08:09.980 --> 08:14.140
 Why do programming languages even matter?

08:14.140 --> 08:15.700
 Okay, well, thank you very much.

08:15.700 --> 08:17.420
 You're saying why should you care

08:17.420 --> 08:18.620
 about any one programming language

08:18.620 --> 08:20.940
 or why do we care about programming computers or?

08:20.940 --> 08:25.180
 No, why do we care about programming language design,

08:25.180 --> 08:27.960
 creating effective programming languages,

08:30.060 --> 08:32.620
 choosing one programming languages

08:32.620 --> 08:34.580
 such as another programming language,

08:34.580 --> 08:37.820
 why we keep struggling and improving

08:37.820 --> 08:39.820
 through the evolution of these programming languages.

08:39.820 --> 08:40.660
 Sure, sure, sure.

08:40.660 --> 08:42.100
 Okay, so I mean, I think you have to come back

08:42.100 --> 08:43.660
 to what are we trying to do here, right?

08:43.660 --> 08:47.120
 So we have these beasts called computers

08:47.120 --> 08:48.820
 that are very good at specific kinds of things

08:48.820 --> 08:52.020
 and we think it's useful to have them do it for us, right?

08:52.020 --> 08:55.540
 Now you have this question of how best to express that

08:55.540 --> 08:57.180
 because you have a human brain still

08:57.180 --> 08:58.860
 that has an idea in its head

08:58.860 --> 09:00.580
 and you want to achieve something, right?

09:00.580 --> 09:03.220
 So, well, there's lots of ways of doing this.

09:03.220 --> 09:04.740
 You can go directly to the machine

09:04.740 --> 09:06.020
 and speak assembly language

09:06.020 --> 09:07.660
 and then you can express directly

09:07.660 --> 09:09.820
 what the computer understands, that's fine.

09:10.740 --> 09:12.840
 You can then have higher and higher and higher levels

09:12.840 --> 09:14.900
 of abstraction up until machine learning

09:14.900 --> 09:18.060
 and you're designing a neural net to do the work for you.

09:18.060 --> 09:21.260
 The question is where along this way do you want to stop

09:21.260 --> 09:23.480
 and what benefits do you get out of doing so?

09:23.480 --> 09:25.300
 And so programming languages in general,

09:25.300 --> 09:30.300
 you have C, you have Fortran, Java and Ada, Pascal, Swift,

09:31.260 --> 09:33.360
 you have lots of different things.

09:33.360 --> 09:34.340
 They'll have different trade offs

09:34.340 --> 09:36.540
 and they're tackling different parts of the problems.

09:36.540 --> 09:39.940
 Now, one of the things that most programming languages do

09:39.940 --> 09:40.820
 is they're trying to make it

09:40.820 --> 09:42.780
 so that you have pretty basic things

09:42.780 --> 09:45.080
 like portability across different hardware.

09:45.080 --> 09:47.660
 So you've got, I'm gonna run on an Intel PC,

09:47.660 --> 09:49.220
 I'm gonna run on a RISC 5 PC,

09:49.220 --> 09:53.500
 I'm gonna run on a ARM phone or something like that, fine.

09:53.500 --> 09:55.580
 I wanna write one program and have it portable.

09:55.580 --> 09:57.780
 And this is something that assembly doesn't do.

09:57.780 --> 09:59.060
 Now, when you start looking

09:59.060 --> 10:00.900
 at the space of programming languages,

10:00.900 --> 10:02.460
 this is where I think it's fun

10:02.460 --> 10:06.180
 because programming languages all have trade offs

10:06.180 --> 10:07.940
 and most people will walk up to them

10:07.940 --> 10:11.000
 and they look at the surface level of syntax and say,

10:11.000 --> 10:13.860
 oh, I like curly braces or I like tabs

10:13.860 --> 10:17.180
 or I like semi colons or not or whatever, right?

10:17.180 --> 10:21.300
 Subjective, fairly subjective, very shallow things.

10:21.300 --> 10:23.180
 But programming languages when done right

10:23.180 --> 10:24.620
 can actually be very powerful.

10:24.620 --> 10:29.380
 And the benefit they bring is expression.

10:30.220 --> 10:32.580
 Okay, and if you look at programming languages,

10:32.580 --> 10:34.420
 there's really kind of two different levels to them.

10:34.420 --> 10:37.940
 One is the down in the dirt, nuts and bolts

10:37.940 --> 10:39.380
 of how do you get the computer to be efficient,

10:39.380 --> 10:40.660
 stuff like that, how they work,

10:40.660 --> 10:43.520
 type systems, compiler stuff, things like that.

10:43.520 --> 10:45.020
 The other is the UI.

10:45.860 --> 10:47.220
 And the UI for programming language

10:47.220 --> 10:48.620
 is really a design problem

10:48.620 --> 10:50.620
 and a lot of people don't think about it that way.

10:50.620 --> 10:53.660
 And the UI, you mean all that stuff with the braces and?

10:53.660 --> 10:55.980
 Yeah, all that stuff's the UI and what it is

10:55.980 --> 10:58.020
 and UI means user interface.

10:58.020 --> 11:00.380
 And so what's really going on is

11:00.380 --> 11:03.220
 it's the interface between the guts and the human.

11:04.340 --> 11:05.860
 And humans are hard, right?

11:05.860 --> 11:09.500
 Humans have feelings, they have things they like,

11:09.500 --> 11:10.700
 they have things they don't like.

11:10.700 --> 11:12.700
 And a lot of people treat programming languages

11:12.700 --> 11:16.300
 as though humans are just kind of abstract creatures

11:16.300 --> 11:17.520
 that cannot be predicted.

11:17.520 --> 11:20.740
 But it turns out that actually there is better and worse.

11:21.620 --> 11:24.960
 Like people can tell when a programming language is good

11:24.960 --> 11:26.860
 or when it was an accident, right?

11:26.860 --> 11:29.340
 And one of the things with Swift in particular

11:29.340 --> 11:30.980
 is that a tremendous amount of time

11:30.980 --> 11:33.260
 by a tremendous number of people

11:33.260 --> 11:36.660
 have been put into really polishing and making it feel good.

11:36.660 --> 11:39.080
 But it also has really good nuts and bolts underneath it.

11:39.080 --> 11:42.480
 You said that Swift makes a lot of people feel good.

11:42.480 --> 11:45.500
 How do you get to that point?

11:45.500 --> 11:50.500
 So how do you predict that tens of thousands,

11:51.660 --> 11:53.620
 hundreds of thousands of people are going to enjoy

11:53.620 --> 11:57.180
 using this user experience of this programming language?

11:57.180 --> 11:59.540
 Well, you can look at it in terms of better and worse, right?

11:59.540 --> 12:01.340
 So if you have to write lots of boilerplate

12:01.340 --> 12:03.540
 or something like that, you will feel unproductive.

12:03.540 --> 12:05.060
 And so that's a bad thing.

12:05.060 --> 12:06.700
 You can look at it in terms of safety.

12:06.700 --> 12:08.140
 If like C for example,

12:08.140 --> 12:10.060
 is what's called a memory unsafe language.

12:10.060 --> 12:11.580
 And so you get dangling pointers

12:11.580 --> 12:13.300
 and you get all these kinds of bugs

12:13.300 --> 12:15.020
 that then you have spent tons of time debugging

12:15.020 --> 12:17.740
 and it's a real pain in the butt and you feel unproductive.

12:17.740 --> 12:19.940
 And so by subtracting these things from the experience,

12:19.940 --> 12:22.620
 you get happier people.

12:22.620 --> 12:25.360
 But again, keep interrupting.

12:25.360 --> 12:27.620
 I'm sorry, but so hard to deal with.

12:29.180 --> 12:31.820
 If you look at the people that are most productive

12:31.820 --> 12:36.820
 on Stack Overflow, they have a set of priorities

12:37.440 --> 12:39.860
 that may not always correlate perfectly

12:39.860 --> 12:43.640
 with the experience of the majority of users.

12:43.640 --> 12:46.260
 If you look at the most upvoted,

12:46.260 --> 12:49.100
 quote unquote, correct answer on Stack Overflow,

12:49.100 --> 12:54.100
 it usually really sort of prioritizes

12:55.460 --> 13:00.460
 like safe code, proper code, stable code,

13:00.820 --> 13:01.860
 you know, that kind of stuff.

13:01.860 --> 13:02.980
 As opposed to like,

13:02.980 --> 13:07.060
 if I wanna use go to statements in my basic, right?

13:08.660 --> 13:09.860
 I wanna use go to statements.

13:09.860 --> 13:12.700
 Like what if 99% of people wanna use go to statements?

13:12.700 --> 13:16.620
 So you use completely improper, you know, unsafe syntax.

13:16.620 --> 13:17.940
 I don't think that people actually,

13:17.940 --> 13:19.460
 like if you boil it down and you get below

13:19.460 --> 13:21.180
 the surface level, people don't actually care

13:21.180 --> 13:24.180
 about go tos or if statements or things like this.

13:24.180 --> 13:26.780
 They care about achieving a goal, right?

13:26.780 --> 13:30.020
 So the real question is I wanna set up a web server

13:30.020 --> 13:32.300
 and I wanna do a thing, whatever.

13:32.300 --> 13:34.300
 Like how quickly can I achieve that, right?

13:34.300 --> 13:36.460
 And so from a programming language perspective,

13:36.460 --> 13:39.060
 there's really two things that matter there.

13:39.060 --> 13:41.980
 One is what libraries exist

13:41.980 --> 13:44.460
 and then how quickly can you put it together

13:44.460 --> 13:47.260
 and what are the tools around that look like, right?

13:47.260 --> 13:49.740
 And when you wanna build a library that's missing,

13:49.740 --> 13:50.580
 what do you do?

13:50.580 --> 13:53.280
 Okay, now this is where you see huge divergence

13:53.280 --> 13:55.820
 in the force between worlds, okay?

13:55.820 --> 13:57.340
 And so you look at Python, for example.

13:57.340 --> 13:59.220
 Python is really good at assembling things,

13:59.220 --> 14:02.500
 but it's not so great at building all the libraries.

14:02.500 --> 14:04.340
 And so what you get because of performance reasons,

14:04.340 --> 14:05.580
 other things like this,

14:05.580 --> 14:09.260
 is you get Python layered on top of C, for example,

14:09.260 --> 14:11.540
 and that means that doing certain kinds of things

14:11.540 --> 14:13.380
 well, it doesn't really make sense to do in Python.

14:13.380 --> 14:15.580
 Instead you do it in C and then you wrap it

14:15.580 --> 14:17.660
 and then you have, you're living in two worlds

14:17.660 --> 14:19.300
 and two worlds never is really great

14:19.300 --> 14:21.900
 because tooling and the debugger doesn't work right

14:21.900 --> 14:23.800
 and like all these kinds of things.

14:23.800 --> 14:25.940
 Can you clarify a little bit what you mean

14:25.940 --> 14:28.580
 by Python is not good at building libraries,

14:28.580 --> 14:30.460
 meaning it doesn't make it conducive.

14:30.460 --> 14:31.540
 Certain kinds of libraries.

14:31.540 --> 14:34.860
 No, but just the actual meaning of the sentence,

14:35.900 --> 14:38.400
 meaning like it's not conducive to developers

14:38.400 --> 14:40.520
 to come in and add libraries

14:40.520 --> 14:44.780
 or is it the duality of the,

14:44.780 --> 14:48.100
 it's a dance between Python and C and...

14:48.100 --> 14:49.460
 Well, so Python's amazing.

14:49.460 --> 14:50.420
 Python's a great language.

14:50.420 --> 14:53.420
 I did not mean to say that Python is bad for libraries.

14:53.420 --> 14:56.820
 What I meant to say is there are libraries

14:56.820 --> 15:00.440
 that Python's really good at that you can write in Python,

15:00.440 --> 15:01.280
 but there are other things,

15:01.280 --> 15:03.600
 like if you wanna build a machine learning framework,

15:03.600 --> 15:05.020
 you're not gonna build a machine learning framework

15:05.020 --> 15:07.380
 in Python because of performance, for example,

15:07.380 --> 15:10.180
 or you want GPU acceleration or things like this.

15:10.180 --> 15:13.260
 Instead, what you do is you write a bunch of C

15:13.260 --> 15:15.300
 or C++ code or something like that,

15:15.300 --> 15:18.460
 and then you talk to it from Python, right?

15:18.460 --> 15:21.100
 And so this is because of decisions

15:21.100 --> 15:23.140
 that were made in the Python design

15:23.140 --> 15:27.140
 and those decisions have other counterbalancing forces.

15:27.140 --> 15:29.880
 But the trick when you start looking at this

15:29.880 --> 15:31.340
 from a programming language perspective,

15:31.340 --> 15:33.220
 you start to say, okay, cool.

15:33.220 --> 15:36.380
 How do I build this catalog of libraries

15:36.380 --> 15:37.860
 that are really powerful?

15:37.860 --> 15:40.520
 And how do I make it so that then they can be assembled

15:40.520 --> 15:42.100
 into ways that feel good

15:42.100 --> 15:44.020
 and they generally work the first time?

15:44.020 --> 15:46.900
 Because when you're talking about building a thing,

15:46.900 --> 15:50.220
 you have to include the debugging, the fixing,

15:50.220 --> 15:51.900
 the turnaround cycle, the development cycle,

15:51.900 --> 15:52.980
 all that kind of stuff

15:53.940 --> 15:56.040
 into the process of building the thing.

15:56.040 --> 15:58.300
 It's not just about pounding out the code.

15:58.300 --> 16:01.300
 And so this is where things like catching bugs

16:01.300 --> 16:04.220
 at compile time is valuable, for example.

16:04.220 --> 16:07.600
 But if you dive into the details in this,

16:07.600 --> 16:10.580
 Swift, for example, has certain things like value semantics,

16:10.580 --> 16:11.980
 which is this fancy way of saying

16:11.980 --> 16:16.440
 that when you treat a variable like a value,

16:18.460 --> 16:21.460
 it acts like a mathematical object would.

16:21.460 --> 16:25.180
 Okay, so you have used PyTorch a little bit.

16:25.180 --> 16:26.620
 In PyTorch, you have tensors.

16:26.620 --> 16:31.620
 Tensors are n dimensional grid of numbers, very simple.

16:31.940 --> 16:34.660
 You can do plus and other operators on them.

16:34.660 --> 16:35.840
 It's all totally fine.

16:35.840 --> 16:38.180
 But why do you need to clone a tensor sometimes?

16:39.140 --> 16:40.820
 Have you ever run into that?

16:40.820 --> 16:41.660
 Yeah.

16:41.660 --> 16:42.780
 Okay, and so why is that?

16:42.780 --> 16:43.900
 Why do you need to clone a tensor?

16:43.900 --> 16:46.820
 It's the usual object thing that's in Python.

16:46.820 --> 16:49.300
 So in Python, and just like with Java

16:49.300 --> 16:51.540
 and many other languages, this isn't unique to Python.

16:51.540 --> 16:53.740
 In Python, it has a thing called reference semantics,

16:53.740 --> 16:55.700
 which is the nerdy way of explaining this.

16:55.700 --> 16:58.060
 And what that means is you actually have a pointer

16:58.060 --> 17:01.080
 do a thing instead of the thing, okay?

17:01.080 --> 17:05.220
 Now, this is due to a bunch of implementation details

17:05.220 --> 17:06.780
 that you don't want to go into.

17:06.780 --> 17:09.540
 But in Swift, you have this thing called value semantics.

17:09.540 --> 17:12.140
 And so when you have a tensor in Swift, it is a value.

17:12.140 --> 17:15.060
 If you copy it, it looks like you have a unique copy.

17:15.060 --> 17:16.780
 And if you go change one of those copies,

17:16.780 --> 17:19.340
 then it doesn't update the other one

17:19.340 --> 17:21.420
 because you just made a copy of this thing, right?

17:21.420 --> 17:24.300
 So that's like highly error prone

17:24.300 --> 17:29.180
 in at least computer science, math centric disciplines

17:29.180 --> 17:33.520
 about Python, that like the thing you would expect

17:33.520 --> 17:35.420
 to behave like math.

17:35.420 --> 17:38.260
 Like math, it doesn't behave like math.

17:38.260 --> 17:41.660
 And in fact, quietly it doesn't behave like math

17:41.660 --> 17:43.220
 and then can ruin the entirety of your math thing.

17:43.220 --> 17:44.060
 Exactly.

17:44.060 --> 17:45.980
 Well, and then it puts you in debugging land again.

17:45.980 --> 17:46.820
 Yeah.

17:46.820 --> 17:48.580
 Right now, you just want to get something done

17:48.580 --> 17:51.500
 and you're like, wait a second, where do I need to put clone?

17:51.500 --> 17:54.180
 And what level of the stack, which is very complicated,

17:54.180 --> 17:56.780
 which I thought I was reusing somebody's library

17:56.780 --> 17:57.860
 and now I need to understand it

17:57.860 --> 17:59.620
 to know where to clone a thing, right?

17:59.620 --> 18:01.280
 And hard to debug, by the way.

18:01.280 --> 18:02.120
 Exactly, right.

18:02.120 --> 18:04.340
 And so this is where programming languages really matter.

18:04.340 --> 18:06.300
 Right, and so in Swift having value semantics

18:06.300 --> 18:10.300
 so that both you get the benefit of math,

18:10.300 --> 18:12.340
 working like math, right?

18:12.340 --> 18:15.120
 But also the efficiency that comes with certain advantages

18:15.120 --> 18:17.340
 there, certain implementation details there

18:17.340 --> 18:18.860
 really benefit you as a programmer, right?

18:18.860 --> 18:20.620
 Can you clarify the value semantics?

18:20.620 --> 18:22.900
 Like how do you know that a thing should be treated

18:22.900 --> 18:23.740
 like a value?

18:23.740 --> 18:27.740
 Yeah, so Swift has a pretty strong culture

18:27.740 --> 18:30.420
 and good language support for defining values.

18:30.420 --> 18:31.960
 And so if you have an array,

18:31.960 --> 18:34.860
 so tensors are one example that the machine learning folks

18:34.860 --> 18:36.500
 are very used to.

18:36.500 --> 18:38.280
 Just think about arrays, same thing,

18:38.280 --> 18:41.640
 where you have an array, you create an array,

18:41.640 --> 18:43.900
 you put two or three or four things into it,

18:43.900 --> 18:46.940
 and then you pass it off to another function.

18:46.940 --> 18:51.380
 What happens if that function adds some more things to it?

18:51.380 --> 18:54.300
 Well, you'll see it on the side that you pass it in, right?

18:54.300 --> 18:56.680
 This is called reference semantics.

18:56.680 --> 19:01.220
 Now, what if you pass an array off to a function,

19:01.220 --> 19:02.860
 it scrolls it away in some dictionary

19:02.860 --> 19:04.880
 or some other data structure somewhere, right?

19:04.880 --> 19:07.980
 Well, it thought that you just handed it that array,

19:07.980 --> 19:10.780
 then you return back and that reference to that array

19:10.780 --> 19:12.820
 still exists in the caller,

19:12.820 --> 19:15.780
 and they go and put more stuff in it, right?

19:15.780 --> 19:17.860
 The person you handed it off to

19:17.860 --> 19:20.260
 may have thought they had the only reference to that,

19:20.260 --> 19:22.860
 and so they didn't know that this was gonna change

19:22.860 --> 19:23.940
 underneath the covers.

19:23.940 --> 19:26.220
 And so this is where you end up having to do clone.

19:26.220 --> 19:27.820
 So like I was passed a thing,

19:27.820 --> 19:30.240
 I'm not sure if I have the only version of it,

19:30.240 --> 19:32.260
 so now I have to clone it.

19:32.260 --> 19:34.680
 So what value semantics does is it allows you to say,

19:34.680 --> 19:38.380
 hey, I have a, so in Swift, it defaults to value semantics.

19:38.380 --> 19:40.260
 Oh, so it defaults to value semantics,

19:40.260 --> 19:42.460
 and then because most things

19:42.460 --> 19:44.100
 should end up being like values,

19:44.100 --> 19:46.100
 then it makes sense for that to be the default.

19:46.100 --> 19:47.240
 And one of the important things about that

19:47.240 --> 19:48.740
 is that arrays and dictionaries

19:48.740 --> 19:49.940
 and all these other collections

19:49.940 --> 19:51.300
 that are aggregations of other things

19:51.300 --> 19:53.020
 also have value semantics.

19:53.020 --> 19:55.060
 And so when you pass this around

19:55.060 --> 19:56.680
 to different parts of your program,

19:56.680 --> 19:59.180
 you don't have to do these defensive copies.

19:59.180 --> 20:01.260
 And so this is great for two sides, right?

20:01.260 --> 20:04.220
 It's great because you define away the bug,

20:04.220 --> 20:05.980
 which is a big deal for productivity,

20:05.980 --> 20:08.220
 the number one thing most people care about,

20:08.220 --> 20:09.740
 but it's also good for performance

20:09.740 --> 20:11.580
 because when you're doing a clone,

20:11.580 --> 20:13.460
 so you pass the array down to the thing,

20:13.460 --> 20:15.420
 it's like, I don't know if anybody else has it,

20:15.420 --> 20:16.620
 I have to clone it.

20:16.620 --> 20:18.460
 Well, you just did a copy of a bunch of data.

20:18.460 --> 20:19.940
 It could be big.

20:19.940 --> 20:21.980
 And then it could be that the thing that called you

20:21.980 --> 20:24.020
 is not keeping track of the old thing.

20:24.020 --> 20:25.700
 So you just made a copy of it,

20:25.700 --> 20:27.800
 and you may not have had to.

20:27.800 --> 20:30.180
 And so the way the value semantics work in Swift

20:30.180 --> 20:32.060
 is it uses this thing called copy on write,

20:32.060 --> 20:35.500
 which means that you get the benefit of safety

20:35.500 --> 20:36.420
 and performance.

20:36.420 --> 20:38.340
 And it has another special trick

20:38.340 --> 20:41.180
 because if you think certain languages like Java,

20:41.180 --> 20:43.940
 for example, they have immutable strings.

20:43.940 --> 20:44.940
 And so what they're trying to do

20:44.940 --> 20:46.400
 is they provide value semantics

20:46.400 --> 20:48.980
 by having pure immutability.

20:48.980 --> 20:51.060
 Functional languages have pure immutability

20:51.060 --> 20:52.300
 in lots of different places,

20:52.300 --> 20:53.960
 and this provides a much safer model

20:53.960 --> 20:56.140
 and it provides value semantics.

20:56.140 --> 20:58.380
 The problem with this is if you have immutability,

20:58.380 --> 20:59.500
 everything is expensive.

20:59.500 --> 21:00.980
 Everything requires a copy.

21:02.420 --> 21:05.420
 For example, in Java, if you have a string X

21:05.420 --> 21:07.900
 and a string Y, you append them together,

21:07.900 --> 21:11.060
 we have to allocate a new string to hold X, Y.

21:12.180 --> 21:13.720
 If they're immutable.

21:13.720 --> 21:16.900
 Well, strings in Java are immutable.

21:16.900 --> 21:19.580
 And if there's optimizations for short ones,

21:19.580 --> 21:22.820
 it's complicated, but generally think about them

21:22.820 --> 21:24.580
 as a separate allocation.

21:24.580 --> 21:26.620
 And so when you append them together,

21:26.620 --> 21:28.580
 you have to go allocate a third thing

21:28.580 --> 21:29.660
 because somebody might have a pointer

21:29.660 --> 21:31.060
 to either of the other ones, right?

21:31.060 --> 21:32.060
 And you can't go change them.

21:32.060 --> 21:34.700
 So you have to go allocate a third thing.

21:34.700 --> 21:36.740
 Because of the beauty of how the Swift value semantics

21:36.740 --> 21:38.780
 system works out, if you have a string in Swift

21:38.780 --> 21:40.980
 and you say, hey, put in X, right?

21:40.980 --> 21:43.720
 And they say, append on Y, Z, W,

21:44.980 --> 21:47.500
 it knows that there's only one reference to that.

21:47.500 --> 21:49.300
 And so it can do an in place update.

21:50.220 --> 21:53.420
 And so you're not allocating tons of stuff on the side.

21:53.420 --> 21:54.620
 You don't have all those problems.

21:54.620 --> 21:56.040
 When you pass it off,

21:56.040 --> 21:57.520
 you can know you have the only reference.

21:57.520 --> 21:59.340
 If you pass it off to multiple different people,

21:59.340 --> 22:02.620
 but nobody changes it, they can all share the same thing.

22:02.620 --> 22:05.780
 So you get a lot of the benefit of purely immutable design.

22:05.780 --> 22:07.640
 And so you get a really nice sweet spot

22:07.640 --> 22:09.300
 that I haven't seen in other languages.

22:09.300 --> 22:10.540
 Yeah, that's interesting.

22:10.540 --> 22:15.540
 I thought there was going to be a philosophical narrative

22:15.780 --> 22:19.420
 here that you're gonna have to pay a cost for it.

22:19.420 --> 22:24.420
 Cause it sounds like, I think value semantics

22:24.500 --> 22:27.440
 is beneficial for easing of debugging

22:27.440 --> 22:30.980
 or minimizing the risk of errors,

22:30.980 --> 22:34.220
 like bringing the errors closer to the source,

22:35.780 --> 22:38.180
 bringing the symptom of the error closer

22:38.180 --> 22:40.840
 to the source of the error, however you say that.

22:40.840 --> 22:44.980
 But you're saying there's not a performance cost either

22:44.980 --> 22:46.300
 if you implement it correctly.

22:46.300 --> 22:48.300
 Well, so there's trade offs with everything.

22:48.300 --> 22:51.860
 And so if you are doing very low level stuff,

22:51.860 --> 22:53.180
 then sometimes you can notice a cost,

22:53.180 --> 22:54.880
 but then what you're doing is you're saying,

22:54.880 --> 22:56.540
 what is the right default?

22:56.540 --> 22:59.100
 So coming back to user interface,

22:59.100 --> 23:00.740
 when you talk about programming languages,

23:00.740 --> 23:03.000
 one of the major things that Swift does

23:03.000 --> 23:04.500
 that makes people love it,

23:04.500 --> 23:08.220
 that is not obvious when it comes to designing a language

23:08.220 --> 23:11.460
 is this UI principle of progressive disclosure

23:11.460 --> 23:12.980
 of complexity.

23:12.980 --> 23:16.700
 Okay, so Swift, like many languages is very powerful.

23:16.700 --> 23:18.420
 The question is, when do you have to learn

23:18.420 --> 23:19.500
 the power as a user?

23:20.820 --> 23:22.980
 So Swift, like Python, allows you to start with like,

23:22.980 --> 23:24.940
 print hello world, right?

23:24.940 --> 23:26.920
 Certain other languages start with like,

23:26.920 --> 23:29.020
 public static void main class,

23:30.580 --> 23:32.140
 like all the ceremony, right?

23:32.140 --> 23:34.620
 And so you go to teach a new person,

23:34.620 --> 23:36.780
 hey, welcome to this new thing.

23:36.780 --> 23:40.300
 Let's talk about public access control classes.

23:40.300 --> 23:41.140
 Wait, what's that?

23:41.140 --> 23:44.740
 String system.out.println, like packages,

23:44.740 --> 23:46.700
 like, God, right?

23:46.700 --> 23:48.700
 And so instead, if you take this and you say,

23:48.700 --> 23:51.740
 hey, we need packages, modules,

23:51.740 --> 23:54.220
 we need powerful things like classes,

23:54.220 --> 23:57.380
 we need data structures, we need like all these things.

23:57.380 --> 23:59.420
 The question is, how do you factor the complexity?

23:59.420 --> 24:02.820
 And how do you make it so that the normal case scenario

24:02.820 --> 24:05.620
 is you're dealing with things that work the right way

24:05.620 --> 24:07.940
 in the right way, give you good performance

24:07.940 --> 24:11.140
 by default, but then as a power user,

24:11.140 --> 24:12.340
 if you want to dive down to it,

24:12.340 --> 24:15.140
 you have full C performance, full control

24:15.140 --> 24:15.980
 over low level pointers.

24:15.980 --> 24:18.340
 You can call malloc if you want to call malloc.

24:18.340 --> 24:20.780
 This is not recommended on the first page of every tutorial,

24:20.780 --> 24:22.300
 but it's actually really important

24:22.300 --> 24:23.780
 when you want to get work done, right?

24:23.780 --> 24:27.460
 And so being able to have that is really the design

24:27.460 --> 24:28.820
 in programming language design,

24:28.820 --> 24:31.300
 and design is really, really hard.

24:31.300 --> 24:34.940
 It's something that I think a lot of people kind of,

24:34.940 --> 24:37.900
 outside of UI, again, a lot of people just think

24:37.900 --> 24:40.940
 is subjective, like there's nothing,

24:40.940 --> 24:43.620
 you know, it's just like curly braces or whatever.

24:43.620 --> 24:45.340
 It's just like somebody's preference,

24:45.340 --> 24:48.740
 but actually good design is something that you can feel.

24:48.740 --> 24:52.100
 And how many people are involved with good design?

24:52.100 --> 24:54.860
 So if we looked at Swift, but look at historically,

24:54.860 --> 24:57.340
 I mean, this might touch like,

24:57.340 --> 24:59.700
 it's almost like a Steve Jobs question too,

24:59.700 --> 25:04.100
 like how much dictatorial decision making is required

25:04.100 --> 25:09.100
 versus collaborative, and we'll talk about

25:09.100 --> 25:11.700
 how all that can go wrong or right, but.

25:11.700 --> 25:14.340
 Yeah, well, Swift, so I can't speak to in general,

25:14.340 --> 25:15.540
 all design everywhere.

25:15.540 --> 25:19.740
 So the way it works with Swift is that there's a core team,

25:19.740 --> 25:22.460
 and so a core team is six or seven people ish,

25:22.460 --> 25:25.020
 something like that, that is people that have been working

25:25.020 --> 25:27.100
 with Swift since very early days, and so.

25:27.100 --> 25:30.060
 And by early days is not that long ago.

25:30.060 --> 25:33.580
 Okay, yeah, so it became public in 2014,

25:33.580 --> 25:35.500
 so it's been six years public now,

25:35.500 --> 25:38.820
 but so that's enough time that there's a story arc there.

25:38.820 --> 25:41.940
 Okay, yeah, and there's mistakes have been made

25:41.940 --> 25:43.700
 that then get fixed, and you learn something,

25:43.700 --> 25:46.980
 and then you, you know, and so what the core team does

25:46.980 --> 25:50.420
 is it provides continuity, and so you wanna have a,

25:50.420 --> 25:54.020
 okay, well, there's a big hole that we wanna fill.

25:54.020 --> 25:56.900
 We know we wanna fill it, so don't do other things

25:56.900 --> 25:59.940
 that invade that space until we fill the hole, right?

25:59.940 --> 26:01.100
 There's a boulder that's missing here,

26:01.100 --> 26:03.060
 we wanna do, we will do that boulder,

26:03.060 --> 26:06.100
 even though it's not today, keep out of that space.

26:06.100 --> 26:10.340
 And the whole team remembers the myth of the boulder

26:10.340 --> 26:11.180
 that's there.

26:11.180 --> 26:12.540
 Yeah, yeah, there's a general sense

26:12.540 --> 26:14.460
 of what the future looks like in broad strokes,

26:14.460 --> 26:16.460
 and a shared understanding of that,

26:16.460 --> 26:18.780
 combined with a shared understanding of what has happened

26:18.780 --> 26:22.100
 in the past that worked out well and didn't work out well.

26:22.100 --> 26:24.260
 The next level out is you have the,

26:24.260 --> 26:25.820
 what's called the Swift evolution community,

26:25.820 --> 26:27.700
 and you've got, in that case, hundreds of people

26:27.700 --> 26:30.980
 that really care passionately about the way Swift evolves,

26:30.980 --> 26:33.900
 and that's like an amazing thing to, again,

26:33.900 --> 26:35.540
 the core team doesn't necessarily need to come up

26:35.540 --> 26:36.820
 with all the good ideas.

26:36.820 --> 26:38.060
 You got hundreds of people out there

26:38.060 --> 26:39.020
 that care about something,

26:39.020 --> 26:41.100
 and they come up with really good ideas too,

26:41.100 --> 26:45.180
 and that provides this rock tumbler for ideas.

26:45.180 --> 26:48.780
 And so the evolution process is,

26:48.780 --> 26:50.380
 a lot of people in a discourse forum,

26:50.380 --> 26:52.100
 they're like hashing it out and trying to talk about,

26:52.100 --> 26:54.100
 okay, well, should we go left or right,

26:54.100 --> 26:55.700
 or if we did this, what would be good?

26:55.700 --> 26:57.700
 And here you're talking about hundreds of people,

26:57.700 --> 27:00.380
 so you're not gonna get consensus, necessarily,

27:00.380 --> 27:04.620
 not obvious consensus, and so there's a proposal process

27:04.620 --> 27:07.660
 that then allows the core team and the community

27:07.660 --> 27:10.020
 to work this out, and what the core team does

27:10.020 --> 27:12.820
 is it aims to get consensus out of the community

27:12.820 --> 27:17.420
 and provide guardrails, but also provide long term,

27:17.420 --> 27:20.380
 make sure we're going the right direction kind of things.

27:20.380 --> 27:23.540
 So does that group represent like the,

27:23.540 --> 27:27.420
 how much people will love the user interface?

27:27.420 --> 27:29.420
 Like, do you think they're able to capture that?

27:29.420 --> 27:31.020
 Well, I mean, it's something we talk about a lot,

27:31.020 --> 27:32.340
 it's something we care about.

27:32.340 --> 27:34.780
 How well we do that's up for debate,

27:34.780 --> 27:36.780
 but I think that we've done pretty well so far.

27:36.780 --> 27:38.540
 Is the beginner in mind?

27:38.540 --> 27:39.380
 Yeah. Like, because you said

27:39.380 --> 27:40.780
 the progressive disclosure complexity.

27:40.780 --> 27:44.180
 Yeah, so we care a lot about that,

27:44.180 --> 27:46.420
 a lot about power, a lot about efficiency,

27:46.420 --> 27:48.700
 a lot about, there are many factors to good design,

27:48.700 --> 27:50.100
 and you have to figure out a way

27:50.100 --> 27:53.300
 to kind of work your way through that, and.

27:53.300 --> 27:57.540
 So if you think about, like the language I love is Lisp,

27:57.540 --> 27:59.340
 probably still because I use Emacs,

27:59.340 --> 28:02.180
 but I haven't done anything, any serious work in Lisp,

28:02.180 --> 28:05.020
 but it has a ridiculous amount of parentheses.

28:05.020 --> 28:06.540
 Yeah.

28:06.540 --> 28:11.540
 I've also, you know, with Java and C++, the braces,

28:14.300 --> 28:17.500
 you know, I like, I enjoyed the comfort

28:17.500 --> 28:20.580
 of being between braces, you know?

28:20.580 --> 28:21.420
 Yeah, yeah, well, let's talk.

28:21.420 --> 28:23.140
 And then Python is, sorry to interrupt,

28:23.140 --> 28:25.740
 just like, and last thing to me, as a designer,

28:25.740 --> 28:28.740
 if I was a language designer, God forbid,

28:28.740 --> 28:33.740
 is I would be very surprised that Python with no braces

28:34.020 --> 28:38.220
 would nevertheless somehow be comforting also.

28:38.220 --> 28:40.620
 So like, I could see arguments for all of this.

28:40.620 --> 28:41.940
 But look at this, this is evidence

28:41.940 --> 28:44.260
 that it's not about braces versus tabs.

28:44.260 --> 28:47.020
 Right, exactly, you're good, that's a good point.

28:47.020 --> 28:50.020
 Right, so like, you know, there's evidence that.

28:50.020 --> 28:52.380
 But see, like, it's one of the most argued about things.

28:52.380 --> 28:54.140
 Oh yeah, of course, just like tabs and spaces,

28:54.140 --> 28:57.180
 which it doesn't, I mean, there's one obvious right answer,

28:57.180 --> 28:59.140
 but it doesn't actually matter.

28:59.140 --> 28:59.980
 What's that?

28:59.980 --> 29:01.780
 Let's not, like, come on, we're friends.

29:01.780 --> 29:03.460
 Like, come on, what are you trying to do to me here?

29:03.460 --> 29:05.500
 People are gonna, yeah, half the people are gonna tune out.

29:05.500 --> 29:09.420
 Yeah, so these, so you're able to identify things

29:09.420 --> 29:12.620
 that don't really matter for the experience.

29:12.620 --> 29:14.780
 Well, no, no, no, it's always a really hard,

29:14.780 --> 29:16.900
 so the easy decisions are easy, right?

29:16.900 --> 29:19.540
 I mean, fine, those are not the interesting ones.

29:19.540 --> 29:21.780
 The hard ones are the ones that are most interesting, right?

29:21.780 --> 29:23.580
 The hard ones are the places where,

29:23.580 --> 29:27.020
 hey, we wanna do a thing, everybody agrees we should do it,

29:27.020 --> 29:28.900
 there's one proposal on the table,

29:28.900 --> 29:31.580
 but it has all these bad things associated with it.

29:31.580 --> 29:33.740
 Well, okay, what are we gonna do about that?

29:33.740 --> 29:34.980
 Do we just take it?

29:34.980 --> 29:36.260
 Do we delay it?

29:36.260 --> 29:38.500
 Do we say, hey, well, maybe there's this other feature

29:38.500 --> 29:41.500
 that if we do that first, this will work out better.

29:41.500 --> 29:44.060
 How does this, if we do this,

29:44.060 --> 29:46.180
 are we paying ourselves into a corner, right?

29:46.180 --> 29:47.340
 And so this is where, again,

29:47.340 --> 29:48.580
 you're having that core team of people

29:48.580 --> 29:51.660
 that has some continuity and has perspective,

29:51.660 --> 29:53.620
 has some of the historical understanding,

29:53.620 --> 29:56.100
 is really valuable because you get,

29:56.100 --> 29:57.180
 it's not just like one brain,

29:57.180 --> 29:59.220
 you get the power of multiple people coming together

29:59.220 --> 30:00.100
 to make good decisions,

30:00.100 --> 30:02.500
 and then you get the best out of all these people,

30:02.500 --> 30:06.300
 and you also can harness the community around it.

30:06.300 --> 30:09.380
 And what about the decision of whether in Python

30:09.380 --> 30:14.140
 having one type or having strict typing?

30:14.140 --> 30:15.100
 Yeah, okay.

30:15.100 --> 30:16.060
 Yeah, let's talk about this.

30:16.060 --> 30:19.580
 So I like how you put that, by the way.

30:19.580 --> 30:21.900
 So many people would say that Python doesn't have types.

30:21.900 --> 30:22.900
 Doesn't have types, yeah.

30:22.900 --> 30:23.740
 But you're right.

30:23.740 --> 30:26.660
 I haven't listened to you enough to where,

30:26.660 --> 30:29.940
 I'm a fan of yours and I've listened to way too many

30:29.940 --> 30:32.460
 podcasts and videos of you talking about this stuff.

30:32.460 --> 30:34.780
 Oh yeah, so I would argue that Python has one type.

30:34.780 --> 30:38.180
 And so like when you import Python into Swift,

30:38.180 --> 30:39.780
 which by the way works really well,

30:39.780 --> 30:41.820
 you have everything comes in as a Python object.

30:41.820 --> 30:43.980
 Now here are their trade offs because

30:46.220 --> 30:47.460
 it depends on what you're optimizing for.

30:47.460 --> 30:49.300
 And Python is a super successful language

30:49.300 --> 30:51.060
 for a really good reason.

30:51.060 --> 30:52.740
 Because it has one type,

30:52.740 --> 30:55.340
 you get duck typing for free and things like this.

30:55.340 --> 30:56.940
 But also you're pushing,

30:56.940 --> 31:00.580
 you're making it very easy to pound out code on one hand,

31:00.580 --> 31:03.580
 but you're also making it very easy to introduce

31:03.580 --> 31:05.260
 complicated bugs that you have to debug.

31:05.260 --> 31:08.180
 And you pass a string into something that expects an integer

31:08.180 --> 31:10.220
 and it doesn't immediately die.

31:10.220 --> 31:12.060
 It goes all the way down the stack trace

31:12.060 --> 31:13.460
 and you find yourself in the middle of some code

31:13.460 --> 31:14.900
 that you really didn't want to know anything about.

31:14.900 --> 31:16.420
 And it blows up and you're just saying,

31:16.420 --> 31:18.180
 well, what did I do wrong, right?

31:18.180 --> 31:21.740
 And so types are good and bad and they have trade offs.

31:21.740 --> 31:23.620
 They're good for performance and certain other things

31:23.620 --> 31:24.740
 depending on where you're coming from,

31:24.740 --> 31:26.340
 but it's all about trade offs.

31:26.340 --> 31:28.580
 And so this is what design is, right?

31:28.580 --> 31:30.220
 Design is about weighing trade offs

31:30.220 --> 31:32.580
 and trying to understand the ramifications

31:32.580 --> 31:34.300
 of the things that you're weighing,

31:34.300 --> 31:37.300
 like types or not, or one type or many types.

31:38.660 --> 31:39.820
 But also within many types,

31:39.820 --> 31:41.740
 how powerful do you make that type system

31:41.740 --> 31:44.500
 is another very complicated question

31:44.500 --> 31:45.380
 with lots of trade offs.

31:45.380 --> 31:47.540
 It's very interesting by the way,

31:47.540 --> 31:52.540
 but that's like one dimension and there's a bunch

31:52.620 --> 31:55.260
 of other dimensions, JIT compiled versus static compiled,

31:55.260 --> 31:57.820
 garbage collected versus reference counted

31:57.820 --> 32:00.900
 versus manual memory management versus,

32:00.900 --> 32:02.980
 like in like all these different trade offs

32:02.980 --> 32:03.820
 and how you balance them

32:03.820 --> 32:05.580
 are what make a program language good.

32:05.580 --> 32:06.820
 Concurrency.

32:06.820 --> 32:07.660
 Yeah.

32:07.660 --> 32:09.860
 So in all those things, I guess,

32:09.860 --> 32:11.300
 when you're designing the language,

32:11.300 --> 32:13.020
 you also have to think of how that's gonna get

32:13.020 --> 32:15.220
 all compiled down to.

32:15.220 --> 32:17.420
 If you care about performance, yeah.

32:17.420 --> 32:18.780
 Well, and go back to Lisp, right?

32:18.780 --> 32:20.940
 So Lisp also, I would say JavaScript

32:20.940 --> 32:24.100
 is another example of a very simple language, right?

32:24.100 --> 32:27.220
 And so one of the, so I also love Lisp.

32:27.220 --> 32:29.780
 I don't use it as much as maybe you do or you did.

32:29.780 --> 32:32.500
 No, I think we're both, everyone who loves Lisp,

32:32.500 --> 32:35.140
 it's like, you love, it's like, I don't know,

32:35.140 --> 32:36.260
 I love Frank Sinatra,

32:36.260 --> 32:39.180
 but like how often do I seriously listen to Frank Sinatra?

32:39.180 --> 32:40.020
 Sure, sure.

32:40.020 --> 32:42.780
 But you look at that or you look at JavaScript,

32:42.780 --> 32:44.100
 which is another very different,

32:44.100 --> 32:45.980
 but relatively simple language.

32:45.980 --> 32:47.740
 And there are certain things that don't exist

32:47.740 --> 32:49.140
 in the language,

32:49.140 --> 32:51.900
 but there is inherent complexity to the problems

32:51.900 --> 32:53.140
 that we're trying to model.

32:53.140 --> 32:54.660
 And so what happens to the complexity?

32:54.660 --> 32:57.220
 In the case of both of them, for example,

32:57.220 --> 33:00.100
 you say, well, what about large scale software development?

33:00.100 --> 33:02.380
 Okay, well, you need something like packages.

33:02.380 --> 33:05.780
 Neither language has a language affordance for packages.

33:05.780 --> 33:07.420
 And so what you get is patterns.

33:07.420 --> 33:08.700
 You get things like NPN.

33:08.700 --> 33:12.060
 You get things like these ecosystems that get built around.

33:12.060 --> 33:15.140
 And I'm a believer that if you don't model

33:15.140 --> 33:17.740
 at least the most important inherent complexity

33:17.740 --> 33:18.740
 in the language,

33:18.740 --> 33:19.620
 then what ends up happening

33:19.620 --> 33:21.740
 is that complexity gets pushed elsewhere.

33:22.740 --> 33:24.100
 And when it gets pushed elsewhere,

33:24.100 --> 33:26.580
 sometimes that's great because often building things

33:26.580 --> 33:28.900
 as libraries is very flexible and very powerful

33:28.900 --> 33:30.700
 and allows you to evolve and things like that.

33:30.700 --> 33:34.020
 But often it leads to a lot of unnecessary divergence

33:34.020 --> 33:35.580
 in the force and fragmentation.

33:35.580 --> 33:39.540
 And when that happens, you just get kind of a mess.

33:39.540 --> 33:42.940
 And so the question is, how do you balance that?

33:42.940 --> 33:44.260
 Don't put too much stuff in the language

33:44.260 --> 33:45.220
 because that's really expensive

33:45.220 --> 33:46.740
 and it makes things complicated.

33:46.740 --> 33:49.620
 But how do you model enough of the inherent complexity

33:49.620 --> 33:52.380
 of the problem that you provide the framework

33:52.380 --> 33:54.860
 and the structure for people to think about?

33:54.860 --> 33:57.220
 Well, so the key thing to think about

33:57.220 --> 33:59.060
 with programming languages,

33:59.060 --> 34:01.340
 and you think about what a programming language is therefore,

34:01.340 --> 34:04.220
 is it's about making a human more productive, right?

34:04.220 --> 34:07.100
 And so there's an old, I think it's Steve Jobs quote

34:07.100 --> 34:10.420
 about it's a bicycle for the mind, right?

34:10.420 --> 34:13.020
 You can definitely walk,

34:13.020 --> 34:15.260
 but you'll get there a lot faster

34:15.260 --> 34:17.540
 if you can bicycle on your way.

34:17.540 --> 34:18.380
 And...

34:18.380 --> 34:20.140
 A programming language is a bicycle for the mind?

34:20.140 --> 34:20.980
 Yeah.

34:20.980 --> 34:22.140
 Is it basically, wow,

34:22.140 --> 34:23.900
 that's really interesting way to think about it.

34:23.900 --> 34:25.540
 By raising the level of abstraction,

34:25.540 --> 34:27.380
 now you can fit more things in your head.

34:27.380 --> 34:30.100
 By being able to just directly leverage somebody's library,

34:30.100 --> 34:33.420
 you can now get something done quickly.

34:33.420 --> 34:36.180
 In the case of Swift, Swift UI is this new framework

34:36.180 --> 34:39.780
 that Apple has released recently for doing UI programming.

34:39.780 --> 34:42.980
 And it has this declarative programming model,

34:42.980 --> 34:45.660
 which defines away entire classes of bugs.

34:45.660 --> 34:48.820
 It builds on value semantics and many other nice Swift things.

34:48.820 --> 34:51.620
 And what this does is it allows you to just get way more done

34:51.620 --> 34:53.260
 with way less code.

34:53.260 --> 34:56.580
 And now your productivity as a developer is much higher,

34:56.580 --> 34:57.420
 right?

34:57.420 --> 34:59.420
 And so that's really what programming languages

34:59.420 --> 35:00.260
 should be about,

35:00.260 --> 35:01.780
 is it's not about tabs versus spaces

35:01.780 --> 35:03.300
 or curly braces or whatever.

35:03.300 --> 35:05.380
 It's about how productive do you make the person.

35:05.380 --> 35:08.980
 And you can only see that when you have libraries

35:08.980 --> 35:11.060
 that were built with the right intention

35:11.060 --> 35:13.740
 that the language was designed for.

35:13.740 --> 35:16.620
 And with Swift, I think we're still a little bit early,

35:16.620 --> 35:19.460
 but Swift UI and many other things that are coming out now

35:19.460 --> 35:20.300
 are really showing that.

35:20.300 --> 35:22.500
 And I think that they're opening people's eyes.

35:22.500 --> 35:25.180
 It's kind of interesting to think about like how

35:26.300 --> 35:29.620
 that the knowledge of something,

35:29.620 --> 35:31.620
 of how good the bicycle is,

35:31.620 --> 35:33.740
 how people learn about that.

35:33.740 --> 35:36.020
 So I've used C++,

35:36.020 --> 35:38.980
 now this is not going to be a trash talking session

35:38.980 --> 35:41.820
 about C++, but I used C++ for a really long time.

35:41.820 --> 35:45.100
 You can go there if you want, I have the scars.

35:45.100 --> 35:49.580
 I feel like I spent many years without realizing

35:49.580 --> 35:51.500
 like there's languages that could,

35:51.500 --> 35:56.500
 for my particular lifestyle, brain style, thinking style,

35:56.820 --> 36:00.340
 there's languages that could make me a lot more productive

36:00.340 --> 36:04.340
 in the debugging stage, in just the development stage

36:04.340 --> 36:05.940
 and thinking like the bicycle for the mind

36:05.940 --> 36:07.740
 that I can fit more stuff into my...

36:07.740 --> 36:09.220
 Python's a great example of that, right?

36:09.220 --> 36:10.940
 I mean, a machine learning framework in Python

36:10.940 --> 36:12.260
 is a great example of that.

36:12.260 --> 36:14.660
 It's just very high abstraction level.

36:14.660 --> 36:15.860
 And so you can be thinking about things

36:15.860 --> 36:19.020
 on a like very high level algorithmic level

36:19.020 --> 36:20.420
 instead of thinking about, okay, well,

36:20.420 --> 36:23.780
 am I copying this tensor to a GPU or not, right?

36:23.780 --> 36:25.500
 It's not what you want to be thinking about.

36:25.500 --> 36:26.940
 And as I was telling you, I mean,

36:26.940 --> 36:28.380
 I guess the question I had is,

36:29.740 --> 36:31.740
 how does a person like me or in general people

36:31.740 --> 36:36.740
 discover more productive languages?

36:36.860 --> 36:39.940
 Like how I was, as I've been telling you offline,

36:39.940 --> 36:43.220
 I've been looking for like a project to work on in Swift

36:43.220 --> 36:45.540
 so I can really try it out.

36:45.540 --> 36:48.580
 I mean, my intuition was like doing a hello world

36:48.580 --> 36:50.420
 is not going to get me there

36:50.420 --> 36:54.100
 to get me to experience the power of language.

36:54.100 --> 36:55.900
 You need a few weeks to change your metabolism.

36:55.900 --> 36:58.260
 Exactly, beautifully put.

36:59.500 --> 37:01.500
 That's one of the problems with people with diets,

37:01.500 --> 37:05.260
 like I'm actually currently, to go in parallel,

37:05.260 --> 37:07.780
 but in a small tangent is I've been recently

37:07.780 --> 37:10.260
 eating only meat, okay?

37:10.260 --> 37:13.140
 And okay, so most people are like,

37:14.940 --> 37:16.820
 they think that's horribly unhealthy or whatever,

37:16.820 --> 37:20.540
 you have like a million, whatever the science is,

37:20.540 --> 37:22.460
 it just doesn't sound right.

37:22.460 --> 37:24.060
 Well, so back when I was in college,

37:24.060 --> 37:26.460
 we did the Atkins diet, that was a thing.

37:26.460 --> 37:30.620
 Similar, but you have to always give these things a chance.

37:30.620 --> 37:33.220
 I mean, with dieting, I was not dieting,

37:33.220 --> 37:35.660
 but it's just the things that you like.

37:35.660 --> 37:38.060
 If I eat, personally, if I eat meat,

37:38.060 --> 37:40.140
 just everything, I can be super focused

37:40.140 --> 37:41.980
 or more focused than usual.

37:42.900 --> 37:43.940
 I just feel great.

37:43.940 --> 37:46.260
 I mean, I've been running a lot,

37:46.260 --> 37:47.940
 doing pushups and pull ups and so on.

37:47.940 --> 37:50.620
 I mean, Python is similar in that sense for me.

37:50.620 --> 37:51.980
 Where are you going with this?

37:53.540 --> 37:57.300
 I mean, literally, I just felt I had like a stupid smile

37:57.300 --> 38:00.740
 on my face when I first started using Python.

38:00.740 --> 38:02.900
 I could code up really quick things.

38:02.900 --> 38:05.700
 Like I would see the world,

38:05.700 --> 38:07.740
 I would be empowered to write a script

38:07.740 --> 38:11.780
 to do some basic data processing,

38:11.780 --> 38:14.180
 to rename files on my computer.

38:14.180 --> 38:16.260
 Like Perl didn't do that for me,

38:18.780 --> 38:19.620
 a little bit.

38:19.620 --> 38:22.540
 And again, none of these are about which is best

38:22.540 --> 38:23.380
 or something like that,

38:23.380 --> 38:25.020
 but there's definitely better and worse here.

38:25.020 --> 38:26.060
 But it clicks, right?

38:26.060 --> 38:27.580
 Well, yeah.

38:27.580 --> 38:29.300
 If you look at Perl, for example,

38:29.300 --> 38:32.660
 you get bogged down in scalars versus arrays

38:32.660 --> 38:34.340
 versus hashes versus type globs

38:34.340 --> 38:35.700
 and like all that kind of stuff.

38:35.700 --> 38:38.780
 And Python's like, yeah, let's not do this.

38:38.780 --> 38:39.940
 And some of it is debugging.

38:39.940 --> 38:41.500
 Like everyone has different priorities.

38:41.500 --> 38:44.940
 But for me, it's, can I create systems for myself

38:44.940 --> 38:47.820
 that empower me to debug quickly?

38:47.820 --> 38:50.380
 Like I've always been a big fan,

38:50.380 --> 38:52.060
 even just crude like asserts,

38:52.060 --> 38:57.060
 like always stating things that should be true,

38:57.220 --> 38:59.780
 which in Python, I found in myself doing more

38:59.780 --> 39:02.340
 because of type, all these kinds of stuff.

39:02.340 --> 39:04.540
 Well, you could think of types in a programming language

39:04.540 --> 39:05.860
 as being kind of assert.

39:05.860 --> 39:06.700
 Yeah.

39:06.700 --> 39:08.900
 They could check the compile time, right?

39:08.900 --> 39:10.980
 So how do you learn a new thing?

39:10.980 --> 39:13.900
 Well, so this, or how do people learn new things, right?

39:13.900 --> 39:15.260
 This is hard.

39:15.260 --> 39:17.140
 People don't like to change.

39:17.140 --> 39:19.300
 People generally don't like change around them either.

39:19.300 --> 39:22.860
 And so we're all very slow to adapt and change.

39:22.860 --> 39:25.460
 And usually there's a catalyst that's required

39:25.460 --> 39:27.980
 to force yourself over this.

39:27.980 --> 39:29.980
 So for learning a programming language,

39:29.980 --> 39:32.700
 it really comes down to finding an excuse,

39:32.700 --> 39:36.300
 like build a thing that the language is actually good for,

39:36.300 --> 39:37.980
 that the ecosystem's ready for.

39:38.820 --> 39:42.980
 And so if you were to write an iOS app, for example,

39:42.980 --> 39:44.220
 that'd be the easy case.

39:44.220 --> 39:46.700
 Obviously you would use Swift for that, right?

39:46.700 --> 39:47.540
 There are other...

39:47.540 --> 39:48.380
 Android.

39:48.380 --> 39:50.540
 So Swift runs on Android.

39:50.540 --> 39:51.380
 Oh, does it?

39:51.380 --> 39:52.220
 Oh yeah.

39:52.220 --> 39:53.060
 Yeah, Swift runs in lots of places.

39:53.060 --> 39:54.700
 How does that work?

39:54.700 --> 39:55.540
 So...

39:55.540 --> 39:58.580
 Okay, so Swift is built on top of LLVM.

39:58.580 --> 40:00.420
 LLVM runs everywhere.

40:00.420 --> 40:03.180
 LLVM, for example, builds the Android kernel.

40:03.180 --> 40:04.180
 Oh, okay.

40:04.180 --> 40:05.020
 So yeah.

40:05.020 --> 40:06.780
 I didn't realize this.

40:06.780 --> 40:09.900
 Yeah, so Swift is very portable, runs on Windows.

40:09.900 --> 40:12.580
 There's, it runs on lots of different things.

40:12.580 --> 40:15.540
 And Swift, sorry to interrupt, Swift UI,

40:15.540 --> 40:17.900
 and then there's a thing called UI Kit.

40:17.900 --> 40:21.060
 So can I build an app with Swift?

40:21.060 --> 40:22.180
 Well, so that's the thing,

40:22.180 --> 40:23.860
 is the ecosystem is what matters there.

40:23.860 --> 40:27.060
 So Swift UI and UI Kit are Apple technologies.

40:27.060 --> 40:27.900
 Okay, got it.

40:27.900 --> 40:28.740
 And so they happen to,

40:28.740 --> 40:30.540
 like Swift UI happens to be written in Swift,

40:30.540 --> 40:32.900
 but it's an Apple proprietary framework

40:32.900 --> 40:35.580
 that Apple loves and wants to keep on its platform,

40:35.580 --> 40:36.900
 which makes total sense.

40:36.900 --> 40:39.660
 You go to Android and you don't have that library, right?

40:39.660 --> 40:42.900
 And so Android has a different ecosystem of things

40:42.900 --> 40:44.100
 that hasn't been built out

40:44.100 --> 40:45.420
 and doesn't work as well with Swift.

40:45.420 --> 40:48.900
 And so you can totally use Swift to do like arithmetic

40:48.900 --> 40:49.740
 and things like this,

40:49.740 --> 40:51.740
 but building UI with Swift on Android

40:51.740 --> 40:54.620
 is not a great experience right now.

40:54.620 --> 40:58.780
 So if I wanted to learn Swift, what's the,

40:58.780 --> 41:01.860
 I mean, the one practical different version of that

41:01.860 --> 41:05.580
 is Swift for TensorFlow, for example.

41:05.580 --> 41:08.420
 And one of the inspiring things for me

41:08.420 --> 41:10.460
 with both TensorFlow and PyTorch

41:10.460 --> 41:13.100
 is how quickly the community can like switch

41:13.100 --> 41:16.820
 from different libraries, like you could see

41:16.820 --> 41:19.700
 some of the communities switching to PyTorch now,

41:19.700 --> 41:21.940
 but it's very easy to see.

41:21.940 --> 41:24.500
 And then TensorFlow is really stepping up its game.

41:24.500 --> 41:26.140
 And then there's no reason why,

41:26.140 --> 41:27.860
 I think the way it works is basically

41:27.860 --> 41:29.580
 it has to be one GitHub repo,

41:29.580 --> 41:31.500
 like one paper steps up.

41:31.500 --> 41:32.340
 It gets people excited.

41:32.340 --> 41:33.740
 It gets people excited and they're like,

41:33.740 --> 41:37.180
 ah, I have to learn this Swift for,

41:37.180 --> 41:39.500
 what's Swift again?

41:39.500 --> 41:41.220
 And then they learn and they fall in love with it.

41:41.220 --> 41:43.100
 I mean, that's what happened, PyTorch has it.

41:43.100 --> 41:44.420
 There has to be a reason, a catalyst.

41:44.420 --> 41:45.260
 Yeah.

41:45.260 --> 41:48.700
 And so, and there, I mean, people don't like change,

41:48.700 --> 41:50.420
 but it turns out that once you've worked

41:50.420 --> 41:52.660
 with one or two programming languages,

41:52.660 --> 41:54.100
 the basics are pretty similar.

41:54.100 --> 41:55.740
 And so one of the fun things

41:55.740 --> 41:57.340
 about learning programming languages,

41:57.340 --> 41:59.860
 even maybe Lisp, I don't know if you agree with this,

41:59.860 --> 42:01.380
 is that when you start doing that,

42:01.380 --> 42:02.940
 you start learning new things.

42:04.020 --> 42:05.660
 Cause you have a new way to do things

42:05.660 --> 42:06.820
 and you're forced to do them.

42:06.820 --> 42:09.260
 And that forces you to explore

42:09.260 --> 42:10.300
 and it puts you in learning mode.

42:10.300 --> 42:11.340
 And when you get in learning mode,

42:11.340 --> 42:12.740
 your mind kind of opens a little bit

42:12.740 --> 42:15.260
 and you can see things in a new way,

42:15.260 --> 42:17.020
 even when you go back to the old place.

42:17.020 --> 42:17.860
 Right.

42:17.860 --> 42:19.900
 Yeah, it's totally, well Lisp is functional.

42:19.900 --> 42:21.140
 Yeah.

42:21.140 --> 42:23.580
 But yeah, I wish there was a kind of window,

42:23.580 --> 42:26.060
 maybe you can tell me if there is, there you go.

42:26.060 --> 42:28.260
 This is a question to ask,

42:28.260 --> 42:29.660
 what is the most beautiful feature

42:29.660 --> 42:30.940
 in a programming language?

42:30.940 --> 42:33.260
 Before I ask it, let me say like with Python,

42:33.260 --> 42:36.660
 I remember I saw Lisp comprehensions.

42:36.660 --> 42:37.500
 Yeah.

42:37.500 --> 42:40.820
 Was like, when I like really took it in.

42:40.820 --> 42:41.940
 Yeah.

42:41.940 --> 42:43.700
 I don't know, I just loved it.

42:43.700 --> 42:47.500
 It was like fun to do, like it was fun to do that kind of,

42:49.820 --> 42:52.820
 something about it to be able to filter through a list

42:52.820 --> 42:56.260
 and to create a new list all in a single line was elegant.

42:56.260 --> 42:58.220
 I could all get into my head

42:58.220 --> 43:01.900
 and it just made me fall in love with the language.

43:01.900 --> 43:02.740
 Yeah.

43:02.740 --> 43:04.860
 So is there, let me ask you a question.

43:04.860 --> 43:07.620
 Is there, what do you use the most beautiful feature

43:07.620 --> 43:11.780
 in a programming languages that you've ever encountered

43:11.780 --> 43:15.140
 in Swift maybe and then outside of Swift?

43:15.140 --> 43:17.460
 I think the thing that I like the most

43:17.460 --> 43:18.860
 from a programming language.

43:18.860 --> 43:21.260
 So I think the thing you have to think about

43:21.260 --> 43:23.580
 with the programming language, again, what is the goal?

43:23.580 --> 43:27.140
 You're trying to get people to get things done quickly.

43:27.140 --> 43:30.500
 And so you need libraries, you need high quality libraries

43:30.500 --> 43:32.620
 and then you need a user base around them

43:32.620 --> 43:35.020
 that can assemble them and do cool things with them, right?

43:35.020 --> 43:36.180
 And so to me, the question is

43:36.180 --> 43:38.260
 what enables high quality libraries?

43:39.860 --> 43:40.700
 Okay.

43:40.700 --> 43:41.540
 Yeah.

43:41.540 --> 43:43.380
 And there's a huge divide in the world

43:43.380 --> 43:48.300
 between libraries who enable high quality libraries

43:48.300 --> 43:52.780
 versus the ones that put special stuff in the language.

43:52.780 --> 43:56.740
 So programming languages that enable high quality libraries?

43:56.740 --> 43:57.580
 Got it.

43:57.580 --> 44:00.860
 So, and what I mean by that is expressive libraries

44:00.860 --> 44:03.700
 that then feel like a natural integrated part

44:03.700 --> 44:05.580
 of the language itself.

44:05.580 --> 44:09.860
 So an example of this in Swift is that int and float

44:09.860 --> 44:12.100
 and also array and string, things like this,

44:12.100 --> 44:13.740
 these are all part of the library.

44:13.740 --> 44:16.180
 Like int is not hard coded into Swift.

44:17.420 --> 44:19.060
 And so what that means is that

44:19.060 --> 44:21.340
 because int is just a library thing

44:21.340 --> 44:22.580
 defined in the standard library,

44:22.580 --> 44:24.660
 along with strings and arrays and all the other things

44:24.660 --> 44:26.180
 that come with the standard library.

44:27.180 --> 44:29.220
 Well, hopefully you do like int,

44:29.220 --> 44:31.980
 but anything that any language features

44:31.980 --> 44:33.940
 that you needed to define int,

44:33.940 --> 44:36.100
 you can also use in your own types.

44:36.100 --> 44:39.540
 So if you wanted to find a quaternion

44:39.540 --> 44:41.420
 or something like this, right?

44:41.420 --> 44:43.580
 Well, it doesn't come in the standard library.

44:43.580 --> 44:45.660
 There's a very special set of people

44:45.660 --> 44:47.180
 that care a lot about this,

44:47.180 --> 44:49.420
 but those people are also important.

44:49.420 --> 44:51.100
 It's not about classism, right?

44:51.100 --> 44:53.500
 It's not about the people who care about ints and floats

44:53.500 --> 44:55.780
 are more important than the people who care about quaternions.

44:55.780 --> 44:56.940
 And so to me, the beautiful things

44:56.940 --> 44:58.980
 about programming languages is when you allow

44:58.980 --> 45:02.300
 those communities to build high quality libraries,

45:02.300 --> 45:03.140
 they feel native.

45:03.140 --> 45:05.820
 They feel like they're built into the compiler

45:05.820 --> 45:06.900
 without having to be.

45:08.020 --> 45:11.140
 What does it mean for the int to be part

45:11.140 --> 45:13.220
 of not hard coded in?

45:13.220 --> 45:18.220
 So is it like how, so what is an int?

45:18.580 --> 45:20.820
 Okay, int is just a integer.

45:20.820 --> 45:23.540
 In this case, it's like a 64 bit integer

45:23.540 --> 45:24.620
 or something like this.

45:24.620 --> 45:28.100
 But so like the 64 bit is hard coded or no?

45:28.100 --> 45:29.380
 No, none of that's hard coded.

45:29.380 --> 45:32.140
 So int, if you go look at how it's implemented,

45:32.140 --> 45:34.740
 it's just a struct in Swift.

45:34.740 --> 45:35.860
 And so it's a struct.

45:35.860 --> 45:37.460
 And then how do you add two structs?

45:37.460 --> 45:38.660
 Well, you define plus.

45:39.620 --> 45:41.780
 And so you can define plus on int.

45:41.780 --> 45:43.540
 Well, you can define plus on your thing too.

45:43.540 --> 45:46.660
 You can define, int is an odd method

45:46.660 --> 45:47.780
 or something like that on it.

45:47.780 --> 45:50.420
 And so yeah, you can add methods on the things.

45:50.420 --> 45:51.340
 Yeah.

45:51.340 --> 45:55.380
 So you can define operators, like how it behaves.

45:55.380 --> 45:57.500
 That's just beautiful when there's something

45:57.500 --> 46:00.420
 about the language which enables others

46:00.420 --> 46:05.340
 to create libraries which are not hacky.

46:05.340 --> 46:07.180
 Yeah, they feel native.

46:07.180 --> 46:10.860
 And so one of the best examples of this is Lisp, right?

46:10.860 --> 46:13.780
 Because in Lisp, like all the libraries

46:13.780 --> 46:15.420
 are basically part of the language, right?

46:15.420 --> 46:17.500
 You write, turn, rewrite systems and things like this.

46:17.500 --> 46:18.340
 And so.

46:18.340 --> 46:20.780
 Can you as a counter example provide

46:20.780 --> 46:23.820
 what makes it difficult to write a library that's native?

46:23.820 --> 46:25.500
 Is it the Python C?

46:25.500 --> 46:29.020
 Well, so one example, I'll give you two examples.

46:29.020 --> 46:31.580
 Java and C++, there's Java and C.

46:33.060 --> 46:35.780
 They both allow you to define your own types,

46:35.780 --> 46:38.420
 but int is hard code in the language.

46:38.420 --> 46:39.340
 Okay, well, why?

46:39.340 --> 46:41.620
 Well, in Java, for example, coming back

46:41.620 --> 46:44.180
 to this whole reference semantic value semantic thing,

46:45.180 --> 46:47.420
 int gets passed around by value.

46:48.860 --> 46:49.700
 Yeah.

46:49.700 --> 46:53.740
 But if you make like a pair or something like that,

46:53.740 --> 46:56.860
 a complex number, right, it's a class in Java.

46:56.860 --> 46:59.900
 And now it gets passed around by reference, by pointer.

46:59.900 --> 47:02.620
 And so now you lose value semantics, right?

47:02.620 --> 47:04.980
 You lost math, okay.

47:04.980 --> 47:06.860
 Well, that's not great, right?

47:06.860 --> 47:08.140
 If you can do something with int,

47:08.140 --> 47:10.460
 why can't I do it with my type, right?

47:10.460 --> 47:15.340
 So that's the negative side of the thing I find beautiful

47:15.340 --> 47:17.340
 is when you can solve that,

47:17.340 --> 47:19.260
 when you can have full expressivity,

47:19.260 --> 47:21.700
 where you as a user of the language

47:21.700 --> 47:24.180
 have as much or almost as much power

47:24.180 --> 47:25.500
 as the people who implemented

47:25.500 --> 47:27.300
 all the standard built in stuff,

47:27.300 --> 47:28.500
 because what that enables

47:28.500 --> 47:31.460
 is that enables truly beautiful libraries.

47:31.460 --> 47:32.620
 You know, it's kind of weird

47:32.620 --> 47:34.900
 because I've gotten used to that.

47:36.260 --> 47:37.860
 That's one, I guess, other aspect

47:37.860 --> 47:39.100
 of program language design.

47:39.100 --> 47:41.140
 You have to think, you know,

47:41.140 --> 47:43.500
 the old first principles thinking,

47:43.500 --> 47:45.580
 like, why are we doing it this way?

47:45.580 --> 47:47.900
 By the way, I mean, I remember,

47:47.900 --> 47:50.900
 because I was thinking about the walrus operator

47:50.900 --> 47:53.260
 and I'll ask you about it later,

47:53.260 --> 47:57.700
 but it hit me that like the equal sign for assignment.

47:57.700 --> 47:58.780
 Yeah.

47:58.780 --> 48:00.820
 Like, why are we using the equal sign for assignment?

48:00.820 --> 48:02.500
 It's wrong, yeah.

48:02.500 --> 48:04.500
 And that's not the only solution, right?

48:04.500 --> 48:05.420
 So if you look at Pascal,

48:05.420 --> 48:07.740
 they use colon equals for assignment

48:07.740 --> 48:11.420
 and equals for equality.

48:11.420 --> 48:12.980
 And they use like less than greater than

48:12.980 --> 48:14.580
 instead of the not equal thing.

48:14.580 --> 48:15.420
 Yeah.

48:15.420 --> 48:16.380
 Like, there are other answers here.

48:16.380 --> 48:19.900
 So, but like, and yeah, like I ask you all,

48:19.900 --> 48:24.860
 but how do you then decide to break convention

48:24.860 --> 48:29.700
 to say, you know what, everybody's doing it wrong.

48:29.700 --> 48:30.980
 We're gonna do it right.

48:30.980 --> 48:31.980
 Yeah.

48:31.980 --> 48:33.740
 So it's like an ROI,

48:33.740 --> 48:35.460
 like return on investment trade off, right?

48:35.460 --> 48:37.340
 So if you do something weird,

48:37.340 --> 48:39.820
 let's just say like not like colon equal

48:39.820 --> 48:40.940
 instead of equal for assignment,

48:40.940 --> 48:44.900
 that would be weird with today's aesthetic, right?

48:44.900 --> 48:47.460
 And so you'd say, cool, this is theoretically better,

48:47.460 --> 48:49.620
 but is it better in which ways?

48:49.620 --> 48:50.700
 Like, what do I get out of that?

48:50.700 --> 48:52.340
 Do I define away class of bugs?

48:52.340 --> 48:54.260
 Well, one of the class of bugs that C has

48:54.260 --> 48:55.860
 is that you can use like, you know,

48:55.860 --> 49:00.860
 if X equals without equals equals X equals Y, right?

49:01.740 --> 49:05.220
 Well, turns out you can solve that problem in lots of ways.

49:05.220 --> 49:07.620
 Clang, for example, GCC, all these compilers

49:07.620 --> 49:10.740
 will detect that as a likely bug, produce a warning.

49:10.740 --> 49:11.580
 Do they?

49:11.580 --> 49:12.420
 Yeah.

49:12.420 --> 49:13.260
 I feel like they didn't.

49:13.260 --> 49:14.100
 Oh, Clang does.

49:14.100 --> 49:14.940
 They didn't.

49:14.940 --> 49:15.900
 GCC didn't.

49:15.900 --> 49:17.820
 It's like one of the important things

49:17.820 --> 49:19.820
 about programming language design is like,

49:19.820 --> 49:22.940
 you're literally creating suffering in the world.

49:22.940 --> 49:23.780
 Okay.

49:23.780 --> 49:27.820
 Like, I feel like, I mean, one way to see it

49:27.820 --> 49:29.140
 is the bicycle for the mind,

49:29.140 --> 49:32.140
 but the other way is to like minimizing suffering.

49:32.140 --> 49:33.580
 Well, you have to decide if it's worth it, right?

49:33.580 --> 49:35.460
 And so let's come back to that.

49:35.460 --> 49:36.300
 Okay.

49:36.300 --> 49:38.300
 But if you look at this, and again,

49:38.300 --> 49:40.020
 this is where there's a lot of detail

49:40.020 --> 49:41.740
 that goes into each of these things.

49:42.700 --> 49:45.060
 Equal and C returns a value.

49:46.700 --> 49:47.540
 Yep.

49:47.540 --> 49:48.860
 Is it messed up?

49:48.860 --> 49:51.060
 That allows you to say X equals Y equals Z,

49:51.060 --> 49:52.380
 like that works in C.

49:52.380 --> 49:53.380
 Yeah.

49:53.380 --> 49:54.580
 Is it messed up?

49:54.580 --> 49:57.460
 You know, most people think it's messed up, I think.

49:57.460 --> 50:00.700
 It is very, by messed up, what I mean is

50:00.700 --> 50:03.460
 it is very rarely used for good,

50:03.460 --> 50:05.460
 and it's often used for bugs.

50:05.460 --> 50:06.300
 Yeah.

50:06.300 --> 50:07.140
 Right, and so.

50:07.140 --> 50:09.340
 That's a good definition of messed up, yeah.

50:09.340 --> 50:12.060
 You could use, you know, in hindsight,

50:12.060 --> 50:13.500
 this was not such a great idea, right?

50:13.500 --> 50:14.340
 No.

50:14.340 --> 50:16.100
 One of the things with Swift that is really powerful

50:16.100 --> 50:18.420
 and one of the reasons it's actually good

50:18.420 --> 50:20.260
 versus it being full of good ideas

50:20.260 --> 50:23.420
 is that when we launched Swift 1,

50:23.420 --> 50:26.020
 we announced that it was public,

50:26.020 --> 50:27.900
 people could use it, people could build apps,

50:27.900 --> 50:30.940
 but it was gonna change and break, okay?

50:30.940 --> 50:33.220
 When Swift 2 came out, we said, hey, it's open source,

50:33.220 --> 50:34.460
 and there's this open process

50:34.460 --> 50:37.900
 which people can help evolve and direct the language.

50:37.900 --> 50:40.140
 So the community at large, like Swift users,

50:40.140 --> 50:43.100
 can now help shape the language as it is.

50:43.100 --> 50:46.140
 And what happened as part of that process is

50:46.140 --> 50:49.540
 a lot of really bad mistakes got taken out.

50:49.540 --> 50:53.180
 So for example, Swift used to have the C style plus plus

50:53.180 --> 50:55.020
 and minus minus operators.

50:55.020 --> 50:56.580
 Like, what does it mean when you put it before

50:56.580 --> 50:59.340
 versus after, right?

50:59.340 --> 51:02.620
 Well, that got cargo culted from C into Swift early on.

51:02.620 --> 51:03.740
 What's cargo culted?

51:03.740 --> 51:05.300
 Cargo culted means brought forward

51:05.300 --> 51:07.740
 without really considering it.

51:07.740 --> 51:08.580
 Okay.

51:08.580 --> 51:12.060
 This is maybe not the most PC term, but.

51:12.060 --> 51:13.580
 You have to look it up in Urban Dictionary, yeah.

51:13.580 --> 51:17.500
 Yeah, so it got pulled into C without,

51:17.500 --> 51:18.580
 or it got pulled into Swift

51:18.580 --> 51:20.500
 without very good consideration.

51:20.500 --> 51:22.180
 And we went through this process,

51:22.180 --> 51:23.700
 and one of the first things got ripped out

51:23.700 --> 51:25.580
 was plus plus and minus minus,

51:25.580 --> 51:27.740
 because they lead to confusion.

51:27.740 --> 51:31.580
 They have very low value over saying x plus equals one,

51:31.580 --> 51:34.180
 and x plus equals one is way more clear.

51:34.180 --> 51:36.980
 And so when you're optimizing for teachability and clarity

51:36.980 --> 51:39.540
 and bugs and this multidimensional space

51:39.540 --> 51:40.980
 that you're looking at,

51:40.980 --> 51:42.300
 things like that really matter.

51:42.300 --> 51:45.500
 And so being first principles on where you're coming from

51:45.500 --> 51:46.460
 and what you're trying to achieve

51:46.460 --> 51:50.100
 and being anchored on the objective is really important.

51:50.100 --> 51:53.260
 Well, let me ask you about the most,

51:54.460 --> 51:58.140
 sort of this podcast isn't about information,

51:58.140 --> 51:59.300
 it's about drama.

51:59.300 --> 52:00.140
 Okay.

52:00.140 --> 52:01.300
 Let me talk to you about some drama.

52:01.300 --> 52:06.300
 So you mentioned Pascal and colon equals,

52:06.300 --> 52:08.980
 there's something that's called the Walrus operator.

52:08.980 --> 52:09.820
 Okay.

52:09.820 --> 52:14.820
 And Python in Python 3.8 added the Walrus operator.

52:15.580 --> 52:17.580
 And the reason I think it's interesting

52:19.100 --> 52:21.340
 is not just because of the feature,

52:21.340 --> 52:23.420
 it has the same kind of expression feature

52:23.420 --> 52:25.180
 you can mention to see that it returns

52:25.180 --> 52:27.060
 the value of the assignment.

52:27.060 --> 52:29.620
 And then maybe you can comment on that in general,

52:29.620 --> 52:31.180
 but on the other side of it,

52:31.180 --> 52:36.180
 it's also the thing that toppled the dictator.

52:36.540 --> 52:39.220
 So it finally drove Guido

52:39.220 --> 52:42.820
 to step down from BDFL, the toxicity of the community.

52:42.820 --> 52:46.300
 So maybe what do you think about the Walrus operator

52:46.300 --> 52:47.140
 in Python?

52:47.140 --> 52:50.020
 Is there an equivalent thing in Swift

52:50.020 --> 52:54.180
 that really stress tested the community?

52:54.180 --> 52:56.620
 And then on the flip side,

52:56.620 --> 52:58.700
 what do you think about Guido stepping down over it?

52:58.700 --> 53:01.180
 Yeah, well, if I look past the details

53:01.180 --> 53:02.380
 of the Walrus operator,

53:02.380 --> 53:04.180
 one of the things that makes it most polarizing

53:04.180 --> 53:05.720
 is that it's syntactic sugar.

53:06.900 --> 53:07.740
 Okay.

53:07.740 --> 53:09.140
 What do you mean by syntactic sugar?

53:09.140 --> 53:10.540
 It means you can take something

53:10.540 --> 53:11.780
 that already exists in the language

53:11.780 --> 53:14.420
 and you can express it in a more concise way.

53:14.420 --> 53:15.980
 So, okay, I'm going to play dollars advocate.

53:15.980 --> 53:17.780
 So this is great.

53:18.780 --> 53:21.580
 Is that a objective or subjective statement?

53:21.580 --> 53:24.420
 Like, can you argue that basically anything

53:24.420 --> 53:26.340
 isn't syntactic sugar or not?

53:27.460 --> 53:30.340
 No, not everything is syntactic sugar.

53:30.340 --> 53:32.740
 So for example, the type system,

53:32.740 --> 53:35.680
 like can you have classes versus,

53:35.680 --> 53:37.960
 like, do you have types or not, right?

53:37.960 --> 53:40.040
 So one type versus many types

53:40.040 --> 53:42.600
 is not something that affects syntactic sugar.

53:42.600 --> 53:43.760
 And so if you say,

53:43.760 --> 53:46.040
 I want to have the ability to define types,

53:46.040 --> 53:47.840
 I have to have all this like language mechanics

53:47.840 --> 53:49.080
 to define classes.

53:49.080 --> 53:51.200
 And oh, now I have to have inheritance.

53:51.200 --> 53:52.880
 And I have like, I have all this stuff

53:52.880 --> 53:54.920
 that's just making the language more complicated.

53:54.920 --> 53:57.000
 That's not about sugaring it.

53:58.440 --> 54:00.080
 Swift has the sugar.

54:00.080 --> 54:02.040
 So like Swift has this thing called if let,

54:02.040 --> 54:04.640
 and it has a lot of different types

54:04.640 --> 54:06.520
 and it has various operators

54:06.520 --> 54:10.480
 that are used to concisify specific use cases.

54:10.480 --> 54:12.840
 So the problem with syntactic sugar,

54:12.840 --> 54:14.000
 when you're talking about,

54:14.000 --> 54:16.240
 hey, I have a thing that takes a lot to write

54:16.240 --> 54:17.660
 and I have a new way to write it.

54:17.660 --> 54:19.880
 You have this like horrible trade off,

54:19.880 --> 54:22.340
 which becomes almost completely subjective,

54:22.340 --> 54:26.280
 which is how often does this happen and does it matter?

54:26.280 --> 54:28.480
 And one of the things that is true about human psychology,

54:28.480 --> 54:29.780
 particularly when you're talking about introducing

54:29.780 --> 54:34.240
 a new thing is that people overestimate

54:34.240 --> 54:36.120
 the burden of learning something.

54:36.120 --> 54:38.840
 And so it looks foreign when you haven't gotten used to it.

54:38.840 --> 54:40.360
 But if it was there from the beginning,

54:40.360 --> 54:42.000
 of course it's just part of Python.

54:42.000 --> 54:45.080
 Like unquestionably, like this is just the thing I know.

54:45.080 --> 54:47.640
 And it's not a new thing that you're worried about learning.

54:47.640 --> 54:49.400
 It's just part of the deal.

54:49.400 --> 54:54.240
 Now with Guido, I don't know Guido well.

54:55.480 --> 54:56.920
 Yeah, have you passed cross much?

54:56.920 --> 54:58.180
 Yeah, I've met him a couple of times,

54:58.180 --> 55:00.000
 but I don't know Guido well.

55:00.000 --> 55:03.280
 But the sense that I got out of that whole dynamic

55:03.280 --> 55:04.720
 was that he had put the,

55:04.720 --> 55:08.840
 not just the decision maker weight on his shoulders,

55:08.840 --> 55:11.960
 but it was so tied to his personal identity

55:11.960 --> 55:15.060
 that he took it personally and he felt the need

55:15.060 --> 55:16.560
 and he kind of put himself in the situation

55:16.560 --> 55:18.200
 of being the person,

55:18.200 --> 55:20.960
 instead of building a base of support around him.

55:20.960 --> 55:23.960
 I mean, this is probably not quite literally true,

55:23.960 --> 55:28.960
 but by too much concentrated on him, right?

55:29.560 --> 55:31.360
 And that can wear you down.

55:31.360 --> 55:33.800
 Well, yeah, particularly because people then say,

55:33.800 --> 55:35.400
 Guido, you're a horrible person.

55:35.400 --> 55:37.600
 I hate this thing, blah, blah, blah, blah, blah, blah, blah.

55:37.600 --> 55:40.040
 And sure, it's like maybe 1% of the community

55:40.040 --> 55:43.560
 that's doing that, but Python's got a big community.

55:43.560 --> 55:46.640
 And 1% of millions of people is a lot of hate mail.

55:46.640 --> 55:49.480
 And that just from human factor will just wear on you.

55:49.480 --> 55:52.600
 Well, to clarify, it looked from just what I saw

55:52.600 --> 55:53.920
 in the messaging for the,

55:53.920 --> 55:55.800
 let's not look at the million Python users,

55:55.800 --> 55:58.380
 but at the Python core developers,

55:58.380 --> 56:01.880
 it feels like the majority, the big majority

56:01.880 --> 56:03.680
 on a vote were opposed to it.

56:03.680 --> 56:06.840
 Okay, I'm not that close to it, so I don't know.

56:06.840 --> 56:09.220
 Okay, so the situation is like literally,

56:10.920 --> 56:13.120
 yeah, I mean, the majority of the core developers

56:13.120 --> 56:13.960
 are against it.

56:13.960 --> 56:14.780
 Were opposed to it.

56:14.780 --> 56:19.780
 So, and they weren't even like against it.

56:20.920 --> 56:23.080
 It was, there was a few, well, they were against it,

56:23.080 --> 56:27.800
 but the against it wasn't like, this is a bad idea.

56:27.800 --> 56:31.240
 They were more like, we don't see why this is a good idea.

56:31.240 --> 56:35.160
 And what that results in is there's a stalling feeling,

56:35.160 --> 56:37.980
 like you just slow things down.

56:37.980 --> 56:41.600
 Now, from my perspective, that you could argue this,

56:41.600 --> 56:44.600
 and I think it's very interesting

56:44.600 --> 56:47.600
 if we look at politics today and the way Congress works,

56:47.600 --> 56:49.560
 it's slowed down everything.

56:49.560 --> 56:50.400
 It's a dampener.

56:50.400 --> 56:51.880
 Yeah, it's a dampener, but like,

56:51.880 --> 56:53.660
 that's a dangerous thing too,

56:53.660 --> 56:57.480
 because if it dampens things like, you know,

56:57.480 --> 56:58.680
 if the dampening results.

56:58.680 --> 56:59.520
 What are you talking about?

56:59.520 --> 57:00.520
 Like, it's a low pass filter,

57:00.520 --> 57:02.320
 but if you need billions of dollars

57:02.320 --> 57:05.080
 injected into the economy or trillions of dollars,

57:05.080 --> 57:06.840
 then suddenly stuff happens, right?

57:06.840 --> 57:07.680
 And so.

57:07.680 --> 57:09.360
 For sure.

57:09.360 --> 57:10.460
 So you're talking about.

57:10.460 --> 57:11.980
 I'm not defending our political situation,

57:11.980 --> 57:13.320
 just to be clear.

57:13.320 --> 57:16.480
 But you're talking about like a global pandemic.

57:16.480 --> 57:17.320
 Well.

57:17.320 --> 57:20.560
 I was hoping we could fix like the healthcare system

57:20.560 --> 57:22.960
 and the education system, like, you know.

57:22.960 --> 57:24.720
 I'm not a politics person.

57:24.720 --> 57:26.240
 I don't know.

57:26.240 --> 57:28.120
 When it comes to languages,

57:28.120 --> 57:30.760
 the community's kind of right in terms of,

57:30.760 --> 57:33.200
 it's a very high burden to add something to a language.

57:33.200 --> 57:34.400
 So as soon as you add something,

57:34.400 --> 57:35.720
 you have a community of people building on it

57:35.720 --> 57:38.080
 and you can't remove it, okay?

57:38.080 --> 57:39.620
 And if there's a community of people

57:39.620 --> 57:41.620
 that feel really uncomfortable with it,

57:41.620 --> 57:45.600
 then taking it slow, I think, is an important thing to do.

57:45.600 --> 57:48.080
 And there's no rush, particularly if it was something

57:48.080 --> 57:50.360
 that's 25 years old and is very established.

57:50.360 --> 57:53.540
 And, you know, it's not like coming into its own.

57:54.360 --> 57:55.840
 What about features?

57:55.840 --> 57:58.800
 Well, so I think that the issue with Guido

57:58.800 --> 58:00.360
 is that maybe this is a case

58:00.360 --> 58:02.720
 where he realized it had outgrown him

58:03.600 --> 58:06.240
 and it went from being the language.

58:06.240 --> 58:09.660
 So Python, I mean, Guido's amazing,

58:09.660 --> 58:12.260
 but Python isn't about Guido anymore.

58:12.260 --> 58:13.520
 It's about the users.

58:13.520 --> 58:15.320
 And to a certain extent, the users own it.

58:15.320 --> 58:19.720
 And, you know, Guido spent years of his life,

58:19.720 --> 58:22.880
 a significant fraction of his career on Python.

58:22.880 --> 58:24.720
 And from his perspective, I imagine he's like,

58:24.720 --> 58:25.800
 well, this is my thing.

58:25.800 --> 58:28.240
 I should be able to do the thing I think is right.

58:28.240 --> 58:30.360
 But you can also understand the users

58:30.360 --> 58:33.140
 where they feel like, you know, this is my thing.

58:33.140 --> 58:38.140
 I use this, like, and I don't know, it's a hard thing.

58:38.320 --> 58:41.400
 But what, if we could talk about leadership in this,

58:41.400 --> 58:42.540
 because it's so interesting to me.

58:42.540 --> 58:44.440
 I'm gonna make, I'm gonna work.

58:44.440 --> 58:45.520
 Hopefully somebody makes it.

58:45.520 --> 58:47.720
 If not, I'll make it a Walrus Operator shirt,

58:47.720 --> 58:50.380
 because I think it represents, to me,

58:50.380 --> 58:52.480
 maybe it's my Russian roots or something.

58:52.480 --> 58:56.100
 But, you know, it's the burden of leadership.

58:56.100 --> 58:59.220
 Like, I feel like to push back,

59:01.000 --> 59:02.980
 I feel like progress can only,

59:02.980 --> 59:06.220
 like most difficult decisions, just like you said,

59:06.220 --> 59:09.100
 there'll be a lot of divisiveness over,

59:09.100 --> 59:11.240
 especially in a passionate community.

59:12.180 --> 59:14.540
 It just feels like leaders need to take

59:14.540 --> 59:19.540
 those risky decisions that if you like listen,

59:19.540 --> 59:23.020
 that with some nonzero probability,

59:23.020 --> 59:26.100
 maybe even a high probability would be the wrong decision.

59:26.100 --> 59:29.260
 But they have to use their gut and make that decision.

59:29.260 --> 59:30.940
 Well, this is like one of the things

59:30.940 --> 59:34.180
 where you see amazing founders.

59:34.180 --> 59:36.220
 The founders understand exactly what's happened

59:36.220 --> 59:39.100
 and how the company got there and are willing to say,

59:39.100 --> 59:42.780
 we have been doing thing X the last 20 years,

59:42.780 --> 59:45.460
 but today we're gonna do thing Y.

59:45.460 --> 59:47.380
 And they make a major pivot for the whole company.

59:47.380 --> 59:48.580
 The company lines up behind them,

59:48.580 --> 59:50.540
 they move and it's the right thing.

59:50.540 --> 59:52.380
 But then when the founder dies,

59:52.380 --> 59:57.060
 the successor doesn't always feel that agency

59:57.060 --> 59:59.140
 to be able to make those kinds of decisions.

59:59.140 --> 1:00:00.040
 Even though they're a CEO,

1:00:00.040 --> 1:00:02.140
 they could theoretically do whatever.

1:00:02.140 --> 1:00:04.460
 There's two reasons for that, in my opinion,

1:00:04.460 --> 1:00:07.340
 or in many cases, it's always different.

1:00:07.340 --> 1:00:09.760
 But one of which is they weren't there

1:00:09.760 --> 1:00:11.620
 for all the decisions that were made.

1:00:11.620 --> 1:00:13.360
 And so they don't know the principles

1:00:13.360 --> 1:00:15.340
 in which those decisions were made.

1:00:15.340 --> 1:00:17.620
 And once the principles change,

1:00:17.620 --> 1:00:20.740
 you should be obligated to change what you're doing

1:00:20.740 --> 1:00:22.700
 and change direction, right?

1:00:22.700 --> 1:00:25.860
 And so if you don't know how you got to where you are,

1:00:25.860 --> 1:00:27.400
 it just seems like gospel

1:00:27.400 --> 1:00:29.820
 and you're not gonna question it.

1:00:29.820 --> 1:00:30.740
 You may not understand

1:00:30.740 --> 1:00:32.420
 that it really is the right thing to do,

1:00:32.420 --> 1:00:33.460
 so you just may not see it.

1:00:33.460 --> 1:00:34.300
 That's so brilliant.

1:00:34.300 --> 1:00:35.940
 I never thought of it that way.

1:00:35.940 --> 1:00:38.660
 Like it's so much higher burden

1:00:38.660 --> 1:00:40.400
 when as a leader you step into a thing

1:00:40.400 --> 1:00:41.740
 that's already worked for a long time.

1:00:41.740 --> 1:00:42.560
 Yeah, yeah.

1:00:42.560 --> 1:00:44.100
 Well, and if you change it and it doesn't work out,

1:00:44.100 --> 1:00:46.340
 now you're the person who screwed it up.

1:00:46.340 --> 1:00:47.660
 People always second guess it.

1:00:47.660 --> 1:00:48.500
 Yeah.

1:00:48.500 --> 1:00:49.340
 And the second thing is that

1:00:49.340 --> 1:00:51.140
 even if you decide to make a change,

1:00:51.140 --> 1:00:53.540
 even if you're theoretically in charge,

1:00:53.540 --> 1:00:57.480
 you're just a person that thinks they're in charge.

1:00:57.480 --> 1:00:58.860
 Meanwhile, you have to motivate the troops.

1:00:58.860 --> 1:00:59.700
 You have to explain it to them

1:00:59.700 --> 1:01:00.540
 in terms they'll understand.

1:01:00.540 --> 1:01:02.180
 You have to get them to buy into it and believe in it,

1:01:02.180 --> 1:01:03.620
 because if they don't,

1:01:03.620 --> 1:01:05.940
 then they're not gonna be able to make the turn

1:01:05.940 --> 1:01:08.460
 even if you tell them their bonuses are gonna be curtailed.

1:01:08.460 --> 1:01:10.700
 They're just not gonna like buy into it, you know?

1:01:10.700 --> 1:01:12.980
 And so there's only so much power you have as a leader,

1:01:12.980 --> 1:01:16.400
 and you have to understand what those limitations are.

1:01:16.400 --> 1:01:18.220
 Are you still BDFL?

1:01:18.220 --> 1:01:20.300
 You've been a BDFL of some stuff.

1:01:21.540 --> 1:01:23.540
 You're very heavy on the B,

1:01:24.660 --> 1:01:27.900
 the benevolent, benevolent dictator for life.

1:01:27.900 --> 1:01:29.180
 I guess LLVM?

1:01:29.180 --> 1:01:32.560
 Yeah, so I still lead the LLVM world.

1:01:32.560 --> 1:01:34.380
 I mean, what's the role of,

1:01:35.460 --> 1:01:38.460
 so then on Swift you said that there's a group of people.

1:01:38.460 --> 1:01:41.660
 Yeah, so if you contrast Python with Swift, right,

1:01:41.660 --> 1:01:43.420
 one of the reasons,

1:01:43.420 --> 1:01:45.620
 so everybody on the core team takes the role

1:01:45.620 --> 1:01:47.580
 really seriously, and I think we all really care

1:01:47.580 --> 1:01:49.220
 about where Swift goes,

1:01:49.220 --> 1:01:52.940
 but you're almost delegating the final decision making

1:01:52.940 --> 1:01:54.940
 to the wisdom of the group,

1:01:54.940 --> 1:01:56.660
 and so it doesn't become personal.

1:01:57.580 --> 1:01:59.620
 And also, when you're talking with the community,

1:01:59.620 --> 1:02:02.060
 so yeah, some people are very annoyed

1:02:02.060 --> 1:02:04.300
 as certain decisions get made.

1:02:04.300 --> 1:02:06.260
 There's a certain faith in the process,

1:02:06.260 --> 1:02:08.100
 because it's a very transparent process,

1:02:08.100 --> 1:02:09.940
 and when a decision gets made,

1:02:09.940 --> 1:02:12.180
 a full rationale is provided, things like this.

1:02:12.180 --> 1:02:14.420
 These are almost defense mechanisms

1:02:14.420 --> 1:02:16.500
 to help both guide future discussions

1:02:16.500 --> 1:02:18.820
 and provide case law, kind of like Supreme Court does

1:02:18.820 --> 1:02:20.980
 about this decision was made for this reason,

1:02:20.980 --> 1:02:21.900
 and here's the rationale

1:02:21.900 --> 1:02:24.120
 and what we want to see more of or less of.

1:02:25.540 --> 1:02:27.600
 But it's also a way to provide a defense mechanism,

1:02:27.600 --> 1:02:28.980
 so that when somebody's griping about it,

1:02:28.980 --> 1:02:31.980
 they're not saying that person did the wrong thing.

1:02:31.980 --> 1:02:33.980
 They're saying, well, this thing sucks,

1:02:33.980 --> 1:02:38.540
 and later they move on and they get over it.

1:02:38.540 --> 1:02:40.140
 Yeah, the analogy of the Supreme Court,

1:02:40.140 --> 1:02:42.660
 I think, is really good.

1:02:42.660 --> 1:02:45.700
 But then, okay, not to get personal on the SWIFT team,

1:02:45.700 --> 1:02:50.020
 but it just seems like it's impossible

1:02:50.020 --> 1:02:52.820
 for division not to emerge.

1:02:52.820 --> 1:02:55.340
 Well, each of the humans on the SWIFT Core Team,

1:02:55.340 --> 1:02:56.980
 for example, are different,

1:02:56.980 --> 1:02:58.380
 and the membership of the SWIFT Core Team

1:02:58.380 --> 1:03:02.340
 changes slowly over time, which is, I think, a healthy thing.

1:03:02.340 --> 1:03:04.020
 And so each of these different humans

1:03:04.020 --> 1:03:05.220
 have different opinions.

1:03:05.220 --> 1:03:09.380
 Trust me, it's not a singular consciousness

1:03:09.380 --> 1:03:11.000
 by any stretch of the imagination.

1:03:11.000 --> 1:03:12.840
 You've got three major organizations,

1:03:12.840 --> 1:03:14.580
 including Apple, Google, and SciFive,

1:03:14.580 --> 1:03:16.380
 all kind of working together.

1:03:16.380 --> 1:03:20.180
 And it's a small group of people, but you need high trust.

1:03:20.180 --> 1:03:21.940
 You need, again, it comes back to the principles

1:03:21.940 --> 1:03:23.360
 of what you're trying to achieve

1:03:23.360 --> 1:03:27.480
 and understanding what you're optimizing for.

1:03:27.480 --> 1:03:30.500
 And I think that starting with strong principles

1:03:30.500 --> 1:03:32.300
 and working towards decisions

1:03:32.300 --> 1:03:36.300
 is always a good way to both make wise decisions in general

1:03:36.300 --> 1:03:37.940
 but then be able to communicate them to people

1:03:37.940 --> 1:03:39.300
 so that they can buy into them.

1:03:39.300 --> 1:03:41.420
 And that is hard.

1:03:41.420 --> 1:03:42.700
 And so you mentioned LLVM.

1:03:42.700 --> 1:03:46.780
 LLVM is gonna be 20 years old this December,

1:03:46.780 --> 1:03:49.500
 so it's showing its own age.

1:03:49.500 --> 1:03:53.580
 Do you have like a dragon cake plan?

1:03:53.580 --> 1:03:54.740
 No, I should definitely do that.

1:03:54.740 --> 1:03:57.820
 Yeah, if we can have a pandemic cake.

1:03:57.820 --> 1:03:58.980
 Pandemic cake.

1:03:58.980 --> 1:04:00.380
 Everybody gets a slice of cake

1:04:00.380 --> 1:04:02.220
 and it gets sent through email.

1:04:04.300 --> 1:04:08.140
 But LLVM has had tons of its own challenges

1:04:08.140 --> 1:04:09.160
 over time too, right?

1:04:09.160 --> 1:04:12.620
 And one of the challenges that the LLVM community has,

1:04:12.620 --> 1:04:15.220
 in my opinion, is that it has a whole bunch of people

1:04:15.220 --> 1:04:19.060
 that have been working on LLVM for 10 years, right?

1:04:19.060 --> 1:04:20.900
 Because this happens somehow.

1:04:20.900 --> 1:04:22.780
 And LLVM has always been one way,

1:04:22.780 --> 1:04:25.060
 but it needs to be a different way, right?

1:04:25.060 --> 1:04:26.620
 And they've worked on it for like 10 years.

1:04:26.620 --> 1:04:28.540
 It's a long time to work on something.

1:04:28.540 --> 1:04:32.140
 And you suddenly can't see the faults

1:04:32.140 --> 1:04:33.460
 in the thing that you're working on.

1:04:33.460 --> 1:04:35.780
 And LLVM has lots of problems and we need to address them

1:04:35.780 --> 1:04:36.700
 and we need to make it better.

1:04:36.700 --> 1:04:37.700
 And if we don't make it better,

1:04:37.700 --> 1:04:40.220
 then somebody else will come up with a better idea, right?

1:04:40.220 --> 1:04:42.500
 And so it's just kind of of that age

1:04:42.500 --> 1:04:45.060
 where the community is like in danger

1:04:45.060 --> 1:04:46.580
 of getting too calcified.

1:04:46.580 --> 1:04:50.420
 And so I'm happy to see new projects joining

1:04:50.420 --> 1:04:51.980
 and new things mixing it up.

1:04:51.980 --> 1:04:54.520
 Fortran is now a new thing in the LLVM community,

1:04:54.520 --> 1:04:56.300
 which is hilarious and good.

1:04:56.300 --> 1:04:58.980
 I've been trying to find, on a little tangent,

1:04:58.980 --> 1:05:02.340
 find people who program in Cobalt or Fortran,

1:05:02.340 --> 1:05:06.460
 Fortran especially, to talk to, they're hard to find.

1:05:06.460 --> 1:05:09.820
 Yeah, look to the scientific community.

1:05:09.820 --> 1:05:11.660
 They still use Fortran quite a bit.

1:05:11.660 --> 1:05:14.260
 Well, interesting thing you kind of mentioned with LLVM,

1:05:14.260 --> 1:05:16.980
 or just in general, that as something evolves,

1:05:16.980 --> 1:05:19.700
 you're not able to see the faults.

1:05:19.700 --> 1:05:23.100
 So do you fall in love with the thing over time?

1:05:23.100 --> 1:05:24.580
 Or do you start hating everything

1:05:24.580 --> 1:05:26.300
 about the thing over time?

1:05:26.300 --> 1:05:31.020
 Well, so my personal folly is that I see,

1:05:31.020 --> 1:05:33.460
 maybe not all, but many of the faults,

1:05:33.460 --> 1:05:35.580
 and they grate on me, and I don't have time to go fix them.

1:05:35.580 --> 1:05:37.540
 Yeah, and they get magnified over time.

1:05:37.540 --> 1:05:38.900
 Well, and they may not get magnified,

1:05:38.900 --> 1:05:39.740
 but they never get fixed.

1:05:39.740 --> 1:05:41.300
 And it's like sand underneath,

1:05:41.300 --> 1:05:43.540
 you know, it's just like grating against you.

1:05:43.540 --> 1:05:45.820
 And it's like sand underneath your fingernails or something.

1:05:45.820 --> 1:05:46.880
 It's just like, you know it's there,

1:05:46.880 --> 1:05:48.180
 you can't get rid of it.

1:05:49.660 --> 1:05:52.980
 And so the problem is that if other people don't see it,

1:05:52.980 --> 1:05:56.860
 like I don't have time to go write the code

1:05:56.860 --> 1:05:58.420
 and fix it anymore,

1:05:58.420 --> 1:06:01.420
 but then people are resistant to change.

1:06:01.420 --> 1:06:03.020
 And so you say, hey, we should go fix this thing.

1:06:03.020 --> 1:06:05.260
 They're like, oh yeah, that sounds risky.

1:06:05.260 --> 1:06:07.180
 It's like, well, is it the right thing or not?

1:06:07.180 --> 1:06:10.180
 Are the challenges the group dynamics,

1:06:10.180 --> 1:06:11.620
 or is it also just technical?

1:06:11.620 --> 1:06:14.260
 I mean, some of these features like,

1:06:14.260 --> 1:06:17.180
 I think as an observer, it's almost like a fan

1:06:17.180 --> 1:06:21.220
 in the, you know, as a spectator of the whole thing,

1:06:21.220 --> 1:06:23.820
 I don't often think about, you know,

1:06:23.820 --> 1:06:24.980
 some things might actually be

1:06:24.980 --> 1:06:27.540
 technically difficult to implement.

1:06:27.540 --> 1:06:30.040
 An example of this is we built this new compiler framework

1:06:30.040 --> 1:06:31.300
 called MLIR.

1:06:31.300 --> 1:06:32.140
 Yes.

1:06:32.140 --> 1:06:34.180
 MLIR is a whole new framework.

1:06:34.180 --> 1:06:37.300
 It's not, many people think it's about machine learning.

1:06:37.300 --> 1:06:39.140
 The ML stands for multi level

1:06:39.140 --> 1:06:41.380
 because compiler people can't name things very well,

1:06:41.380 --> 1:06:42.220
 I guess.

1:06:42.220 --> 1:06:45.240
 Do we dig into what MLIR is?

1:06:45.240 --> 1:06:47.700
 Yeah, so when you look at compilers,

1:06:47.700 --> 1:06:51.700
 compilers have historically been solutions for a given space.

1:06:51.700 --> 1:06:56.540
 So LLVM is a, it's really good for dealing with CPUs,

1:06:56.540 --> 1:06:58.100
 let's just say, at a high level.

1:06:58.100 --> 1:07:01.620
 You look at Java, Java has a JVM.

1:07:01.620 --> 1:07:04.300
 The JVM is very good for garbage collected languages

1:07:04.300 --> 1:07:05.540
 that need dynamic compilation,

1:07:05.540 --> 1:07:08.380
 and it's very optimized for a specific space.

1:07:08.380 --> 1:07:09.980
 And so hotspot is one of the compilers

1:07:09.980 --> 1:07:11.000
 that gets used in that space,

1:07:11.000 --> 1:07:14.060
 and that compiler is really good at that kind of stuff.

1:07:14.060 --> 1:07:16.740
 Usually when you build these domain specific compilers,

1:07:16.740 --> 1:07:19.620
 you end up building the whole thing from scratch

1:07:19.620 --> 1:07:20.540
 for each domain.

1:07:22.220 --> 1:07:23.380
 What's a domain?

1:07:23.380 --> 1:07:26.660
 So what's the scope of a domain?

1:07:26.660 --> 1:07:29.160
 Well, so here I would say, like, if you look at Swift,

1:07:29.160 --> 1:07:31.940
 there's several different parts to the Swift compiler,

1:07:31.940 --> 1:07:36.100
 one of which is covered by the LLVM part of it.

1:07:36.100 --> 1:07:39.420
 There's also a high level piece that's specific to Swift,

1:07:39.420 --> 1:07:41.540
 and there's a huge amount of redundancy

1:07:41.540 --> 1:07:44.060
 between those two different infrastructures

1:07:44.060 --> 1:07:46.380
 and a lot of re implemented stuff

1:07:46.380 --> 1:07:48.300
 that is similar but different.

1:07:48.300 --> 1:07:49.980
 What does LLVM define?

1:07:49.980 --> 1:07:53.020
 LLVM is effectively an infrastructure.

1:07:53.020 --> 1:07:55.140
 So you can mix and match it in different ways.

1:07:55.140 --> 1:07:56.060
 It's built out of libraries.

1:07:56.060 --> 1:07:57.620
 You can use it for different things,

1:07:57.620 --> 1:07:59.820
 but it's really good at CPUs and GPUs.

1:07:59.820 --> 1:08:02.500
 CPUs and like the tip of the iceberg on GPUs.

1:08:02.500 --> 1:08:04.340
 It's not really great at GPUs.

1:08:04.340 --> 1:08:05.660
 Okay.

1:08:05.660 --> 1:08:07.860
 But it turns out. A bunch of languages that.

1:08:07.860 --> 1:08:10.100
 That then use it to talk to CPUs.

1:08:10.100 --> 1:08:11.060
 Got it.

1:08:11.060 --> 1:08:13.100
 And so it turns out there's a lot of hardware out there

1:08:13.100 --> 1:08:14.820
 that is custom accelerators.

1:08:14.820 --> 1:08:16.140
 So machine learning, for example.

1:08:16.140 --> 1:08:18.780
 There are a lot of matrix multiply accelerators

1:08:18.780 --> 1:08:20.580
 and things like this.

1:08:20.580 --> 1:08:22.820
 There's a whole world of hardware synthesis.

1:08:22.820 --> 1:08:26.620
 So we're using MLIR to build circuits.

1:08:26.620 --> 1:08:27.460
 Okay.

1:08:27.460 --> 1:08:30.860
 And so you're compiling for a domain of transistors.

1:08:30.860 --> 1:08:32.460
 And so what MLIR does is it provides

1:08:32.460 --> 1:08:34.500
 a tremendous amount of compiler infrastructure

1:08:34.500 --> 1:08:37.500
 that allows you to build these domain specific compilers

1:08:37.500 --> 1:08:41.900
 in a much faster way and have the result be good.

1:08:41.900 --> 1:08:44.380
 If we're thinking about the future,

1:08:44.380 --> 1:08:45.980
 now we're talking about like ASICs.

1:08:45.980 --> 1:08:46.900
 So anything.

1:08:46.900 --> 1:08:47.740
 Yeah, yeah.

1:08:47.740 --> 1:08:50.540
 So if we project into the future,

1:08:50.540 --> 1:08:54.500
 it's very possible that the number of these kinds of ASICs,

1:08:54.500 --> 1:08:59.500
 very specific infrastructure architecture things

1:09:02.740 --> 1:09:05.340
 like multiplies exponentially.

1:09:05.340 --> 1:09:06.340
 I hope so.

1:09:06.340 --> 1:09:08.620
 So that's MLIR.

1:09:08.620 --> 1:09:10.780
 So what MLIR does is it allows you

1:09:10.780 --> 1:09:13.260
 to build these compilers very efficiently.

1:09:13.260 --> 1:09:15.820
 Right now, one of the things that coming back

1:09:15.820 --> 1:09:17.980
 to the LLVM thing, and then we'll go to hardware,

1:09:17.980 --> 1:09:22.980
 is LLVM is a specific compiler for a specific domain.

1:09:23.980 --> 1:09:26.860
 MLIR is now this very general, very flexible thing

1:09:26.860 --> 1:09:29.260
 that can solve lots of different kinds of problems.

1:09:29.260 --> 1:09:32.380
 So LLVM is a subset of what MLIR does.

1:09:32.380 --> 1:09:35.340
 So MLIR is, I mean, it's an ambitious project then.

1:09:35.340 --> 1:09:36.980
 Yeah, it's a very ambitious project, yeah.

1:09:36.980 --> 1:09:39.820
 And so to make it even more confusing,

1:09:39.820 --> 1:09:42.420
 MLIR has joined the LLVM Umbrella Project.

1:09:42.420 --> 1:09:44.340
 So it's part of the LLVM family.

1:09:44.340 --> 1:09:45.180
 Right.

1:09:45.180 --> 1:09:47.620
 But where this comes full circle is now folks

1:09:47.620 --> 1:09:49.380
 that work on the LLVM part,

1:09:49.380 --> 1:09:51.980
 the classic part that's 20 years old,

1:09:51.980 --> 1:09:54.100
 aren't aware of all the cool new things

1:09:54.100 --> 1:09:56.140
 that have been done in the new thing,

1:09:56.140 --> 1:09:59.620
 that MLIR was built by me and many other people

1:09:59.620 --> 1:10:01.860
 that knew a lot about LLVM,

1:10:01.860 --> 1:10:05.140
 and so we fixed a lot of the mistakes that lived in LLVM.

1:10:05.140 --> 1:10:07.140
 And so now you have this community dynamic

1:10:07.140 --> 1:10:08.540
 where it's like, well, there's this new thing,

1:10:08.540 --> 1:10:10.340
 but it's not familiar, nobody knows it,

1:10:10.340 --> 1:10:12.820
 it feels like it's new, and so let's not trust it.

1:10:12.820 --> 1:10:13.980
 And so it's just really interesting

1:10:13.980 --> 1:10:16.900
 to see the cultural social dynamic that comes out of that.

1:10:16.900 --> 1:10:19.500
 And I think it's super healthy

1:10:19.500 --> 1:10:21.540
 because we're seeing the ideas percolate

1:10:21.540 --> 1:10:24.020
 and we're seeing the technology diffusion happen

1:10:24.020 --> 1:10:25.260
 as people get more comfortable with it,

1:10:25.260 --> 1:10:27.220
 they start to understand things in their own terms.

1:10:27.220 --> 1:10:28.820
 And this just gets to the,

1:10:28.820 --> 1:10:31.220
 it takes a while for ideas to propagate,

1:10:31.220 --> 1:10:33.980
 even though they may be very different

1:10:33.980 --> 1:10:35.260
 than what people are used to.

1:10:35.260 --> 1:10:37.220
 So maybe let's talk about that a little bit,

1:10:37.220 --> 1:10:38.220
 the world of Asics.

1:10:38.220 --> 1:10:39.060
 Yeah.

1:10:39.060 --> 1:10:44.060
 Actually, you have a new role at SciFive.

1:10:45.420 --> 1:10:47.380
 What's that place about?

1:10:47.380 --> 1:10:50.980
 What is the vision for their vision

1:10:50.980 --> 1:10:52.940
 for, I would say, the future of computer?

1:10:52.940 --> 1:10:55.900
 Yeah, so I lead the engineering and product teams at SciFive.

1:10:55.900 --> 1:10:59.660
 SciFive is a company who was founded

1:10:59.660 --> 1:11:02.580
 with this architecture called RISC5.

1:11:02.580 --> 1:11:04.380
 RISC5 is a new instruction set.

1:11:04.380 --> 1:11:06.300
 Instruction sets are the things inside of your computer

1:11:06.300 --> 1:11:08.420
 that tell it how to run things.

1:11:08.420 --> 1:11:12.020
 X86 from Intel and ARM from the ARM company

1:11:12.020 --> 1:11:13.860
 and things like this are other instruction sets.

1:11:13.860 --> 1:11:15.020
 I've talked to, sorry to interrupt,

1:11:15.020 --> 1:11:15.980
 I've talked to Dave Patterson,

1:11:15.980 --> 1:11:17.980
 who's super excited about RISC5.

1:11:17.980 --> 1:11:18.860
 Dave is awesome.

1:11:18.860 --> 1:11:20.540
 Yeah, he's brilliant, yeah.

1:11:20.540 --> 1:11:23.660
 The RISC5 is distinguished by not being proprietary.

1:11:24.540 --> 1:11:28.820
 And so X86 can only be made by Intel and AMD.

1:11:28.820 --> 1:11:30.380
 ARM can only be made by ARM.

1:11:30.380 --> 1:11:33.340
 They sell licenses to build ARM chips to other companies,

1:11:33.340 --> 1:11:34.180
 things like this.

1:11:34.180 --> 1:11:35.540
 MIPS is another instruction set

1:11:35.540 --> 1:11:38.300
 that is owned by the MIPS company, now Wave.

1:11:38.300 --> 1:11:40.860
 And then it gets licensed out, things like that.

1:11:40.860 --> 1:11:43.340
 And so RISC5 is an open standard

1:11:43.340 --> 1:11:45.140
 that anybody can build chips for.

1:11:45.140 --> 1:11:48.220
 And so SciFive was founded by three of the founders

1:11:48.220 --> 1:11:51.580
 of RISC5 that designed and built it in Berkeley,

1:11:51.580 --> 1:11:52.860
 working with Dave.

1:11:52.860 --> 1:11:55.780
 And so that was the genesis of the company.

1:11:56.780 --> 1:11:59.060
 SciFive today has some of the world's best RISC5 cores

1:11:59.060 --> 1:12:01.420
 and we're selling them and that's really great.

1:12:01.420 --> 1:12:04.020
 They're going to tons of products, it's very exciting.

1:12:04.020 --> 1:12:06.100
 So they're taking this thing that's open source

1:12:06.100 --> 1:12:09.620
 and just trying to be or are the best in the world

1:12:09.620 --> 1:12:10.780
 at building these things.

1:12:10.780 --> 1:12:13.260
 Yeah, so here it's the specifications open source.

1:12:13.260 --> 1:12:15.940
 It's like saying TCP IP is an open standard

1:12:15.940 --> 1:12:18.020
 or C is an open standard,

1:12:18.020 --> 1:12:19.620
 but then you have to build an implementation

1:12:19.620 --> 1:12:20.780
 of the standard.

1:12:20.780 --> 1:12:23.660
 And so SciFive, on the one hand, pushes forward

1:12:23.660 --> 1:12:26.260
 and defined and pushes forward the standard.

1:12:26.260 --> 1:12:28.100
 On the other hand, we have implementations

1:12:28.100 --> 1:12:30.980
 that are best in class for different points in the space,

1:12:30.980 --> 1:12:33.620
 depending on if you want a really tiny CPU

1:12:33.620 --> 1:12:36.980
 or if you want a really big, beefy one that is faster,

1:12:36.980 --> 1:12:38.860
 but it uses more area and things like this.

1:12:38.860 --> 1:12:41.220
 What about the actual manufacturer chips?

1:12:41.220 --> 1:12:43.580
 So like, where does that all fit?

1:12:43.580 --> 1:12:45.340
 I'm going to ask a bunch of dumb questions.

1:12:45.340 --> 1:12:48.180
 That's okay, this is how we learn, right?

1:12:48.180 --> 1:12:52.540
 And so the way this works is that there's generally

1:12:52.540 --> 1:12:55.140
 a separation of the people who designed the circuits

1:12:55.140 --> 1:12:56.900
 and then people who manufacture them.

1:12:56.900 --> 1:13:00.780
 And so you'll hear about fabs like TSMC and Samsung

1:13:00.780 --> 1:13:03.780
 and things like this that actually produce the chips,

1:13:03.780 --> 1:13:05.820
 but they take a design coming in

1:13:05.820 --> 1:13:09.940
 and that design specifies how the,

1:13:09.940 --> 1:13:14.940
 you turn code for the chip into little rectangles

1:13:16.300 --> 1:13:20.260
 that then use photolithography to make mask sets

1:13:20.260 --> 1:13:22.260
 and then burn transistors onto a chip

1:13:22.260 --> 1:13:24.700
 or onto a, onto silicon rather.

1:13:24.700 --> 1:13:28.340
 So, and we're talking about mass manufacturing, so.

1:13:28.340 --> 1:13:29.940
 Yeah, they're talking about making hundreds of millions

1:13:29.940 --> 1:13:31.380
 of parts and things like that, yeah.

1:13:31.380 --> 1:13:33.580
 And so the fab handles the volume production,

1:13:33.580 --> 1:13:34.660
 things like that.

1:13:34.660 --> 1:13:36.380
 But when you look at this problem,

1:13:37.260 --> 1:13:39.740
 the interesting thing about the space when you look at it

1:13:39.740 --> 1:13:44.380
 is that these, the steps that you go from designing a chip

1:13:44.380 --> 1:13:46.300
 and writing the quote unquote code for it

1:13:46.300 --> 1:13:49.220
 and things like Verilog and languages like that,

1:13:49.220 --> 1:13:51.660
 down to what you hand off to the fab

1:13:51.660 --> 1:13:56.260
 is a really well studied, really old problem, okay?

1:13:56.260 --> 1:13:57.580
 Tons of people have worked on it.

1:13:57.580 --> 1:14:00.580
 Lots of smart people have built systems and tools.

1:14:00.580 --> 1:14:03.500
 These tools then have generally gone through acquisitions.

1:14:03.500 --> 1:14:06.180
 And so they've ended up at three different major companies

1:14:06.180 --> 1:14:07.780
 that build and sell these tools.

1:14:07.780 --> 1:14:08.980
 They're called the EDA tools

1:14:08.980 --> 1:14:11.660
 like for electronic design automation.

1:14:11.660 --> 1:14:13.220
 The problem with this is you have huge amounts

1:14:13.220 --> 1:14:17.100
 of fragmentation, you have loose standards

1:14:17.900 --> 1:14:20.060
 and the tools don't really work together.

1:14:20.060 --> 1:14:21.300
 So you have tons of duct tape

1:14:21.300 --> 1:14:24.260
 and you have tons of loss productivity.

1:14:24.260 --> 1:14:26.740
 Now these are, these are tools for designing.

1:14:26.740 --> 1:14:30.260
 So the RISC 5 is a instruction.

1:14:30.260 --> 1:14:32.060
 Like what is RISC 5?

1:14:32.060 --> 1:14:33.260
 Like how deep does it go?

1:14:33.260 --> 1:14:35.940
 How much does it touch the hardware?

1:14:35.940 --> 1:14:38.460
 How much does it define how much of the hardware is?

1:14:38.460 --> 1:14:41.900
 Yeah, so RISC 5 is all about given a CPU.

1:14:41.900 --> 1:14:44.900
 So the processor and your computer,

1:14:44.900 --> 1:14:47.420
 how does the compiler like Swift compiler,

1:14:47.420 --> 1:14:50.500
 the C compiler, things like this, how does it make it work?

1:14:50.500 --> 1:14:52.700
 So it's, what is the assembly code?

1:14:52.700 --> 1:14:54.180
 And so you write RISC 5 assembly

1:14:54.180 --> 1:14:57.060
 instead of XA6 assembly, for example.

1:14:57.060 --> 1:14:58.620
 But it's a set of instructions

1:14:58.620 --> 1:15:00.060
 as opposed to instructions.

1:15:00.060 --> 1:15:03.660
 Why do you say it tells you how the compiler works?

1:15:03.660 --> 1:15:05.380
 Sorry, it's what the compiler talks to.

1:15:05.380 --> 1:15:06.220
 Okay. Yeah.

1:15:06.220 --> 1:15:08.500
 And then the tooling you mentioned

1:15:08.500 --> 1:15:10.700
 that the disparate tools are for what?

1:15:10.700 --> 1:15:13.340
 For when you're building a specific chip.

1:15:13.340 --> 1:15:14.860
 So RISC 5. In hardware.

1:15:14.860 --> 1:15:15.740
 In hardware, yeah.

1:15:15.740 --> 1:15:19.140
 So RISC 5, you can buy a RISC 5 core from SciFive

1:15:19.140 --> 1:15:21.660
 and say, hey, I want to have a certain number of,

1:15:21.660 --> 1:15:23.380
 run a certain number of gigahertz.

1:15:23.380 --> 1:15:24.660
 I want it to be this big.

1:15:24.660 --> 1:15:26.820
 I want it to be, have these features.

1:15:26.820 --> 1:15:29.860
 I want to have like, I want floating point or not,

1:15:29.860 --> 1:15:30.780
 for example.

1:15:31.860 --> 1:15:34.180
 And then what you get is you get a description

1:15:34.180 --> 1:15:36.620
 of a CPU with those characteristics.

1:15:36.620 --> 1:15:38.140
 Now, if you want to make a chip,

1:15:38.140 --> 1:15:39.940
 you want to build like an iPhone chip

1:15:39.940 --> 1:15:41.180
 or something like that, right?

1:15:41.180 --> 1:15:42.740
 You have to take both the CPU,

1:15:42.740 --> 1:15:44.380
 but then you have to talk to memory.

1:15:44.380 --> 1:15:49.300
 You have to have timers, IOs, a GPU, other components.

1:15:49.300 --> 1:15:51.380
 And so you need to pull all those things together

1:15:51.380 --> 1:15:53.900
 into what's called an ASIC,

1:15:53.900 --> 1:15:55.500
 an Application Specific Integrated Circuit.

1:15:55.500 --> 1:15:56.860
 So a custom chip.

1:15:56.860 --> 1:15:58.980
 And then you take that design

1:15:58.980 --> 1:16:00.900
 and then you have to transform it into something

1:16:00.900 --> 1:16:03.980
 that the fabs, like TSMC, for example,

1:16:03.980 --> 1:16:06.740
 know how to take to production.

1:16:06.740 --> 1:16:07.580
 Got it.

1:16:07.580 --> 1:16:08.580
 So, but yeah, okay.

1:16:08.580 --> 1:16:10.620
 And so that process, I will,

1:16:11.820 --> 1:16:15.620
 I can't help but see it as, is a big compiler.

1:16:15.620 --> 1:16:16.940
 Yeah, yeah.

1:16:16.940 --> 1:16:18.860
 It's a whole bunch of compilers written

1:16:18.860 --> 1:16:21.420
 without thinking about it through that lens.

1:16:21.420 --> 1:16:23.700
 Isn't the universe a compiler?

1:16:23.700 --> 1:16:26.820
 Yeah, compilers do two things.

1:16:26.820 --> 1:16:29.140
 They represent things and transform them.

1:16:29.140 --> 1:16:31.780
 And so there's a lot of things that end up being compilers.

1:16:31.780 --> 1:16:34.700
 But this is a space where we're talking about design

1:16:34.700 --> 1:16:37.460
 and usability and the way you think about things,

1:16:37.460 --> 1:16:40.900
 the way things compose correctly, it matters a lot.

1:16:40.900 --> 1:16:43.460
 And so SciFi is investing a lot into that space.

1:16:43.460 --> 1:16:45.900
 And we think that there's a lot of benefit

1:16:45.900 --> 1:16:48.980
 that can be made by allowing people to design chips faster,

1:16:48.980 --> 1:16:52.020
 get them to market quicker and scale out

1:16:52.020 --> 1:16:56.420
 because at the alleged end of Moore's law,

1:16:56.420 --> 1:16:59.300
 you've got this problem of you're not getting

1:16:59.300 --> 1:17:01.980
 free performance just by waiting another year

1:17:01.980 --> 1:17:03.540
 for a faster CPU.

1:17:03.540 --> 1:17:06.540
 And so you have to find performance in other ways.

1:17:06.540 --> 1:17:09.100
 And one of the ways to do that is with custom accelerators

1:17:09.100 --> 1:17:11.460
 and other things and hardware.

1:17:11.460 --> 1:17:16.460
 And so, well, we'll talk a little more about ASICs,

1:17:17.420 --> 1:17:21.980
 but do you see that a lot of people,

1:17:21.980 --> 1:17:25.300
 a lot of companies will try to have

1:17:25.300 --> 1:17:26.980
 different sets of requirements

1:17:26.980 --> 1:17:28.380
 that this whole process to go for?

1:17:28.380 --> 1:17:32.540
 So like almost different car companies might use different

1:17:32.540 --> 1:17:35.660
 and like different PC manufacturers.

1:17:35.660 --> 1:17:40.660
 So is RISC 5 in this whole process,

1:17:40.660 --> 1:17:44.860
 is it potentially the future of all computing devices?

1:17:44.860 --> 1:17:47.460
 Yeah, I think that, so if you look at RISC 5

1:17:47.460 --> 1:17:49.660
 and step back from the Silicon side of things,

1:17:49.660 --> 1:17:51.580
 RISC 5 is an open standard.

1:17:51.580 --> 1:17:53.900
 And one of the things that has happened

1:17:53.900 --> 1:17:55.460
 over the course of decades,

1:17:55.460 --> 1:17:57.820
 if you look over the long arc of computing,

1:17:57.820 --> 1:17:59.220
 somehow became decades old.

1:17:59.220 --> 1:18:00.060
 Yeah.

1:18:00.060 --> 1:18:02.700
 Is that you have companies that come and go

1:18:02.700 --> 1:18:04.900
 and you have instruction sets that come and go.

1:18:04.900 --> 1:18:09.900
 Like one example of this out of many is Sun with Spark.

1:18:09.900 --> 1:18:11.260
 Yeah, it's on one way.

1:18:11.260 --> 1:18:12.980
 Spark still lives on at Fujitsu,

1:18:12.980 --> 1:18:17.340
 but we have HP had this instruction set called PA RISC.

1:18:18.140 --> 1:18:21.020
 So PA RISC was this big server business

1:18:21.020 --> 1:18:22.900
 and had tons of customers.

1:18:22.900 --> 1:18:25.100
 They decided to move to this architecture

1:18:25.100 --> 1:18:27.140
 called Itanium from Intel.

1:18:27.140 --> 1:18:27.980
 Yeah.

1:18:27.980 --> 1:18:29.620
 This didn't work out so well.

1:18:29.620 --> 1:18:30.460
 Yeah.

1:18:30.460 --> 1:18:32.940
 Right, and so you have this issue of

1:18:32.940 --> 1:18:35.380
 you're making many billion dollar investments

1:18:35.380 --> 1:18:38.220
 on instruction sets that are owned by a company.

1:18:38.220 --> 1:18:39.740
 And even companies as big as Intel

1:18:39.740 --> 1:18:42.460
 don't always execute as well as they could.

1:18:42.460 --> 1:18:44.700
 They even have their own issues.

1:18:44.700 --> 1:18:46.700
 HP, for example, decided that it wasn't

1:18:46.700 --> 1:18:48.620
 in their best interest to continue investing in the space

1:18:48.620 --> 1:18:49.700
 because it was very expensive.

1:18:49.700 --> 1:18:52.180
 And so they make technology decisions

1:18:52.180 --> 1:18:54.180
 or they make their own business decisions.

1:18:54.180 --> 1:18:57.860
 And this means that as a customer, what do you do?

1:18:57.860 --> 1:18:59.660
 You've sunk all this time, all this engineering,

1:18:59.660 --> 1:19:01.300
 all this software work, all these,

1:19:01.300 --> 1:19:02.540
 you've built other products around them

1:19:02.540 --> 1:19:05.020
 and now you're stuck, right?

1:19:05.020 --> 1:19:07.580
 What RISC 5 does is provide you more optionality

1:19:07.580 --> 1:19:10.860
 in the space because if you buy an implementation

1:19:10.860 --> 1:19:13.540
 of RISC 5 from SciFive, and you should,

1:19:13.540 --> 1:19:14.380
 they're the best ones.

1:19:14.380 --> 1:19:15.220
 Yeah.

1:19:16.380 --> 1:19:19.460
 But if something bad happens to SciFive in 20 years, right?

1:19:19.460 --> 1:19:21.220
 Well, great, you can turn around

1:19:21.220 --> 1:19:23.300
 and buy a RISC 5 core from somebody else.

1:19:23.300 --> 1:19:25.020
 And there's an ecosystem of people

1:19:25.020 --> 1:19:26.620
 that are all making different RISC 5 cores

1:19:26.620 --> 1:19:29.180
 with different trade offs, which means that

1:19:29.180 --> 1:19:30.620
 if you have more than one requirement,

1:19:30.620 --> 1:19:31.900
 if you have a family of products,

1:19:31.900 --> 1:19:34.700
 you can probably find something in the RISC 5 space

1:19:34.700 --> 1:19:36.020
 that fits your needs.

1:19:36.020 --> 1:19:39.620
 Whereas with, if you're talking about XA6, for example,

1:19:39.620 --> 1:19:41.340
 it's Intel's only gonna bother

1:19:41.340 --> 1:19:45.060
 to make certain classes of devices, right?

1:19:45.060 --> 1:19:47.740
 I see, so maybe a weird question,

1:19:47.740 --> 1:19:52.740
 but like if SciFive is like infinitely successful

1:19:54.820 --> 1:19:58.100
 in the next 20, 30 years, what does the world look like?

1:19:58.100 --> 1:20:01.900
 So like how does the world of computing change?

1:20:01.900 --> 1:20:05.340
 So too much diversity in hardware instruction sets,

1:20:05.340 --> 1:20:06.540
 I think is bad.

1:20:06.540 --> 1:20:08.660
 Like we have a lot of people that are using

1:20:09.700 --> 1:20:10.980
 lots of different instruction sets,

1:20:10.980 --> 1:20:12.260
 particularly in the embedded,

1:20:12.260 --> 1:20:14.340
 the like very tiny microcontroller space,

1:20:14.340 --> 1:20:19.340
 the thing in your toaster that are just weird

1:20:19.580 --> 1:20:21.060
 and different for historical reasons.

1:20:21.060 --> 1:20:23.100
 And so the compilers and the tool chains

1:20:23.100 --> 1:20:27.140
 and the languages on top of them aren't there.

1:20:27.140 --> 1:20:29.220
 And so the developers for that software

1:20:29.220 --> 1:20:31.060
 have to use really weird tools

1:20:31.060 --> 1:20:34.220
 because the ecosystem that supports is not big enough.

1:20:34.220 --> 1:20:35.460
 So I expect that will change, right?

1:20:35.460 --> 1:20:38.060
 People will have better tools and better languages,

1:20:38.060 --> 1:20:39.460
 better features everywhere

1:20:39.460 --> 1:20:42.300
 that then can serve as many different points in the space.

1:20:43.300 --> 1:20:46.300
 And I think RISC5 will progressively

1:20:46.300 --> 1:20:49.420
 eat more of the ecosystem because it can scale up,

1:20:49.420 --> 1:20:51.620
 it can scale down, sideways, left, right.

1:20:51.620 --> 1:20:53.860
 It's very flexible and very well considered

1:20:53.860 --> 1:20:55.500
 and well designed instruction set.

1:20:56.420 --> 1:20:58.820
 I think when you look at SciFive tackling silicon

1:20:58.820 --> 1:21:00.020
 and how people build chips,

1:21:00.020 --> 1:21:03.980
 which is a very different space,

1:21:03.980 --> 1:21:05.180
 that's where you say,

1:21:05.180 --> 1:21:07.540
 I think we'll see a lot more custom chips.

1:21:07.540 --> 1:21:09.820
 And that means that you get much more battery life,

1:21:09.820 --> 1:21:14.820
 you get better tuned solutions for your IoT thingy.

1:21:16.220 --> 1:21:18.260
 You get people that move faster,

1:21:18.260 --> 1:21:20.700
 you get the ability to have faster time to market,

1:21:20.700 --> 1:21:21.540
 for example.

1:21:21.540 --> 1:21:22.620
 So how many custom...

1:21:22.620 --> 1:21:25.020
 So first of all, on the IoT side of things,

1:21:25.020 --> 1:21:29.100
 do you see the number of smart toasters

1:21:29.100 --> 1:21:30.260
 increasing exponentially?

1:21:30.260 --> 1:21:35.260
 So, and if you do,

1:21:35.460 --> 1:21:38.940
 like how much customization per toaster is there?

1:21:38.940 --> 1:21:42.700
 Do all toasters in the world run the same silicon,

1:21:42.700 --> 1:21:44.060
 like the same design,

1:21:44.060 --> 1:21:46.060
 or is it different companies have different design?

1:21:46.060 --> 1:21:49.700
 Like how much customization is possible here?

1:21:49.700 --> 1:21:52.460
 Well, a lot of it comes down to cost, right?

1:21:52.460 --> 1:21:56.100
 And so the way that chips work is you end up paying by the...

1:21:56.100 --> 1:21:58.780
 One of the factors is the size of the chip.

1:21:58.780 --> 1:22:01.380
 And so what ends up happening

1:22:01.380 --> 1:22:03.180
 just from an economic perspective is

1:22:03.180 --> 1:22:06.100
 there's only so many chips that get made in a year

1:22:06.100 --> 1:22:07.340
 of a given design.

1:22:07.340 --> 1:22:10.220
 And so often what customers end up having to do

1:22:10.220 --> 1:22:12.260
 is they end up having to pick up a chip that exists

1:22:12.260 --> 1:22:14.140
 that was built for somebody else

1:22:14.140 --> 1:22:16.500
 so that they can then ship their product.

1:22:16.500 --> 1:22:17.340
 And the reason for that

1:22:17.340 --> 1:22:19.220
 is they don't have the volume of the iPhone.

1:22:19.220 --> 1:22:21.700
 They can't afford to build a custom chip.

1:22:21.700 --> 1:22:23.820
 However, what that means is they're now buying

1:22:23.820 --> 1:22:26.900
 an off the shelf chip that isn't really good,

1:22:26.900 --> 1:22:28.220
 isn't a perfect fit for their needs.

1:22:28.220 --> 1:22:30.060
 And so they're paying a lot of money for it

1:22:30.060 --> 1:22:33.500
 because they're buying silicon that they're not using.

1:22:33.500 --> 1:22:36.580
 Well, if you now reduce the cost of designing the chip,

1:22:36.580 --> 1:22:37.780
 now you get a lot more chips.

1:22:37.780 --> 1:22:39.500
 And the more you reduce it,

1:22:39.500 --> 1:22:42.340
 the easier it is to design chips.

1:22:42.340 --> 1:22:44.340
 The more the world keeps evolving

1:22:44.340 --> 1:22:45.740
 and we get more AI accelerators,

1:22:45.740 --> 1:22:46.740
 we get more other things,

1:22:46.740 --> 1:22:48.780
 we get more standards to talk to,

1:22:48.780 --> 1:22:50.980
 we get 6G, right?

1:22:50.980 --> 1:22:53.180
 You get changes in the world

1:22:53.180 --> 1:22:54.780
 that you wanna be able to talk to these different things.

1:22:54.780 --> 1:22:57.220
 There's more diversity in the cross product of features

1:22:57.220 --> 1:22:58.460
 that people want.

1:22:58.460 --> 1:23:02.140
 And that drives differentiated chips

1:23:02.140 --> 1:23:03.300
 in another direction.

1:23:03.300 --> 1:23:05.620
 And so nobody really knows what the future looks like,

1:23:05.620 --> 1:23:09.780
 but I think that there's a lot of silicon in the future.

1:23:09.780 --> 1:23:11.180
 Speaking of the future,

1:23:11.180 --> 1:23:13.740
 you said Moore's law allegedly is dead.

1:23:13.740 --> 1:23:18.740
 So do you agree with Dave Patterson and many folks

1:23:20.340 --> 1:23:22.100
 that Moore's law is dead?

1:23:22.100 --> 1:23:23.940
 Or do you agree with Jim Keller,

1:23:23.940 --> 1:23:28.620
 who's standing at the helm of the pirate ship

1:23:28.620 --> 1:23:31.620
 saying it's still alive?

1:23:31.620 --> 1:23:32.460
 Yeah.

1:23:32.460 --> 1:23:35.700
 Well, so I agree with what they're saying

1:23:35.700 --> 1:23:37.780
 and different people are interpreting

1:23:37.780 --> 1:23:39.340
 the end of Moore's law in different ways.

1:23:39.340 --> 1:23:40.180
 Yeah.

1:23:40.180 --> 1:23:41.020
 So Jim would say,

1:23:41.020 --> 1:23:44.180
 there's another thousand X left in physics

1:23:44.180 --> 1:23:46.900
 and we can continue to squeeze the stone

1:23:46.900 --> 1:23:50.060
 and make it faster and smaller and smaller geometries

1:23:50.060 --> 1:23:51.380
 and all that kind of stuff.

1:23:52.340 --> 1:23:53.500
 He's right.

1:23:53.500 --> 1:23:55.220
 So Jim is absolutely right

1:23:55.220 --> 1:23:57.820
 that there's a ton of progress left

1:23:57.820 --> 1:23:59.980
 and we're not at the limit of physics yet.

1:24:01.700 --> 1:24:03.980
 That's not really what Moore's law is though.

1:24:04.940 --> 1:24:06.620
 If you look at what Moore's law is,

1:24:06.620 --> 1:24:10.660
 is that it's a very simple evaluation of,

1:24:10.660 --> 1:24:13.580
 okay, well you look at the cost per,

1:24:13.580 --> 1:24:14.980
 I think it was cost per area

1:24:14.980 --> 1:24:17.020
 and the most economic point in that space.

1:24:17.020 --> 1:24:20.020
 And if you go look at the now quite old paper

1:24:20.020 --> 1:24:21.860
 that describes this,

1:24:21.860 --> 1:24:25.460
 Moore's law has a specific economic aspect to it

1:24:25.460 --> 1:24:26.380
 and I think this is something

1:24:26.380 --> 1:24:28.220
 that Dave and others often point out.

1:24:28.220 --> 1:24:30.540
 And so on a technicality, that's right.

1:24:31.380 --> 1:24:33.300
 I look at it from,

1:24:33.300 --> 1:24:34.980
 so I can acknowledge both of those viewpoints.

1:24:34.980 --> 1:24:35.820
 They're both right.

1:24:35.820 --> 1:24:36.660
 They're both right.

1:24:36.660 --> 1:24:39.140
 I'll give you a third wrong viewpoint

1:24:39.140 --> 1:24:40.300
 that may be right in its own way,

1:24:40.300 --> 1:24:43.020
 which is single threaded performance

1:24:44.060 --> 1:24:46.020
 doesn't improve like it used to.

1:24:46.020 --> 1:24:48.460
 And it used to be back when you got a,

1:24:48.460 --> 1:24:50.580
 you know, a Pentium 66 or something

1:24:50.580 --> 1:24:53.820
 and the year before you had a Pentium 33

1:24:53.820 --> 1:24:56.740
 and now it's twice as fast, right?

1:24:56.740 --> 1:25:00.380
 Well, it was twice as fast at doing exactly the same thing.

1:25:00.380 --> 1:25:03.820
 Okay, like literally the same program ran twice as fast.

1:25:03.820 --> 1:25:07.020
 You just wrote a check and waited a year, year and a half.

1:25:07.020 --> 1:25:10.100
 Well, so that's what a lot of people think about Moore's law

1:25:10.100 --> 1:25:11.780
 and I think that is dead.

1:25:11.780 --> 1:25:15.260
 And so what we're seeing instead is we're pushing,

1:25:15.260 --> 1:25:17.260
 we're pushing people to write software in different ways.

1:25:17.260 --> 1:25:19.060
 And so we're pushing people to write CUDA

1:25:19.060 --> 1:25:20.980
 so they can get GPU compute

1:25:20.980 --> 1:25:23.420
 and the thousands of cores on GPU.

1:25:23.420 --> 1:25:26.380
 We're talking about C programmers having to use P threads

1:25:26.380 --> 1:25:27.860
 because they now have, you know,

1:25:27.860 --> 1:25:30.460
 a hundred threads or 50 cores in a machine

1:25:30.460 --> 1:25:31.980
 or something like that.

1:25:31.980 --> 1:25:33.660
 You're now talking about machine learning accelerators

1:25:33.660 --> 1:25:35.100
 that are now domain specific.

1:25:35.100 --> 1:25:38.460
 And when you look at these kinds of use cases,

1:25:38.460 --> 1:25:40.460
 you can still get performance

1:25:40.460 --> 1:25:42.660
 and Jim will come up with cool things

1:25:42.660 --> 1:25:45.780
 that utilize the silicon in new ways for sure,

1:25:45.780 --> 1:25:48.420
 but you're also gonna change the programming model.

1:25:48.420 --> 1:25:49.260
 Right.

1:25:49.260 --> 1:25:50.140
 And now when you start talking about changing

1:25:50.140 --> 1:25:50.980
 the programming model,

1:25:50.980 --> 1:25:53.060
 that's when you come back to languages

1:25:53.060 --> 1:25:54.020
 and things like this too,

1:25:54.020 --> 1:25:58.500
 because often what you see is like you take

1:25:58.500 --> 1:25:59.820
 the C programming language, right?

1:25:59.820 --> 1:26:02.220
 The C programming language is designed for CPUs.

1:26:03.340 --> 1:26:04.980
 And so if you want to talk to a GPU,

1:26:04.980 --> 1:26:08.820
 now you're talking to its cousin CUDA, okay?

1:26:08.820 --> 1:26:11.900
 CUDA is a different thing with a different set of tools,

1:26:11.900 --> 1:26:14.380
 a different world, a different way of thinking.

1:26:14.380 --> 1:26:16.940
 And we don't have one world that scales.

1:26:16.940 --> 1:26:18.460
 And I think that we can get there.

1:26:18.460 --> 1:26:21.020
 We can have one world that scales in a much better way.

1:26:21.020 --> 1:26:22.500
 And a small tangent then,

1:26:22.500 --> 1:26:25.940
 I think most programming languages are designed for CPUs,

1:26:25.940 --> 1:26:28.900
 for single core, even just in their spirit,

1:26:28.900 --> 1:26:30.460
 even if they allow for parallelization.

1:26:30.460 --> 1:26:34.140
 So what does it look like for a programming language

1:26:34.140 --> 1:26:38.660
 to have parallelization or massive parallelization

1:26:38.660 --> 1:26:41.300
 as it's like first principle?

1:26:41.300 --> 1:26:43.540
 So the canonical example of this

1:26:43.540 --> 1:26:46.380
 is the hardware design world.

1:26:46.380 --> 1:26:50.020
 So Verilog, VHDL, these kinds of languages,

1:26:50.020 --> 1:26:53.500
 they're what's called a high level synthesis language.

1:26:53.500 --> 1:26:56.860
 This is the thing people design chips in.

1:26:56.860 --> 1:26:58.140
 And when you're designing a chip,

1:26:58.140 --> 1:27:02.660
 it's kind of like a brain where you have infinite parallelism.

1:27:02.660 --> 1:27:05.580
 Like you're like laying down transistors.

1:27:05.580 --> 1:27:08.340
 Transistors are always running, okay?

1:27:08.340 --> 1:27:10.260
 And so you're not saying run this transistor,

1:27:10.260 --> 1:27:12.300
 then this transistor, then this transistor.

1:27:12.300 --> 1:27:13.140
 It's like your brain,

1:27:13.140 --> 1:27:15.300
 like your neurons are always just doing something.

1:27:15.300 --> 1:27:16.780
 They're not clocked, right?

1:27:16.780 --> 1:27:20.180
 They're just doing their thing.

1:27:20.180 --> 1:27:23.540
 And so when you design a chip or when you design a CPU,

1:27:23.540 --> 1:27:25.180
 when you design a GPU, when you design,

1:27:25.180 --> 1:27:27.260
 when you're laying down the transistors,

1:27:27.260 --> 1:27:28.460
 similarly, you're talking about,

1:27:28.460 --> 1:27:31.300
 well, okay, well, how do these things communicate?

1:27:31.300 --> 1:27:32.740
 And so these languages exist.

1:27:32.740 --> 1:27:36.140
 Verilog is a kind of mixed example of that.

1:27:36.140 --> 1:27:37.620
 None of these languages are really great.

1:27:37.620 --> 1:27:39.580
 You have a very low level, yeah.

1:27:39.580 --> 1:27:40.660
 Yeah, they're very low level

1:27:40.660 --> 1:27:42.540
 and abstraction is necessary here.

1:27:42.540 --> 1:27:44.500
 And there's different approaches with that.

1:27:44.500 --> 1:27:47.340
 And it's itself a very complicated world,

1:27:47.340 --> 1:27:50.620
 but it's implicitly parallel.

1:27:50.620 --> 1:27:55.620
 And so having that as the domain that you program towards

1:27:56.220 --> 1:27:59.460
 makes it so that by default, you get parallel systems.

1:27:59.460 --> 1:28:00.300
 If you look at CUDA,

1:28:00.300 --> 1:28:03.660
 CUDA is a point halfway in the space where in CUDA,

1:28:03.660 --> 1:28:05.940
 when you write a CUDA kernel for your GPU,

1:28:05.940 --> 1:28:08.100
 it feels like you're writing a scalar program.

1:28:08.100 --> 1:28:10.020
 So you're like, you have ifs, you have for loops,

1:28:10.020 --> 1:28:12.620
 stuff like this, you're just writing normal code.

1:28:12.620 --> 1:28:14.820
 But what happens outside of that in your driver

1:28:14.820 --> 1:28:16.180
 is that it actually is running you

1:28:16.180 --> 1:28:18.900
 on like a thousand things at once, right?

1:28:18.900 --> 1:28:20.580
 And so it's parallel,

1:28:20.580 --> 1:28:23.020
 but it has pulled it out of the programming model.

1:28:23.900 --> 1:28:28.460
 And so now you as a programmer are working in a simpler world

1:28:28.460 --> 1:28:31.540
 and it's solved that for you, right?

1:28:31.540 --> 1:28:33.780
 How do you take the language like Swift?

1:28:36.420 --> 1:28:39.060
 If we think about GPUs, but also ASICs,

1:28:39.060 --> 1:28:40.900
 maybe if we can dance back and forth

1:28:40.900 --> 1:28:42.500
 between hardware and software.

1:28:42.500 --> 1:28:46.740
 How do you design for these features

1:28:46.740 --> 1:28:50.060
 to be able to program and get a first class citizen

1:28:50.060 --> 1:28:53.100
 to be able to do like Swift for TensorFlow

1:28:53.100 --> 1:28:56.660
 to be able to do machine learning on current hardware,

1:28:56.660 --> 1:28:59.700
 but also future hardware like TPUs

1:28:59.700 --> 1:29:00.660
 and all kinds of ASICs

1:29:00.660 --> 1:29:02.220
 that I'm sure will be popping up more and more.

1:29:02.220 --> 1:29:04.380
 Yeah, well, so a lot of this comes down

1:29:04.380 --> 1:29:06.540
 to this whole idea of having the nuts and bolts

1:29:06.540 --> 1:29:08.660
 underneath the covers that work really well.

1:29:08.660 --> 1:29:10.420
 So you need, if you're talking to TPUs,

1:29:10.420 --> 1:29:13.780
 you need MLIR or XLA or one of these compilers

1:29:13.780 --> 1:29:17.420
 that talks to TPUs to build on top of, okay?

1:29:17.420 --> 1:29:19.340
 And if you're talking to circuits,

1:29:19.340 --> 1:29:21.500
 you need to figure out how to lay down the transistors

1:29:21.500 --> 1:29:23.300
 and how to organize it and how to set up clocking

1:29:23.300 --> 1:29:24.460
 and like all the domain problems

1:29:24.460 --> 1:29:26.180
 that you get with circuits.

1:29:27.420 --> 1:29:29.780
 Then you have to decide how to explain it to a human.

1:29:29.780 --> 1:29:31.820
 What is ZY, right?

1:29:31.820 --> 1:29:34.460
 And if you do it right, that's a library problem,

1:29:34.460 --> 1:29:36.420
 not a language problem.

1:29:36.420 --> 1:29:39.060
 And that works if you have a library or a language

1:29:39.060 --> 1:29:42.140
 which allows your library to write things

1:29:42.140 --> 1:29:45.820
 that feel native in the language by implementing libraries,

1:29:45.820 --> 1:29:49.220
 because then you can innovate in programming models

1:29:49.220 --> 1:29:51.220
 without having to change your syntax again.

1:29:51.220 --> 1:29:54.860
 Like you have to invent new code formatting tools

1:29:54.860 --> 1:29:57.500
 and like all the other things that languages come with.

1:29:57.500 --> 1:29:59.940
 And this gets really interesting.

1:29:59.940 --> 1:30:02.300
 And so if you look at the space,

1:30:02.300 --> 1:30:05.820
 the interesting thing once you separate out syntax

1:30:05.820 --> 1:30:07.860
 becomes what is that programming model?

1:30:07.860 --> 1:30:10.260
 And so do you want the CUDA style?

1:30:10.260 --> 1:30:12.780
 I write one program and it runs many places.

1:30:14.340 --> 1:30:16.820
 Do you want the implicitly parallel model?

1:30:16.820 --> 1:30:17.780
 How do you reason about that?

1:30:17.780 --> 1:30:20.780
 How do you give developers, chip architects,

1:30:20.780 --> 1:30:24.100
 the ability to express their intent?

1:30:24.100 --> 1:30:26.300
 And that comes into this whole design question

1:30:26.300 --> 1:30:29.180
 of how do you detect bugs quickly?

1:30:29.180 --> 1:30:30.260
 So you don't have to tape out a chip

1:30:30.260 --> 1:30:32.620
 to find out it's wrong, ideally, right?

1:30:32.620 --> 1:30:35.540
 How do you, and this is a spectrum,

1:30:35.540 --> 1:30:38.500
 how do you make it so that people feel productive?

1:30:38.500 --> 1:30:40.460
 So their turnaround time is very quick.

1:30:40.460 --> 1:30:42.420
 All these things are really hard problems.

1:30:42.420 --> 1:30:46.100
 And in this world, I think that not a lot of effort

1:30:46.100 --> 1:30:48.060
 has been put into that design problem

1:30:48.060 --> 1:30:51.140
 and thinking about the layering in other pieces.

1:30:51.140 --> 1:30:53.500
 Well, you've, on the topic of concurrency,

1:30:53.500 --> 1:30:55.580
 you've written the Swift concurrency manifest.

1:30:55.580 --> 1:30:57.620
 I think it's kind of interesting.

1:30:57.620 --> 1:31:00.620
 Anything that has the word manifest on it

1:31:00.620 --> 1:31:02.380
 is very interesting.

1:31:02.380 --> 1:31:06.140
 Can you summarize the key ideas of each of the five parts

1:31:06.140 --> 1:31:07.380
 you've written about?

1:31:07.380 --> 1:31:08.900
 So what is a manifesto?

1:31:08.900 --> 1:31:09.740
 Yes.

1:31:09.740 --> 1:31:11.820
 How about, we start there.

1:31:11.820 --> 1:31:15.180
 So in the Swift community, we have this problem,

1:31:15.180 --> 1:31:16.100
 which is on the one hand,

1:31:16.100 --> 1:31:19.300
 you wanna have relatively small proposals

1:31:19.300 --> 1:31:21.420
 that you can kind of fit in your head,

1:31:21.420 --> 1:31:24.100
 you can understand the details at a very fine grain level

1:31:24.100 --> 1:31:26.020
 that move the world forward.

1:31:26.020 --> 1:31:28.900
 But then you also have these big arcs, okay?

1:31:28.900 --> 1:31:30.820
 And often when you're working on something

1:31:30.820 --> 1:31:34.060
 that is a big arc, but you're tackling it in small pieces,

1:31:34.060 --> 1:31:35.180
 you have this question of,

1:31:35.180 --> 1:31:37.580
 how do I know I'm not doing a random walk?

1:31:37.580 --> 1:31:38.780
 Where are we going?

1:31:38.780 --> 1:31:39.740
 How does this add up?

1:31:39.740 --> 1:31:43.580
 Furthermore, when you start the first small step,

1:31:43.580 --> 1:31:45.300
 what terminology do you use?

1:31:45.300 --> 1:31:46.580
 How do we think about it?

1:31:46.580 --> 1:31:47.940
 What is better and worse in the space?

1:31:47.940 --> 1:31:48.780
 What are the principles?

1:31:48.780 --> 1:31:50.100
 What are we trying to achieve?

1:31:50.100 --> 1:31:52.060
 And so what a manifesto in the Swift community does

1:31:52.060 --> 1:31:53.220
 is it starts to say,

1:31:53.220 --> 1:31:56.620
 hey, well, let's step back from the details of everything.

1:31:56.620 --> 1:31:58.700
 Let's paint a broad picture to talk about

1:31:58.700 --> 1:32:01.300
 what we're trying to achieve.

1:32:01.300 --> 1:32:02.780
 Let's give an example design point.

1:32:02.780 --> 1:32:05.260
 Let's try to paint the big picture

1:32:05.260 --> 1:32:07.380
 so that then we can zero in on the individual steps

1:32:07.380 --> 1:32:09.660
 and make sure that we're making good progress.

1:32:09.660 --> 1:32:11.220
 And so the Swift concurrency manifesto

1:32:11.220 --> 1:32:13.860
 is something I wrote three years ago.

1:32:13.860 --> 1:32:16.260
 It's been a while, maybe more.

1:32:16.260 --> 1:32:18.660
 Trying to do that for Swift and concurrency.

1:32:19.740 --> 1:32:22.420
 It starts with some fairly simple things

1:32:22.420 --> 1:32:23.980
 like making the observation that

1:32:25.060 --> 1:32:26.740
 when you have multiple different computers

1:32:26.740 --> 1:32:28.940
 and multiple different threads that are communicating,

1:32:28.940 --> 1:32:30.860
 it's best for them to be asynchronous.

1:32:32.020 --> 1:32:34.540
 And so you need things to be able to run separately

1:32:34.540 --> 1:32:35.820
 and then communicate with each other.

1:32:35.820 --> 1:32:37.420
 And this means asynchrony.

1:32:37.420 --> 1:32:38.980
 And this means that you need a way

1:32:38.980 --> 1:32:41.740
 to modeling asynchronous communication.

1:32:41.740 --> 1:32:43.700
 Many languages have features like this.

1:32:43.700 --> 1:32:45.420
 Async await is a popular one.

1:32:45.420 --> 1:32:48.220
 And so that's what I think is very likely in Swift.

1:32:49.220 --> 1:32:51.380
 But as you start building this tower of abstractions,

1:32:51.380 --> 1:32:53.660
 it's not just about how do you write this,

1:32:53.660 --> 1:32:57.460
 you then reach into the how do you get memory safety

1:32:57.460 --> 1:32:58.380
 because you want correctness,

1:32:58.380 --> 1:33:01.700
 you want debuggability and sanity for developers.

1:33:01.700 --> 1:33:06.620
 And how do you get that memory safety into the language?

1:33:06.620 --> 1:33:09.020
 So if you take a language like Go or C

1:33:09.020 --> 1:33:10.420
 or any of these languages,

1:33:10.420 --> 1:33:11.940
 you get what's called a race condition

1:33:11.940 --> 1:33:14.900
 when two different threads or Go routines or whatever

1:33:14.900 --> 1:33:17.380
 touch the same point in memory, right?

1:33:17.380 --> 1:33:21.260
 This is a huge like maddening problem to debug

1:33:21.260 --> 1:33:24.500
 because it's not reproducible generally.

1:33:24.500 --> 1:33:25.540
 And so there's tools,

1:33:25.540 --> 1:33:27.020
 there's a whole ecosystem of solutions

1:33:27.020 --> 1:33:28.300
 that built up around this,

1:33:28.300 --> 1:33:29.700
 but it's a huge problem

1:33:29.700 --> 1:33:31.060
 when you're writing concurrent code.

1:33:31.060 --> 1:33:33.100
 And so with Swift,

1:33:33.100 --> 1:33:35.460
 this whole value semantics thing is really powerful there

1:33:35.460 --> 1:33:39.060
 because it turns out that math and copies actually work

1:33:39.060 --> 1:33:40.700
 even in concurrent worlds.

1:33:40.700 --> 1:33:43.300
 And so you get a lot of safety just out of the box,

1:33:43.300 --> 1:33:44.620
 but there are also some hard problems.

1:33:44.620 --> 1:33:47.020
 And it talks about some of that.

1:33:47.020 --> 1:33:48.820
 When you start building up to the next level up

1:33:48.820 --> 1:33:50.540
 and you start talking beyond memory safety,

1:33:50.540 --> 1:33:53.020
 you have to talk about what is the programmer model?

1:33:53.020 --> 1:33:54.300
 How does a human think about this?

1:33:54.300 --> 1:33:56.820
 So a developer that's trying to build a program

1:33:56.820 --> 1:33:57.660
 think about this,

1:33:57.660 --> 1:34:01.060
 and it proposes a really old model with a new spin

1:34:01.060 --> 1:34:02.100
 called Actors.

1:34:02.100 --> 1:34:03.980
 Actors are about saying,

1:34:03.980 --> 1:34:08.180
 we have islands of single threadedness logically.

1:34:08.180 --> 1:34:09.380
 So you write something that feels like

1:34:09.380 --> 1:34:13.260
 it's one program running in a unit,

1:34:13.260 --> 1:34:16.740
 and then it communicates asynchronously with other things.

1:34:16.740 --> 1:34:19.860
 And so making that expressive and natural feel good

1:34:19.860 --> 1:34:22.420
 be the first thing you reach for and being safe by default

1:34:22.420 --> 1:34:25.620
 is a big part of the design of that proposal.

1:34:25.620 --> 1:34:26.740
 When you start going beyond that,

1:34:26.740 --> 1:34:27.740
 now you start to say, cool,

1:34:27.740 --> 1:34:30.140
 well, these things that communicate asynchronously,

1:34:30.140 --> 1:34:32.020
 they don't have to share memory.

1:34:32.020 --> 1:34:33.260
 Well, if they don't have to share memory

1:34:33.260 --> 1:34:35.100
 and they're sending messages to each other,

1:34:35.100 --> 1:34:37.100
 why do they have to be in the same process?

1:34:38.220 --> 1:34:40.500
 These things should be able to be in different processes

1:34:40.500 --> 1:34:41.740
 on your machine.

1:34:41.740 --> 1:34:43.060
 And why just processes?

1:34:43.060 --> 1:34:44.660
 Well, why not different machines?

1:34:44.660 --> 1:34:47.740
 And so now you have a very nice gradual transition

1:34:47.740 --> 1:34:49.780
 towards distributed programming.

1:34:49.780 --> 1:34:53.060
 And of course, when you start talking about the big future,

1:34:53.060 --> 1:34:55.020
 the manifesto doesn't go into it,

1:34:55.020 --> 1:35:00.020
 but accelerators are things you talk to asynchronously

1:35:00.180 --> 1:35:01.900
 by sending messages to them.

1:35:01.900 --> 1:35:03.900
 And how do you program those?

1:35:03.900 --> 1:35:05.820
 Well, that gets very interesting.

1:35:05.820 --> 1:35:07.580
 That's not in the proposal.

1:35:07.580 --> 1:35:12.500
 And how much do you wanna make that explicit

1:35:12.500 --> 1:35:14.700
 like the control of that whole process

1:35:14.700 --> 1:35:15.780
 explicit to the program?

1:35:15.780 --> 1:35:16.860
 Yeah, good question.

1:35:16.860 --> 1:35:20.540
 So when you're designing any of these kinds of features

1:35:20.540 --> 1:35:22.900
 or language features or even libraries,

1:35:22.900 --> 1:35:25.300
 you have this really hard trade off you have to make,

1:35:25.300 --> 1:35:27.420
 which is how much is it magic

1:35:27.420 --> 1:35:29.740
 or how much is it in the human's control?

1:35:29.740 --> 1:35:32.380
 How much can they predict and control it?

1:35:32.380 --> 1:35:36.260
 What do you do when the default case is the wrong case?

1:35:37.820 --> 1:35:39.820
 And so when you're designing a system,

1:35:39.820 --> 1:35:44.820
 and so when you're designing a system, I won't name names,

1:35:45.060 --> 1:35:50.060
 but there are systems where it's really easy to get started

1:35:50.980 --> 1:35:52.620
 and then you jump.

1:35:52.620 --> 1:35:54.100
 So let's pick like logo.

1:35:54.100 --> 1:35:55.580
 Okay, so something like this.

1:35:55.580 --> 1:35:57.140
 So it's really easy to get started.

1:35:57.140 --> 1:35:59.540
 It's really designed for teaching kids,

1:35:59.540 --> 1:36:02.060
 but as you get into it, you hit a ceiling

1:36:02.060 --> 1:36:03.180
 and then you can't go any higher.

1:36:03.180 --> 1:36:04.100
 And then what do you do?

1:36:04.100 --> 1:36:05.580
 Well, you have to go switch to a different world

1:36:05.580 --> 1:36:07.140
 and rewrite all your code.

1:36:07.140 --> 1:36:09.100
 And this logo is a silly example here.

1:36:09.100 --> 1:36:11.380
 This exists in many other languages.

1:36:11.380 --> 1:36:15.260
 With Python, you would say like concurrency, right?

1:36:15.260 --> 1:36:17.340
 So Python has the global interpreter block.

1:36:17.340 --> 1:36:19.460
 So threading is challenging in Python.

1:36:19.460 --> 1:36:22.620
 And so if you start writing a large scale application

1:36:22.620 --> 1:36:25.140
 in Python, and then suddenly you need concurrency,

1:36:25.140 --> 1:36:28.380
 you're kind of stuck with a series of bad trade offs, right?

1:36:30.420 --> 1:36:32.220
 There's other ways to go where you say like,

1:36:32.220 --> 1:36:37.020
 foist all the complexity on the user all at once, right?

1:36:37.020 --> 1:36:38.820
 And that's also bad in a different way.

1:36:38.820 --> 1:36:43.460
 And so what I prefer is building a simple model

1:36:43.460 --> 1:36:46.940
 that you can explain that then has an escape hatch.

1:36:46.940 --> 1:36:49.500
 So you get in, you have guardrails,

1:36:50.580 --> 1:36:52.100
 memory safety works like this in Swift,

1:36:52.100 --> 1:36:54.860
 where you can start with, like by default,

1:36:54.860 --> 1:36:57.140
 if you use all the standard things, it's memory safe,

1:36:57.140 --> 1:36:58.620
 you're not gonna shoot your foot off.

1:36:58.620 --> 1:37:02.300
 But if you wanna get a C level pointer to something,

1:37:02.300 --> 1:37:04.300
 you can explicitly do that.

1:37:04.300 --> 1:37:07.740
 But by default, there's guardrails.

1:37:07.740 --> 1:37:08.900
 There's guardrails.

1:37:08.900 --> 1:37:13.900
 Okay, so but like, whose job is it to figure out

1:37:14.300 --> 1:37:16.300
 which part of the code is parallelizable?

1:37:17.420 --> 1:37:21.020
 So in the case of the proposal, it is the human's job.

1:37:21.020 --> 1:37:24.220
 So they decide how to architect their application.

1:37:24.220 --> 1:37:28.180
 And then the runtime in the compiler is very predictable.

1:37:29.060 --> 1:37:31.860
 And so this is in contrast to like,

1:37:31.860 --> 1:37:34.180
 there's a long body of work, including on Fortran

1:37:34.180 --> 1:37:36.020
 for auto parallelizing compilers.

1:37:36.020 --> 1:37:39.540
 And this is an example of a bad thing in my,

1:37:39.540 --> 1:37:42.940
 so as a compiler person, I can drag on compiler people.

1:37:42.940 --> 1:37:45.100
 Often compiler people will say,

1:37:45.100 --> 1:37:46.740
 cool, since I can't change the code,

1:37:46.740 --> 1:37:48.500
 I'm gonna write my compiler that then takes

1:37:48.500 --> 1:37:52.060
 this unmodified code and makes go way faster on this machine.

1:37:52.060 --> 1:37:55.700
 Okay, application, and so it does pattern matching.

1:37:55.700 --> 1:37:57.780
 It does like really deep analysis.

1:37:57.780 --> 1:37:58.980
 Compiler people are really smart.

1:37:58.980 --> 1:38:00.820
 And so they like wanna like do something

1:38:00.820 --> 1:38:01.820
 really clever and tricky.

1:38:01.820 --> 1:38:04.500
 And you get like 10X speed up by taking

1:38:04.500 --> 1:38:06.540
 like an array of structures and turn it

1:38:06.540 --> 1:38:08.100
 into a structure of arrays or something,

1:38:08.100 --> 1:38:09.340
 because it's so much better for memory.

1:38:09.340 --> 1:38:11.780
 Like there's bodies, like tons of tricks.

1:38:12.660 --> 1:38:13.860
 They love optimization.

1:38:13.860 --> 1:38:14.980
 Yeah, you love optimization.

1:38:14.980 --> 1:38:15.820
 Everyone loves optimization.

1:38:15.820 --> 1:38:16.660
 Everyone loves it.

1:38:16.660 --> 1:38:19.100
 Well, and it's this promise of build with my compiler

1:38:19.100 --> 1:38:20.980
 and your thing goes fast, right?

1:38:20.980 --> 1:38:24.740
 But here's the problem, Lex, you write a program,

1:38:24.740 --> 1:38:26.580
 you run it with my compiler, it goes fast.

1:38:26.580 --> 1:38:27.420
 You're very happy.

1:38:27.420 --> 1:38:29.500
 Wow, it's so much faster than the other compiler.

1:38:29.500 --> 1:38:31.260
 Then you go and you add a feature to your program

1:38:31.260 --> 1:38:32.700
 or you refactor some code.

1:38:32.700 --> 1:38:35.740
 And suddenly you got a 10X loss in performance.

1:38:35.740 --> 1:38:36.580
 Well, why?

1:38:36.580 --> 1:38:37.580
 What just happened there?

1:38:37.580 --> 1:38:39.860
 What just happened there is the heuristic,

1:38:39.860 --> 1:38:41.980
 the pattern matching, the compiler,

1:38:41.980 --> 1:38:43.940
 whatever analysis it was doing just got defeated

1:38:43.940 --> 1:38:48.220
 because you didn't inline a function or something, right?

1:38:48.220 --> 1:38:50.260
 As a user, you don't know, you don't wanna know.

1:38:50.260 --> 1:38:51.100
 That was the whole point.

1:38:51.100 --> 1:38:52.820
 You don't wanna know how the compiler works.

1:38:52.820 --> 1:38:54.580
 You don't wanna know how the memory hierarchy works.

1:38:54.580 --> 1:38:56.060
 You don't wanna know how it got parallelized

1:38:56.060 --> 1:38:57.380
 across all these things.

1:38:57.380 --> 1:38:59.900
 You wanted that abstracted away from you,

1:38:59.900 --> 1:39:02.900
 but then the magic is lost as soon as you did something

1:39:02.900 --> 1:39:05.060
 and you fall off a performance cliff.

1:39:05.060 --> 1:39:06.700
 And now you're in this funny position

1:39:06.700 --> 1:39:08.060
 where what do I do?

1:39:08.060 --> 1:39:09.060
 I don't change my code.

1:39:09.060 --> 1:39:10.900
 I don't fix that bug.

1:39:10.900 --> 1:39:12.380
 It costs 10X performance.

1:39:12.380 --> 1:39:13.660
 Now what do I do?

1:39:13.660 --> 1:39:16.340
 Well, this is the problem with unpredictable performance.

1:39:16.340 --> 1:39:17.420
 If you care about performance,

1:39:17.420 --> 1:39:19.580
 predictability is a very important thing.

1:39:19.580 --> 1:39:23.900
 And so what the proposal does is it provides

1:39:23.900 --> 1:39:26.740
 architectural patterns for being able to lay out your code,

1:39:26.740 --> 1:39:28.420
 gives you full control over that,

1:39:28.420 --> 1:39:30.220
 makes it really simple so you can explain it.

1:39:30.220 --> 1:39:34.820
 And then if you wanna scale out in different ways,

1:39:34.820 --> 1:39:36.620
 you have full control over that.

1:39:36.620 --> 1:39:39.580
 So in your sense, the intuition is for a compiler,

1:39:39.580 --> 1:39:42.100
 it's too hard to do automated parallelization.

1:39:43.500 --> 1:39:47.660
 Cause the compilers do stuff automatically

1:39:47.660 --> 1:39:50.540
 that's incredibly impressive for other things,

1:39:50.540 --> 1:39:54.660
 but for parallelization, we're not close to there.

1:39:54.660 --> 1:39:56.300
 Well, it depends on the programming model.

1:39:56.300 --> 1:39:58.460
 So there's many different kinds of compilers.

1:39:58.460 --> 1:40:00.380
 And so if you talk about like a C compiler

1:40:00.380 --> 1:40:01.940
 or Swift compiler or something like that,

1:40:01.940 --> 1:40:04.980
 where you're writing imperative code,

1:40:04.980 --> 1:40:07.140
 parallelizing that and reasoning about all the pointers

1:40:07.140 --> 1:40:10.140
 and stuff like that is a very difficult problem.

1:40:10.140 --> 1:40:12.220
 Now, if you switch domains,

1:40:12.220 --> 1:40:15.540
 so there's this cool thing called machine learning, right?

1:40:15.540 --> 1:40:18.940
 So machine learning nerds among other endearing things

1:40:18.940 --> 1:40:22.060
 like solving cat detectors and other things like that

1:40:23.380 --> 1:40:25.420
 have done this amazing breakthrough

1:40:25.420 --> 1:40:27.540
 of producing a programming model,

1:40:27.540 --> 1:40:29.340
 operations that you compose together

1:40:30.260 --> 1:40:33.180
 that has raised levels of abstraction high enough

1:40:33.180 --> 1:40:36.780
 that suddenly you can have auto parallelizing compilers.

1:40:36.780 --> 1:40:39.620
 You can write a model using a TensorFlow

1:40:39.620 --> 1:40:43.460
 and have it run on 1024 nodes of a TPU.

1:40:43.460 --> 1:40:44.300
 Yeah, that's true.

1:40:44.300 --> 1:40:45.860
 I didn't even think about like,

1:40:46.860 --> 1:40:48.220
 cause there's so much flexibility

1:40:48.220 --> 1:40:50.860
 in the design of architectures that ultimately boil down

1:40:50.860 --> 1:40:54.180
 to a graph that's parallelized for you.

1:40:54.180 --> 1:40:56.660
 And if you think about it, that's pretty cool.

1:40:56.660 --> 1:40:57.660
 That's pretty cool, yeah.

1:40:57.660 --> 1:40:59.780
 And you think about batching, for example,

1:40:59.780 --> 1:41:02.460
 as a way of being able to exploit more parallelism.

1:41:02.460 --> 1:41:05.420
 Like that's a very simple thing that now is very powerful.

1:41:05.420 --> 1:41:08.020
 That didn't come out of the programming language nerds,

1:41:08.020 --> 1:41:10.140
 those people, like that came out of people

1:41:10.140 --> 1:41:11.460
 that are just looking to solve a problem

1:41:11.460 --> 1:41:14.060
 and use a few GPUs and organically developed

1:41:14.060 --> 1:41:16.860
 by the community of people focusing on machine learning.

1:41:16.860 --> 1:41:19.900
 And it's an incredibly powerful abstraction layer

1:41:19.900 --> 1:41:22.820
 that enables the compiler people to go and exploit that.

1:41:22.820 --> 1:41:26.420
 And now you can drive supercomputers from Python.

1:41:26.420 --> 1:41:27.580
 Well, that's pretty cool.

1:41:27.580 --> 1:41:28.420
 That's amazing.

1:41:28.420 --> 1:41:29.540
 So just to pause on that,

1:41:30.780 --> 1:41:32.340
 cause I'm not sufficiently low level,

1:41:32.340 --> 1:41:35.420
 I forget to admire the beauty and power of that,

1:41:35.420 --> 1:41:38.540
 but maybe just to linger on it,

1:41:38.540 --> 1:41:42.660
 like what does it take to run a neural network fast?

1:41:42.660 --> 1:41:44.100
 Like how hard is that compilation?

1:41:44.100 --> 1:41:45.700
 It's really hard.

1:41:45.700 --> 1:41:46.940
 So we just skipped,

1:41:46.940 --> 1:41:49.620
 you said like, it's amazing that that's a thing,

1:41:49.620 --> 1:41:51.540
 but yeah, how hard is that of a thing?

1:41:51.540 --> 1:41:55.380
 It's hard and I would say that not all of the systems

1:41:55.380 --> 1:41:58.620
 are really great, including the ones I helped build.

1:41:58.620 --> 1:42:00.740
 So there's a lot of work left to be done there.

1:42:00.740 --> 1:42:02.340
 Is it the compiler nerds working on that

1:42:02.340 --> 1:42:04.620
 or is it a whole new group of people?

1:42:04.620 --> 1:42:05.900
 Well, it's a full stack problem,

1:42:05.900 --> 1:42:09.180
 including compiler people, including APIs,

1:42:09.180 --> 1:42:14.180
 so like Keras and the module API and PyTorch and Jax.

1:42:14.660 --> 1:42:15.980
 And there's a bunch of people pushing

1:42:15.980 --> 1:42:17.460
 on all the different parts of these things,

1:42:17.460 --> 1:42:19.660
 because when you look at it as it's both,

1:42:19.660 --> 1:42:21.300
 how do I express the computation?

1:42:21.300 --> 1:42:22.900
 Do I stack up layers?

1:42:22.900 --> 1:42:25.620
 Well, cool, like setting up a linear sequence of layers

1:42:25.620 --> 1:42:26.780
 is great for the simple case,

1:42:26.780 --> 1:42:28.220
 but how do I do the hard case?

1:42:28.220 --> 1:42:29.500
 How do I do reinforcement learning?

1:42:29.500 --> 1:42:32.660
 Well, now I need to integrate my application logic in this.

1:42:32.660 --> 1:42:34.660
 Then it's the next level down of,

1:42:34.660 --> 1:42:36.700
 how do you represent that for the runtime?

1:42:36.700 --> 1:42:39.100
 How do you get hardware abstraction?

1:42:39.100 --> 1:42:40.780
 And then you get to the next level down of saying like,

1:42:40.780 --> 1:42:41.860
 forget about abstraction,

1:42:41.860 --> 1:42:44.540
 how do I get the peak performance out of my TPU

1:42:44.540 --> 1:42:47.620
 or my iPhone accelerator or whatever, right?

1:42:47.620 --> 1:42:48.940
 And all these different things.

1:42:48.940 --> 1:42:50.260
 And so this is a layered problem

1:42:50.260 --> 1:42:53.620
 with a lot of really interesting design and work

1:42:53.620 --> 1:42:54.540
 going on in the space

1:42:54.540 --> 1:42:56.940
 and a lot of really smart people working on it.

1:42:56.940 --> 1:42:59.460
 Machine learning is a very well funded area

1:42:59.460 --> 1:43:00.820
 of investment right now.

1:43:00.820 --> 1:43:02.940
 And so there's a lot of progress being made.

1:43:02.940 --> 1:43:05.900
 So how much innovation is there on the lower level,

1:43:05.900 --> 1:43:08.220
 so closer to the ASIC,

1:43:08.220 --> 1:43:09.780
 so redesigning the hardware

1:43:09.780 --> 1:43:13.180
 or redesigning concurrently compilers with that hardware?

1:43:13.180 --> 1:43:16.100
 Is that like, if you were to predict the biggest,

1:43:16.100 --> 1:43:20.540
 the equivalent of Moore's law improvements

1:43:20.540 --> 1:43:24.620
 in the inference and the training of neural networks

1:43:24.620 --> 1:43:25.700
 and just all of that,

1:43:25.700 --> 1:43:26.900
 where is that gonna come from, you think?

1:43:26.900 --> 1:43:28.900
 Sure, you get scalability of different things.

1:43:28.900 --> 1:43:33.620
 And so you get Jim Keller shrinking process technology,

1:43:33.620 --> 1:43:36.620
 you get three nanometer instead of five or seven or 10

1:43:36.620 --> 1:43:38.100
 or 28 or whatever.

1:43:38.100 --> 1:43:41.300
 And so that marches forward and that provides improvements.

1:43:41.300 --> 1:43:44.060
 You get architectural level performance.

1:43:44.060 --> 1:43:47.660
 And so the TPU with a matrix multiply unit

1:43:47.660 --> 1:43:49.620
 and a systolic array is much more efficient

1:43:49.620 --> 1:43:53.220
 than having a scalar core doing multiplies and adds

1:43:53.220 --> 1:43:54.380
 and things like that.

1:43:54.380 --> 1:43:58.620
 You then get system level improvements.

1:43:58.620 --> 1:43:59.860
 So how you talk to memory,

1:43:59.860 --> 1:44:02.340
 how you talk across a cluster of machines,

1:44:02.340 --> 1:44:03.300
 how you scale out,

1:44:03.300 --> 1:44:06.060
 how you have fast interconnects between machines.

1:44:06.060 --> 1:44:08.780
 You then get system level programming models.

1:44:08.780 --> 1:44:11.300
 So now that you have all this hardware, how to utilize it.

1:44:11.300 --> 1:44:13.140
 You then have algorithmic breakthroughs where you say,

1:44:13.140 --> 1:44:14.340
 hey, wow, cool.

1:44:14.340 --> 1:44:18.860
 Instead of training in a resonant 50 in a week,

1:44:18.860 --> 1:44:21.860
 I'm now training it in 25 seconds.

1:44:21.860 --> 1:44:26.860
 And it's a combination of new optimizers

1:44:26.940 --> 1:44:29.620
 and new just training regimens

1:44:29.620 --> 1:44:32.100
 and different approaches to train.

1:44:32.100 --> 1:44:33.980
 And all of these things come together

1:44:33.980 --> 1:44:36.020
 to push the world forward.

1:44:36.020 --> 1:44:39.980
 That was a beautiful exposition.

1:44:39.980 --> 1:44:42.740
 But if you were to force to bet all your money

1:44:42.740 --> 1:44:43.820
 on one of these.

1:44:45.220 --> 1:44:46.140
 Why do we have to?

1:44:48.780 --> 1:44:50.740
 Unfortunately, we have people working on all this.

1:44:50.740 --> 1:44:52.220
 It's an exciting time, right?

1:44:52.220 --> 1:44:56.140
 So, I mean, OpenAI did this little paper

1:44:56.140 --> 1:44:58.020
 showing the algorithmic improvement you can get.

1:44:58.020 --> 1:45:00.900
 It's been improving exponentially.

1:45:00.900 --> 1:45:04.220
 I haven't quite seen the same kind of analysis

1:45:04.220 --> 1:45:06.700
 on other layers of the stack.

1:45:06.700 --> 1:45:09.300
 I'm sure it's also improving significantly.

1:45:09.300 --> 1:45:12.300
 I just, it's a nice intuition builder.

1:45:12.300 --> 1:45:16.060
 I mean, there's a reason why Moore's Law,

1:45:16.060 --> 1:45:18.060
 that's the beauty of Moore's Law is

1:45:18.060 --> 1:45:21.380
 somebody writes a paper that makes a ridiculous prediction.

1:45:22.500 --> 1:45:27.100
 And it becomes reality in a sense.

1:45:27.100 --> 1:45:28.820
 There's something about these narratives

1:45:28.820 --> 1:45:33.540
 when you, when Chris Ladner on a silly little podcast

1:45:33.540 --> 1:45:37.180
 makes, bets all his money on a particular thing,

1:45:37.180 --> 1:45:39.220
 somehow it can have a ripple effect

1:45:39.220 --> 1:45:40.700
 of actually becoming real.

1:45:40.700 --> 1:45:43.220
 That's an interesting aspect of it.

1:45:43.220 --> 1:45:44.820
 Cause like it might've been,

1:45:45.980 --> 1:45:47.460
 we focus with Moore's Law,

1:45:47.460 --> 1:45:49.460
 most of the computing industry

1:45:49.460 --> 1:45:52.660
 really, really focused on the hardware.

1:45:53.500 --> 1:45:55.020
 I mean, software innovation,

1:45:55.020 --> 1:45:56.420
 I don't know how much software innovation

1:45:56.420 --> 1:45:57.260
 there was in terms of efficient.

1:45:57.260 --> 1:46:00.060
 What Intel Giveth Bill takes away, right?

1:46:00.060 --> 1:46:04.020
 Yeah, I mean, compilers improved significantly also.

1:46:04.020 --> 1:46:04.860
 Well, not really.

1:46:04.860 --> 1:46:06.780
 So actually, I mean, so I'm joking

1:46:06.780 --> 1:46:08.900
 about how software has gotten slower

1:46:08.900 --> 1:46:11.500
 pretty much as fast as hardware got better,

1:46:11.500 --> 1:46:13.140
 at least through the nineties.

1:46:13.140 --> 1:46:15.700
 There's another joke, another law in compilers,

1:46:15.700 --> 1:46:18.140
 which is called, I think it's called Probstine's Law,

1:46:18.140 --> 1:46:21.580
 which is compilers double the performance

1:46:21.580 --> 1:46:23.700
 of any given code every 18 years.

1:46:26.180 --> 1:46:27.860
 So they move slowly.

1:46:27.860 --> 1:46:28.700
 Yeah, also.

1:46:28.700 --> 1:46:30.940
 Well, yeah, it's exponential also.

1:46:30.940 --> 1:46:32.380
 Yeah, you're making progress,

1:46:32.380 --> 1:46:34.220
 but there again, it's not about,

1:46:35.540 --> 1:46:37.700
 the power of compilers is not just about

1:46:37.700 --> 1:46:39.060
 how do you make the same thing go faster?

1:46:39.060 --> 1:46:41.740
 It's how do you unlock the new hardware?

1:46:41.740 --> 1:46:43.500
 A new chip came out, how do you utilize it?

1:46:43.500 --> 1:46:45.140
 You say, oh, the programming model,

1:46:45.140 --> 1:46:46.980
 how do we make people more productive?

1:46:46.980 --> 1:46:51.940
 How do we have better error messages?

1:46:51.940 --> 1:46:55.460
 Even such mundane things like how do I generate

1:46:55.460 --> 1:46:58.260
 a very specific error message about your code

1:46:58.260 --> 1:46:59.780
 actually makes people happy

1:46:59.780 --> 1:47:01.860
 because then they know how to fix it, right?

1:47:01.860 --> 1:47:03.580
 And it comes back to how do you help people

1:47:03.580 --> 1:47:04.580
 get their job done.

1:47:04.580 --> 1:47:06.740
 Yeah, and yeah, and then in this world

1:47:06.740 --> 1:47:10.260
 of exponentially increasing smart toasters,

1:47:10.260 --> 1:47:15.260
 how do you expand computing to all these kinds of devices?

1:47:16.100 --> 1:47:18.420
 Do you see this world where just everything

1:47:18.420 --> 1:47:20.340
 is a computing surface?

1:47:20.340 --> 1:47:22.100
 You see that possibility?

1:47:22.100 --> 1:47:23.900
 Just everything is a computer?

1:47:23.900 --> 1:47:25.020
 Yeah, I don't see any reason

1:47:25.020 --> 1:47:26.940
 that that couldn't be achieved.

1:47:26.940 --> 1:47:30.380
 It turns out that sand goes into glass

1:47:30.380 --> 1:47:32.580
 and glass is pretty useful too.

1:47:32.580 --> 1:47:35.140
 And why not?

1:47:35.140 --> 1:47:35.980
 Why not?

1:47:35.980 --> 1:47:39.580
 So very important question then,

1:47:39.580 --> 1:47:44.580
 if we're living in a simulation

1:47:44.580 --> 1:47:47.420
 and the simulation is running a computer,

1:47:47.420 --> 1:47:50.660
 like what's the architecture of that computer, do you think?

1:47:51.900 --> 1:47:54.940
 So you're saying is it a quantum system?

1:47:54.940 --> 1:47:57.500
 Yeah, like this whole quantum discussion, is it needed?

1:47:57.500 --> 1:48:02.500
 Or can we run it with a RISC 5 architecture,

1:48:03.700 --> 1:48:05.260
 a bunch of CPUs?

1:48:05.260 --> 1:48:07.540
 I think it comes down to the right tool for the job.

1:48:07.540 --> 1:48:08.620
 Yeah, and so.

1:48:08.620 --> 1:48:10.100
 And what's the compiler?

1:48:10.100 --> 1:48:12.540
 Yeah, exactly, that's my question.

1:48:12.540 --> 1:48:13.660
 Did I get that job?

1:48:13.660 --> 1:48:15.020
 Feed the universe compiler.

1:48:16.740 --> 1:48:19.700
 And so there, as far as we know,

1:48:19.700 --> 1:48:23.660
 quantum systems are the bottom of the pile of turtles

1:48:23.660 --> 1:48:24.500
 so far.

1:48:24.500 --> 1:48:25.460
 Yeah.

1:48:25.460 --> 1:48:28.260
 And so we don't know efficient ways

1:48:28.260 --> 1:48:31.140
 to implement quantum systems without using quantum computers.

1:48:32.180 --> 1:48:33.540
 Yeah, and that's totally outside

1:48:33.540 --> 1:48:35.060
 of everything we've talked about.

1:48:35.060 --> 1:48:37.060
 But who runs that quantum computer?

1:48:37.060 --> 1:48:37.900
 Yeah.

1:48:37.900 --> 1:48:41.460
 Right, so if we really are living in a simulation,

1:48:41.460 --> 1:48:44.420
 then is it bigger quantum computers?

1:48:44.420 --> 1:48:45.260
 Is it different ones?

1:48:45.260 --> 1:48:46.580
 Like how does that work out?

1:48:46.580 --> 1:48:47.700
 How does that scale?

1:48:47.700 --> 1:48:49.940
 Well, it's the same size.

1:48:49.940 --> 1:48:50.780
 It's the same size.

1:48:50.780 --> 1:48:52.660
 But then the thought of the simulation

1:48:52.660 --> 1:48:54.260
 is that you don't have to run the whole thing,

1:48:54.260 --> 1:48:56.860
 that we humans are cognitively very limited.

1:48:56.860 --> 1:48:57.700
 We do checkpoints.

1:48:57.700 --> 1:48:59.420
 We do checkpoints, yeah.

1:48:59.420 --> 1:49:03.020
 And if we, the point at which we human,

1:49:03.020 --> 1:49:06.860
 so you basically do minimal amount of,

1:49:06.860 --> 1:49:11.860
 what is it, Swift does on right, copy on right.

1:49:12.220 --> 1:49:15.540
 So you only adjust the simulation.

1:49:15.540 --> 1:49:17.060
 Parallel universe theories, right?

1:49:17.060 --> 1:49:20.580
 And so every time a decision's made,

1:49:20.580 --> 1:49:22.060
 somebody opens the short end of your box,

1:49:22.060 --> 1:49:23.740
 then there's a fork.

1:49:23.740 --> 1:49:24.980
 And then this could happen.

1:49:24.980 --> 1:49:29.980
 And then, thank you for considering the possibility.

1:49:29.980 --> 1:49:32.900
 But yeah, so it may not require the entirety

1:49:32.900 --> 1:49:34.260
 of the universe to simulate it.

1:49:34.260 --> 1:49:38.460
 But it's interesting to think about

1:49:38.460 --> 1:49:42.940
 as we create this higher and higher fidelity systems.

1:49:42.940 --> 1:49:46.180
 But I do wanna ask on the quantum computer side,

1:49:46.180 --> 1:49:47.900
 because everything we've talked about,

1:49:47.900 --> 1:49:51.660
 whether you work with SciFive, with compilers,

1:49:51.660 --> 1:49:54.660
 none of that includes quantum computers, right?

1:49:54.660 --> 1:49:55.660
 That's true.

1:49:55.660 --> 1:50:00.660
 So have you ever thought about this whole

1:50:03.140 --> 1:50:06.180
 serious engineering work of quantum computers

1:50:06.180 --> 1:50:09.740
 looks like of compilers, of architectures,

1:50:09.740 --> 1:50:10.660
 all of that kind of stuff?

1:50:10.660 --> 1:50:11.820
 So I've looked at it a little bit.

1:50:11.820 --> 1:50:14.300
 I know almost nothing about it,

1:50:14.300 --> 1:50:15.540
 which means that at some point,

1:50:15.540 --> 1:50:17.860
 I will have to find an excuse to get involved,

1:50:17.860 --> 1:50:18.700
 because that's how it works.

1:50:18.700 --> 1:50:21.140
 But do you think that's a thing to be,

1:50:21.140 --> 1:50:24.620
 like with your little tingly senses of the timing

1:50:24.620 --> 1:50:26.860
 of when to be involved, is it not yet?

1:50:26.860 --> 1:50:28.820
 Well, so the thing I do really well

1:50:28.820 --> 1:50:31.660
 is I jump into messy systems

1:50:31.660 --> 1:50:33.700
 and figure out how to make them,

1:50:33.700 --> 1:50:35.540
 figure out what the truth in the situation is,

1:50:35.540 --> 1:50:39.100
 try to figure out what the unifying theory is,

1:50:39.100 --> 1:50:40.980
 how to like factor the complexity,

1:50:40.980 --> 1:50:42.860
 how to find a beautiful answer to a problem

1:50:42.860 --> 1:50:44.860
 that has been well studied

1:50:44.860 --> 1:50:47.060
 and lots of people have bashed their heads against it.

1:50:47.060 --> 1:50:49.300
 I don't know that quantum computers are mature enough

1:50:49.300 --> 1:50:53.740
 and accessible enough to be figured out yet, right?

1:50:53.740 --> 1:50:58.620
 And I think the open question with quantum computers is,

1:50:58.620 --> 1:51:00.180
 is there a useful problem

1:51:00.180 --> 1:51:02.340
 that gets solved with a quantum computer

1:51:02.340 --> 1:51:05.300
 that makes it worth the economic cost

1:51:05.300 --> 1:51:06.780
 of like having one of these things

1:51:06.780 --> 1:51:11.500
 and having legions of people that set it up?

1:51:11.500 --> 1:51:12.780
 You go back to the fifties, right?

1:51:12.780 --> 1:51:13.740
 And there's the projections

1:51:13.740 --> 1:51:18.220
 of the world will only need seven computers, right?

1:51:18.220 --> 1:51:20.740
 Well, and part of that was that people hadn't figured out

1:51:20.740 --> 1:51:21.980
 what they're useful for.

1:51:21.980 --> 1:51:23.260
 What are the algorithms we wanna run?

1:51:23.260 --> 1:51:24.340
 What are the problems that get solved?

1:51:24.340 --> 1:51:27.620
 And this comes back to how do we make the world better,

1:51:27.620 --> 1:51:29.940
 either economically or making somebody's life better

1:51:29.940 --> 1:51:31.940
 or like solving a problem that wasn't solved before,

1:51:31.940 --> 1:51:33.140
 things like this.

1:51:33.140 --> 1:51:36.020
 And I think that just we're a little bit too early

1:51:36.020 --> 1:51:36.860
 in that development cycle

1:51:36.860 --> 1:51:39.380
 because it's still like literally a science project,

1:51:39.380 --> 1:51:41.540
 not a negative connotation, right?

1:51:41.540 --> 1:51:42.860
 It's literally a science project

1:51:42.860 --> 1:51:45.420
 and the progress there is amazing.

1:51:45.420 --> 1:51:48.900
 And so I don't know if it's 10 years away,

1:51:48.900 --> 1:51:50.100
 if it's two years away,

1:51:50.100 --> 1:51:51.660
 exactly where that breakthrough happens,

1:51:51.660 --> 1:51:54.540
 but you look at machine learning,

1:51:56.300 --> 1:51:58.420
 we went through a few winners

1:51:58.420 --> 1:52:00.140
 before the AlexNet transition

1:52:00.140 --> 1:52:02.980
 and then suddenly it had its breakout moment.

1:52:02.980 --> 1:52:04.300
 And that was the catalyst

1:52:04.300 --> 1:52:07.580
 that then drove the talent flocking into it.

1:52:07.580 --> 1:52:10.180
 That's what drove the economic applications of it.

1:52:10.180 --> 1:52:13.420
 That's what drove the technology to go faster

1:52:13.420 --> 1:52:15.940
 because you now have more minds thrown at the problem.

1:52:15.940 --> 1:52:20.180
 This is what caused like a serious knee in deep learning

1:52:20.180 --> 1:52:21.940
 and the algorithms that we're using.

1:52:21.940 --> 1:52:25.540
 And so I think that's what quantum needs to go through.

1:52:25.540 --> 1:52:28.820
 And so right now it's in that formidable finding itself,

1:52:28.820 --> 1:52:32.980
 getting the like literally the physics figured out.

1:52:32.980 --> 1:52:36.100
 And then it has to figure out the application

1:52:36.100 --> 1:52:37.580
 that makes this useful.

1:52:37.580 --> 1:52:40.780
 Yeah, but I'm not skeptical that I think that will happen.

1:52:40.780 --> 1:52:43.420
 I think it's just 10 years away, something like that.

1:52:43.420 --> 1:52:44.500
 I forgot to ask,

1:52:44.500 --> 1:52:46.380
 what programming language do you think

1:52:46.380 --> 1:52:48.620
 the simulation is written in?

1:52:48.620 --> 1:52:50.340
 Ooh, probably Lisp.

1:52:50.340 --> 1:52:52.980
 So not Swift.

1:52:52.980 --> 1:52:57.980
 Like if you're a Tibet, I'll just leave it at that.

1:52:58.060 --> 1:53:00.380
 So, I mean, we've mentioned that you worked

1:53:00.380 --> 1:53:01.220
 with all these companies,

1:53:01.220 --> 1:53:03.900
 we've talked about all these projects.

1:53:03.900 --> 1:53:07.220
 It's kind of like if we just step back and zoom out

1:53:07.220 --> 1:53:10.100
 about the way you did that work.

1:53:10.100 --> 1:53:12.220
 And we look at COVID times,

1:53:12.220 --> 1:53:14.780
 this pandemic we're living through that may,

1:53:14.780 --> 1:53:17.020
 if I look at the way Silicon Valley folks

1:53:17.020 --> 1:53:19.860
 are talking about it, the way MIT is talking about it,

1:53:19.860 --> 1:53:23.060
 this might last for a long time.

1:53:23.060 --> 1:53:28.060
 Not just the virus, but the remote nature.

1:53:28.340 --> 1:53:29.660
 The economic impact.

1:53:29.660 --> 1:53:30.500
 I mean, all of it, yeah.

1:53:30.500 --> 1:53:32.140
 Yeah, it's gonna be a mess.

1:53:32.140 --> 1:53:34.500
 Do you think, what's your prediction?

1:53:34.500 --> 1:53:36.380
 I mean, from sci fi to Google,

1:53:36.380 --> 1:53:41.380
 to just all the places you worked in,

1:53:42.420 --> 1:53:44.260
 just Silicon Valley, you're in the middle of it.

1:53:44.260 --> 1:53:45.100
 What do you think is,

1:53:45.100 --> 1:53:46.620
 how is this whole place gonna change?

1:53:46.620 --> 1:53:49.020
 Yeah, so, I mean, I really can only speak

1:53:49.020 --> 1:53:50.460
 to the tech perspective.

1:53:50.460 --> 1:53:52.820
 I am in that bubble.

1:53:54.140 --> 1:53:55.700
 I think it's gonna be really interesting

1:53:55.700 --> 1:53:58.820
 because the Zoom culture of being remote

1:53:58.820 --> 1:54:00.260
 and on video chat all the time

1:54:00.260 --> 1:54:01.980
 has really interesting effects on people.

1:54:01.980 --> 1:54:05.020
 So on the one hand, it's a great normalizer.

1:54:05.020 --> 1:54:09.060
 It's a normalizer that I think will help communities

1:54:09.060 --> 1:54:12.580
 of people that have traditionally been underrepresented

1:54:12.580 --> 1:54:16.380
 because now you're taking, in some cases, a face off

1:54:16.380 --> 1:54:18.780
 because you don't have to have a camera going, right?

1:54:18.780 --> 1:54:20.020
 And so you can have conversations

1:54:20.020 --> 1:54:22.780
 without physical appearance being part of the dynamic,

1:54:22.780 --> 1:54:24.500
 which is pretty powerful.

1:54:24.500 --> 1:54:25.940
 You're taking remote employees

1:54:25.940 --> 1:54:27.020
 that have already been remote,

1:54:27.020 --> 1:54:29.900
 and you're saying you're now on the same level

1:54:29.900 --> 1:54:31.380
 and footing as everybody else.

1:54:31.380 --> 1:54:33.460
 Nobody gets whiteboards.

1:54:33.460 --> 1:54:34.620
 You're not gonna be the one person

1:54:34.620 --> 1:54:36.020
 that doesn't get to be participating

1:54:36.020 --> 1:54:37.220
 in the whiteboard conversation,

1:54:37.220 --> 1:54:39.300
 and that's pretty powerful.

1:54:39.300 --> 1:54:44.140
 You've got, you're forcing people to think asynchronously

1:54:44.140 --> 1:54:47.220
 in some cases because it's harder to just get people

1:54:47.220 --> 1:54:49.380
 physically together, and the bumping into each other

1:54:49.380 --> 1:54:52.740
 forces people to find new ways to solve those problems.

1:54:52.740 --> 1:54:55.220
 And I think that that leads to more inclusive behavior,

1:54:55.220 --> 1:54:56.780
 which is good.

1:54:56.780 --> 1:55:00.740
 On the other hand, it's also, it just sucks, right?

1:55:00.740 --> 1:55:05.740
 And so the actual communication just sucks

1:55:05.940 --> 1:55:09.820
 being not with people on a daily basis

1:55:09.820 --> 1:55:11.380
 and collaborating with them.

1:55:11.380 --> 1:55:13.060
 Yeah, all of that, right?

1:55:13.060 --> 1:55:15.660
 I mean, everything, this whole situation is terrible.

1:55:15.660 --> 1:55:17.620
 What I meant primarily was the,

1:55:19.060 --> 1:55:20.860
 I think that most humans

1:55:20.860 --> 1:55:22.980
 like working physically with humans.

1:55:22.980 --> 1:55:24.660
 I think this is something that not everybody,

1:55:24.660 --> 1:55:27.100
 but many people are programmed to do.

1:55:27.100 --> 1:55:29.220
 And I think that we get something out of that

1:55:29.220 --> 1:55:31.460
 that is very hard to express, at least for me.

1:55:31.460 --> 1:55:33.180
 And so maybe this isn't true of everybody.

1:55:33.180 --> 1:55:36.860
 But, and so the question to me is,

1:55:36.860 --> 1:55:40.020
 when you get through that time of adaptation,

1:55:40.020 --> 1:55:41.940
 you get out of March and April,

1:55:41.940 --> 1:55:43.220
 and you get into December,

1:55:43.220 --> 1:55:46.580
 you get into next March, if it's not changed, right?

1:55:46.580 --> 1:55:47.820
 It's already terrifying.

1:55:47.820 --> 1:55:49.140
 Well, you think about that,

1:55:49.140 --> 1:55:51.420
 and you think about what is the nature of work?

1:55:51.420 --> 1:55:52.740
 And how do we adapt?

1:55:52.740 --> 1:55:55.100
 And humans are very adaptable species, right?

1:55:55.100 --> 1:55:58.260
 We can learn things when we're forced to,

1:55:58.260 --> 1:56:00.580
 and there's a catalyst to make that happen.

1:56:00.580 --> 1:56:02.700
 And so what is it that comes out of this,

1:56:02.700 --> 1:56:04.740
 and are we better or worse off?

1:56:04.740 --> 1:56:07.180
 I think that you look at the Bay Area,

1:56:07.180 --> 1:56:08.940
 housing prices are insane.

1:56:08.940 --> 1:56:09.900
 Well, why?

1:56:09.900 --> 1:56:12.460
 Well, there's a high incentive to be physically located,

1:56:12.460 --> 1:56:14.980
 because if you don't have proximity,

1:56:14.980 --> 1:56:18.420
 you end up paying for it and commute, right?

1:56:18.420 --> 1:56:21.060
 And there has been huge social pressure

1:56:21.060 --> 1:56:24.660
 in terms of you will be there for the meeting, right?

1:56:24.660 --> 1:56:26.940
 Or whatever scenario it is.

1:56:26.940 --> 1:56:28.260
 And I think that's gonna be way better.

1:56:28.260 --> 1:56:30.020
 I think it's gonna be much more the norm

1:56:30.020 --> 1:56:31.660
 to have remote employees,

1:56:31.660 --> 1:56:33.260
 and I think this is gonna be really great.

1:56:33.260 --> 1:56:37.260
 Do you have friends, or do you hear of people moving?

1:56:37.260 --> 1:56:40.780
 I know one family friend that moved.

1:56:40.780 --> 1:56:41.980
 They moved back to Michigan,

1:56:41.980 --> 1:56:45.620
 and they were a family with three kids

1:56:45.620 --> 1:56:46.820
 living in a small apartment,

1:56:46.820 --> 1:56:50.820
 and we're going insane, right?

1:56:50.820 --> 1:56:54.300
 And they're in tech, husband works for Google.

1:56:54.300 --> 1:56:56.140
 So first of all, friends of mine

1:56:57.140 --> 1:57:00.580
 are in the process of, or have already lost the business.

1:57:00.580 --> 1:57:03.220
 The thing that represents their passion, their dream,

1:57:03.220 --> 1:57:05.340
 it could be small entrepreneurial projects,

1:57:05.340 --> 1:57:06.820
 but it could be large businesses,

1:57:06.820 --> 1:57:08.500
 like people that run gyms.

1:57:08.500 --> 1:57:10.860
 Restaurants, tons of things, yeah.

1:57:10.860 --> 1:57:14.180
 But also, people look at themselves in the mirror

1:57:14.180 --> 1:57:17.660
 and ask the question of, what do I wanna do in life?

1:57:17.660 --> 1:57:20.980
 For some reason, they haven't done it until COVID.

1:57:20.980 --> 1:57:22.100
 They really ask that question,

1:57:22.100 --> 1:57:26.660
 and that results often in moving or leaving the company

1:57:26.660 --> 1:57:28.140
 with starting your own business

1:57:28.140 --> 1:57:30.660
 or transitioning to a different company.

1:57:30.660 --> 1:57:33.620
 Do you think we're gonna see that a lot?

1:57:33.620 --> 1:57:36.220
 Well, I can't speak to that.

1:57:36.220 --> 1:57:37.300
 I mean, we're definitely gonna see it

1:57:37.300 --> 1:57:39.380
 at a higher frequency than we did before,

1:57:39.380 --> 1:57:41.580
 just because I think what you're trying to say

1:57:41.580 --> 1:57:45.220
 is there are decisions that you make yourself,

1:57:45.220 --> 1:57:47.260
 big life decisions that you make yourself,

1:57:47.260 --> 1:57:49.860
 and I'm gonna quit my job and start a new thing.

1:57:49.860 --> 1:57:52.740
 There's also decisions that get made for you.

1:57:52.740 --> 1:57:55.420
 I got fired from my job, what am I gonna do, right?

1:57:55.420 --> 1:57:58.060
 And that's not a decision that you think about,

1:57:58.060 --> 1:58:00.340
 but you're forced to act, okay?

1:58:00.340 --> 1:58:02.900
 And so I think that those, you're forced to act

1:58:02.900 --> 1:58:05.300
 kind of moments where global pandemic

1:58:05.300 --> 1:58:06.660
 comes and wipes out the economy,

1:58:06.660 --> 1:58:09.900
 and now your business doesn't exist.

1:58:09.900 --> 1:58:11.820
 I think that does lead to more reflection, right?

1:58:11.820 --> 1:58:14.460
 Because you're less anchored on what you have,

1:58:14.460 --> 1:58:17.060
 and it's not a, what do I have to lose

1:58:17.060 --> 1:58:19.980
 versus what do I have to gain, A, B, comparison.

1:58:19.980 --> 1:58:21.940
 It's more of a fresh slate.

1:58:21.940 --> 1:58:23.900
 Cool, I could do anything now.

1:58:23.900 --> 1:58:26.380
 Do I wanna do the same thing I was doing?

1:58:26.380 --> 1:58:27.820
 Did that make me happy?

1:58:27.820 --> 1:58:29.500
 Is this now time to go back to college

1:58:29.500 --> 1:58:33.100
 and take a class and learn a new skill?

1:58:33.100 --> 1:58:36.580
 Is this a time to spend time with family

1:58:36.580 --> 1:58:37.820
 if you can afford to do that?

1:58:37.820 --> 1:58:40.980
 Is this time to literally move in with parents, right?

1:58:40.980 --> 1:58:43.900
 I mean, all these things that were not normative before

1:58:43.900 --> 1:58:48.900
 suddenly become, I think, very, the value systems change.

1:58:49.140 --> 1:58:50.820
 And I think that's actually a good thing

1:58:50.820 --> 1:58:55.280
 in the short term, at least, because it leads to,

1:58:56.340 --> 1:58:58.420
 there's kind of been an overoptimization

1:58:58.420 --> 1:59:01.540
 along one set of priorities for the world,

1:59:01.540 --> 1:59:03.540
 and now maybe we'll get to a more balanced

1:59:03.540 --> 1:59:05.180
 and more interesting world

1:59:05.180 --> 1:59:06.780
 where people are doing different things.

1:59:06.780 --> 1:59:07.660
 I think it could be good.

1:59:07.660 --> 1:59:08.980
 I think there could be more innovation

1:59:08.980 --> 1:59:10.100
 that comes out of it, for example.

1:59:10.100 --> 1:59:12.780
 What do you think about all the social chaos

1:59:12.780 --> 1:59:13.980
 we're in the middle of?

1:59:13.980 --> 1:59:14.820
 It sucks.

1:59:14.820 --> 1:59:18.740
 You think it's, let me ask you a whole,

1:59:18.740 --> 1:59:21.100
 you think it's all gonna be okay?

1:59:21.100 --> 1:59:23.420
 Well, I think humanity will survive.

1:59:23.420 --> 1:59:25.420
 The, from an existential,

1:59:25.420 --> 1:59:27.260
 like we're not all gonna kill, yeah, well.

1:59:27.260 --> 1:59:30.380
 Yeah, I don't think the virus is gonna kill all the humans.

1:59:30.380 --> 1:59:31.980
 I don't think all the humans are gonna kill all the humans.

1:59:31.980 --> 1:59:32.900
 I think that's unlikely.

1:59:32.900 --> 1:59:37.900
 But I look at it as progress requires a catalyst, right?

1:59:42.460 --> 1:59:45.580
 So you need a reason for people to be willing

1:59:45.580 --> 1:59:47.740
 to do things that are uncomfortable.

1:59:47.740 --> 1:59:50.740
 I think that the US, at least,

1:59:50.740 --> 1:59:51.740
 but I think the world in general

1:59:51.740 --> 1:59:56.780
 is a pretty unoptimal place to live in for a lot of people.

1:59:56.780 --> 1:59:58.900
 And I think that what we're seeing right now

1:59:58.900 --> 2:00:00.460
 is we're seeing a lot of unhappiness.

2:00:00.460 --> 2:00:03.580
 And because of all the pressure,

2:00:03.580 --> 2:00:05.500
 because of all the badness in the world

2:00:05.500 --> 2:00:06.340
 that's coming together,

2:00:06.340 --> 2:00:07.860
 it's really kind of igniting some of that debate

2:00:07.860 --> 2:00:10.140
 that should have happened a long time ago, right?

2:00:10.140 --> 2:00:11.620
 I mean, I think that we'll see more progress.

2:00:11.620 --> 2:00:14.220
 You're asking about, offline you're asking about politics

2:00:14.220 --> 2:00:15.740
 and wouldn't it be great if politics moved faster

2:00:15.740 --> 2:00:16.940
 because there's all these problems in the world

2:00:16.940 --> 2:00:18.140
 and we can move it.

2:00:18.140 --> 2:00:22.300
 Well, people are intentionally, are inherently conservative.

2:00:22.300 --> 2:00:25.020
 And so if you're talking about conservative people,

2:00:25.020 --> 2:00:27.460
 particularly if they have heavy burdens on their shoulders

2:00:27.460 --> 2:00:30.060
 because they represent literally thousands of people,

2:00:31.700 --> 2:00:33.220
 it makes sense to be conservative.

2:00:33.220 --> 2:00:35.300
 But on the other hand, when you need change,

2:00:35.300 --> 2:00:36.220
 how do you get it?

2:00:37.140 --> 2:00:40.500
 The global pandemic will probably lead to some change.

2:00:40.500 --> 2:00:44.300
 And it's not a directed, it's not a directed plan,

2:00:44.300 --> 2:00:45.900
 but I think that it leads to people

2:00:45.900 --> 2:00:47.340
 asking really interesting questions.

2:00:47.340 --> 2:00:48.180
 And some of those questions

2:00:48.180 --> 2:00:50.100
 should have been asked a long time ago.

2:00:50.100 --> 2:00:53.260
 Well, let me know if you've observed this as well.

2:00:53.260 --> 2:00:55.620
 Something that's bothered me in the machine learning

2:00:55.620 --> 2:00:58.260
 community, I'm guessing it might be prevalent

2:00:58.260 --> 2:01:02.500
 in other places, is something that feels like in 2020

2:01:02.500 --> 2:01:05.260
 increase the level of toxicity.

2:01:05.260 --> 2:01:09.700
 Like people are just quicker to pile on,

2:01:09.700 --> 2:01:13.260
 to just be, they're just harsh on each other,

2:01:13.260 --> 2:01:18.260
 to like mob, pick a person that screwed up

2:01:19.300 --> 2:01:22.020
 and like make it a big thing.

2:01:22.020 --> 2:01:25.460
 And is there something that we can like,

2:01:26.340 --> 2:01:28.180
 yeah, have you observed that in other places?

2:01:28.180 --> 2:01:30.180
 Is there some way out of this?

2:01:30.180 --> 2:01:32.140
 I think there's an inherent thing in humanity

2:01:32.140 --> 2:01:34.420
 that's kind of an us versus them thing,

2:01:34.420 --> 2:01:37.100
 which is that you wanna succeed and how do you succeed?

2:01:37.100 --> 2:01:39.580
 Well, it's relative to somebody else.

2:01:39.580 --> 2:01:43.100
 And so what's happening in, at least in some part

2:01:43.100 --> 2:01:47.100
 is that with the internet and with online communication,

2:01:47.100 --> 2:01:49.580
 the world's getting smaller, right?

2:01:49.580 --> 2:01:53.020
 And so we're having some of the social ties

2:01:53.020 --> 2:01:57.540
 of like my town versus your town's football team, right?

2:01:57.540 --> 2:02:02.540
 Turn into much larger and yet shallower problems.

2:02:02.980 --> 2:02:06.580
 And people don't have time, the incentives,

2:02:06.580 --> 2:02:08.060
 the clickbait and like all these things

2:02:08.060 --> 2:02:10.500
 kind of really feed into this machine.

2:02:10.500 --> 2:02:12.460
 And I don't know where that goes.

2:02:12.460 --> 2:02:15.060
 Yeah, I mean, the reason I think about that,

2:02:15.060 --> 2:02:17.500
 I mentioned to you this offline a little bit,

2:02:17.500 --> 2:02:22.500
 but I have a few difficult conversations scheduled,

2:02:23.060 --> 2:02:25.100
 some of them political related,

2:02:25.100 --> 2:02:27.340
 some of them within the community,

2:02:28.180 --> 2:02:30.620
 difficult personalities that went through some stuff.

2:02:30.620 --> 2:02:32.140
 I mean, one of them I've talked before,

2:02:32.140 --> 2:02:34.340
 I will talk again is Yann LeCun.

2:02:34.340 --> 2:02:36.380
 He got a little bit of crap on Twitter

2:02:38.380 --> 2:02:40.940
 for talking about a particular paper

2:02:40.940 --> 2:02:42.740
 and the bias within a data set.

2:02:42.740 --> 2:02:45.940
 And then there's been a huge, in my view,

2:02:45.940 --> 2:02:49.700
 and I'm willing, comfortable saying it,

2:02:49.700 --> 2:02:54.380
 irrational, over exaggerated pile on his comments

2:02:54.380 --> 2:02:58.460
 because he made pretty basic comments about the fact that

2:02:58.460 --> 2:02:59.860
 if there's bias in the data,

2:02:59.860 --> 2:03:02.380
 there's going to be bias in the results.

2:03:02.380 --> 2:03:04.540
 So we should not have bias in the data,

2:03:04.540 --> 2:03:07.300
 but people piled on to him because he said

2:03:07.300 --> 2:03:10.020
 he trivialized the problem of bias.

2:03:10.020 --> 2:03:13.180
 Like it's a lot more than just bias in the data,

2:03:13.180 --> 2:03:16.500
 but like, yes, that's a very good point,

2:03:16.500 --> 2:03:18.900
 but that's not what he was saying.

2:03:18.900 --> 2:03:19.740
 That's not what he was saying.

2:03:19.740 --> 2:03:23.100
 And the response, like the implied response

2:03:23.100 --> 2:03:26.660
 that he's basically sexist and racist

2:03:27.620 --> 2:03:30.420
 is something that completely drives away

2:03:30.420 --> 2:03:32.860
 the possibility of nuanced discussion.

2:03:32.860 --> 2:03:37.860
 One nice thing about like a pocket long form of conversation

2:03:37.940 --> 2:03:40.300
 is you can talk it out.

2:03:40.300 --> 2:03:42.860
 You can lay your reasoning out.

2:03:42.860 --> 2:03:44.500
 And even if you're wrong,

2:03:44.500 --> 2:03:47.140
 you can still show that you're a good human being

2:03:47.140 --> 2:03:48.220
 underneath it.

2:03:48.220 --> 2:03:49.100
 You know, your point about

2:03:49.100 --> 2:03:50.980
 you can't have a productive discussion.

2:03:50.980 --> 2:03:53.860
 Well, how do you get to the point where people can turn?

2:03:53.860 --> 2:03:56.260
 They can learn, they can listen, they can think,

2:03:56.260 --> 2:04:00.660
 they can engage versus just being a shallow like,

2:04:00.660 --> 2:04:02.500
 and then keep moving, right?

2:04:02.500 --> 2:04:06.620
 And I don't think that progress really comes from that,

2:04:06.620 --> 2:04:07.460
 right?

2:04:07.460 --> 2:04:09.820
 And I don't think that one should expect that.

2:04:09.820 --> 2:04:12.260
 I think that you'd see that as reinforcing

2:04:12.260 --> 2:04:14.460
 individual circles and the us versus them thing.

2:04:14.460 --> 2:04:17.500
 And I think that's fairly divisive.

2:04:17.500 --> 2:04:20.900
 Yeah, I think there's a big role in,

2:04:20.900 --> 2:04:24.020
 like the people that bother me most on Twitter

2:04:24.020 --> 2:04:26.580
 when I observe things is not the people

2:04:26.580 --> 2:04:30.060
 who get very emotional, angry, like over the top.

2:04:30.060 --> 2:04:33.820
 It's the people who like prop them up.

2:04:33.820 --> 2:04:36.100
 It's all the, it's this,

2:04:36.100 --> 2:04:37.940
 I think what should be the,

2:04:37.940 --> 2:04:42.300
 we should teach each other is to be sort of empathetic.

2:04:42.300 --> 2:04:44.660
 The thing that it's really easy to forget,

2:04:44.660 --> 2:04:47.740
 particularly on like Twitter or the internet or an email,

2:04:47.740 --> 2:04:50.740
 is that sometimes people just have a bad day, right?

2:04:50.740 --> 2:04:53.100
 You have a bad day or you're like,

2:04:53.100 --> 2:04:55.500
 I've been in the situation where it's like between meetings,

2:04:55.500 --> 2:04:57.260
 like fire off a quick response to an email

2:04:57.260 --> 2:05:00.660
 because I want to like help get something unblocked,

2:05:00.660 --> 2:05:03.620
 phrase it really objectively wrong.

2:05:03.620 --> 2:05:04.980
 I screwed up.

2:05:04.980 --> 2:05:08.660
 And suddenly this is now something that sticks with people.

2:05:08.660 --> 2:05:10.540
 And it's not because they're bad.

2:05:10.540 --> 2:05:11.820
 It's not because you're bad.

2:05:11.820 --> 2:05:15.180
 Just psychology of like, you said a thing,

2:05:15.180 --> 2:05:16.020
 it sticks with you.

2:05:16.020 --> 2:05:16.940
 You didn't mean it that way,

2:05:16.940 --> 2:05:18.460
 but it really impacted somebody

2:05:18.460 --> 2:05:20.860
 because the way they interpret it.

2:05:20.860 --> 2:05:23.340
 And this is just an aspect of working together as humans.

2:05:23.340 --> 2:05:26.140
 And I have a lot of optimism in the long term,

2:05:26.140 --> 2:05:29.060
 the very long term about what we as humanity can do.

2:05:29.060 --> 2:05:29.980
 But I think that's going to be,

2:05:29.980 --> 2:05:31.100
 it's just always a rough ride.

2:05:31.100 --> 2:05:33.100
 And you came into this by saying like,

2:05:33.100 --> 2:05:36.180
 what does COVID and all the social strife

2:05:36.180 --> 2:05:38.060
 that's happening right now mean?

2:05:38.060 --> 2:05:40.900
 And I think that it's really bad in the short term,

2:05:40.900 --> 2:05:42.540
 but I think it'll lead to progress.

2:05:42.540 --> 2:05:44.300
 And for that, I'm very thankful.

2:05:45.940 --> 2:05:47.980
 Yeah, painful in the short term though.

2:05:47.980 --> 2:05:48.820
 Well, yeah.

2:05:48.820 --> 2:05:49.740
 I mean, people are out of jobs.

2:05:49.740 --> 2:05:50.860
 Like some people can't eat.

2:05:50.860 --> 2:05:52.500
 Like it's horrible.

2:05:52.500 --> 2:05:56.940
 And, but you know, it's progress.

2:05:56.940 --> 2:05:58.500
 So we'll see what happens.

2:05:58.500 --> 2:06:01.900
 I mean, the real question is when you look back 10 years,

2:06:01.900 --> 2:06:03.580
 20 years, a hundred years from now,

2:06:03.580 --> 2:06:06.860
 how do we evaluate the decisions are being made right now?

2:06:06.860 --> 2:06:09.780
 I think that's really the way you can frame that

2:06:09.780 --> 2:06:10.620
 and look at it.

2:06:10.620 --> 2:06:11.660
 And you say, you know,

2:06:11.660 --> 2:06:14.260
 you integrate across all the short term horribleness

2:06:14.260 --> 2:06:17.220
 that's happening and you look at what that means

2:06:17.220 --> 2:06:19.660
 and is the improvement across the world

2:06:19.660 --> 2:06:22.980
 or the regression across the world significant enough

2:06:22.980 --> 2:06:24.700
 to make it a good or a bad thing?

2:06:24.700 --> 2:06:26.820
 I think that's the question.

2:06:26.820 --> 2:06:27.660
 Yeah.

2:06:27.660 --> 2:06:29.460
 And for that, it's good to study history.

2:06:29.460 --> 2:06:32.020
 I mean, one of the big problems for me right now

2:06:32.020 --> 2:06:34.740
 is I'm reading The Rise and Fall of the Third Reich.

2:06:36.060 --> 2:06:37.340
 Light reading?

2:06:37.340 --> 2:06:39.660
 So it's everything is just,

2:06:39.660 --> 2:06:42.140
 I just see parallels and it means it's,

2:06:42.140 --> 2:06:45.300
 you have to be really careful not to overstep it,

2:06:45.300 --> 2:06:48.700
 but just the thing that worries me the most

2:06:48.700 --> 2:06:53.700
 is the pain that people feel when a few things combine,

2:06:54.380 --> 2:06:55.940
 which is like economic depression,

2:06:55.940 --> 2:06:57.820
 which is quite possible in this country.

2:06:57.820 --> 2:07:02.540
 And then just being disrespected in some kind of way,

2:07:02.540 --> 2:07:05.100
 which the German people were really disrespected

2:07:05.100 --> 2:07:10.100
 by most of the world, like in a way that's over the top,

2:07:10.220 --> 2:07:12.100
 that something can build up

2:07:12.100 --> 2:07:14.940
 and then all you need is a charismatic leader

2:07:15.940 --> 2:07:19.460
 to go either positive or negative and both work

2:07:19.460 --> 2:07:21.060
 as long as they're charismatic.

2:07:21.060 --> 2:07:22.140
 And there's...

2:07:22.140 --> 2:07:23.740
 It's taking advantage of, again,

2:07:23.740 --> 2:07:26.340
 that inflection point that the world's in

2:07:26.340 --> 2:07:28.700
 and what they do with it could be good or bad.

2:07:29.700 --> 2:07:32.700
 And so it's a good way to think about times now,

2:07:32.700 --> 2:07:34.740
 like on an individual level,

2:07:34.740 --> 2:07:38.260
 what we decide to do is when history is written,

2:07:38.260 --> 2:07:40.940
 30 years from now, what happened in 2020,

2:07:40.940 --> 2:07:43.140
 probably history is gonna remember 2020.

2:07:43.140 --> 2:07:43.980
 Yeah, I think so.

2:07:43.980 --> 2:07:46.820
 Either for good or bad,

2:07:46.820 --> 2:07:49.540
 and it's up to us to write it so it's good.

2:07:49.540 --> 2:07:50.900
 Well, one of the things I've observed

2:07:50.900 --> 2:07:54.180
 that I find fascinating is most people act

2:07:54.180 --> 2:07:56.460
 as though the world doesn't change.

2:07:56.460 --> 2:07:59.980
 You make decision knowingly, right?

2:07:59.980 --> 2:08:02.620
 You make a decision where you're predicting the future

2:08:02.620 --> 2:08:04.780
 based on what you've seen in the recent past.

2:08:04.780 --> 2:08:06.100
 And so if something's always been,

2:08:06.100 --> 2:08:07.300
 it's rained every single day,

2:08:07.300 --> 2:08:10.060
 then of course you expect it to rain today too, right?

2:08:10.060 --> 2:08:13.420
 On the other hand, the world changes all the time.

2:08:13.420 --> 2:08:14.260
 Yeah.

2:08:14.260 --> 2:08:16.780
 Constantly, like for better and for worse.

2:08:16.780 --> 2:08:17.700
 And so the question is,

2:08:17.700 --> 2:08:20.900
 if you're interested in something that's not right,

2:08:20.900 --> 2:08:22.900
 what is the inflection point that led to a change?

2:08:22.900 --> 2:08:24.380
 And you can look to history for this.

2:08:24.380 --> 2:08:27.980
 Like what is the catalyst that led to that explosion

2:08:27.980 --> 2:08:30.220
 that led to that bill that led to the,

2:08:30.220 --> 2:08:33.220
 like you can kind of work your way backwards from that.

2:08:33.220 --> 2:08:35.740
 And maybe if you pull together the right people

2:08:35.740 --> 2:08:36.940
 and you get the right ideas together,

2:08:36.940 --> 2:08:38.980
 you can actually start driving that change

2:08:38.980 --> 2:08:40.340
 and doing it in a way that's productive

2:08:40.340 --> 2:08:41.780
 and hurts fewer people.

2:08:41.780 --> 2:08:43.020
 Yeah, like a single person,

2:08:43.020 --> 2:08:44.820
 a single event can turn all of history.

2:08:44.820 --> 2:08:46.420
 Absolutely, everything starts somewhere.

2:08:46.420 --> 2:08:48.500
 And often it's a combination of multiple factors,

2:08:48.500 --> 2:08:52.500
 but yeah, these things can be engineered.

2:08:52.500 --> 2:08:54.980
 That's actually the optimistic view that.

2:08:54.980 --> 2:08:57.580
 I'm a longterm optimist on pretty much everything

2:08:57.580 --> 2:08:59.340
 and human nature.

2:08:59.340 --> 2:09:00.700
 We can look to all the negative things

2:09:00.700 --> 2:09:03.300
 that humanity has, all the pettiness

2:09:03.300 --> 2:09:05.860
 and all the like self servingness

2:09:05.860 --> 2:09:09.780
 and the just the cruelty, right?

2:09:09.780 --> 2:09:13.380
 The biases, the just humans can be very horrible.

2:09:13.380 --> 2:09:17.140
 But on the other hand, we're capable of amazing things.

2:09:17.140 --> 2:09:21.540
 And the progress across 100 year chunks

2:09:21.540 --> 2:09:23.300
 is striking.

2:09:23.300 --> 2:09:26.700
 And even across decades, we've come a long ways

2:09:26.700 --> 2:09:27.820
 and there's still a long ways to go,

2:09:27.820 --> 2:09:29.980
 but that doesn't mean that we've stopped.

2:09:29.980 --> 2:09:33.060
 Yeah, the kind of stuff we've done in the last 100 years

2:09:33.060 --> 2:09:34.900
 is unbelievable.

2:09:34.900 --> 2:09:36.740
 It's kind of scary to think what's gonna happen

2:09:36.740 --> 2:09:37.580
 in this 100 years.

2:09:37.580 --> 2:09:39.020
 It's scary, like exciting.

2:09:39.020 --> 2:09:41.700
 Like scary in a sense that it's kind of sad

2:09:41.700 --> 2:09:43.780
 that the kind of technology is gonna come out

2:09:43.780 --> 2:09:45.740
 in 10, 20, 30 years.

2:09:45.740 --> 2:09:47.820
 We're probably too old to really appreciate

2:09:47.820 --> 2:09:49.100
 if you don't grow up with it.

2:09:49.100 --> 2:09:51.700
 It'll be like kids these days with their virtual reality

2:09:51.700 --> 2:09:54.500
 and their TikToks and stuff like this.

2:09:54.500 --> 2:09:56.820
 Like, how does this thing and like,

2:09:56.820 --> 2:09:59.140
 come on, give me my static photo.

2:10:00.860 --> 2:10:02.300
 My Commodore 64.

2:10:02.300 --> 2:10:03.740
 Yeah, exactly.

2:10:03.740 --> 2:10:05.820
 Okay, sorry, we kind of skipped over.

2:10:05.820 --> 2:10:10.820
 Let me ask on, the machine learning world

2:10:11.060 --> 2:10:15.740
 has been kind of inspired, their imagination captivated

2:10:15.740 --> 2:10:18.740
 with GPT3 and these language models.

2:10:18.740 --> 2:10:21.820
 I thought it'd be cool to get your opinion on it.

2:10:21.820 --> 2:10:26.260
 What's your thoughts on this exciting world of,

2:10:27.300 --> 2:10:29.940
 it connects to computation actually,

2:10:29.940 --> 2:10:33.020
 is of language models that are huge

2:10:33.020 --> 2:10:37.420
 and take many, many computers, not just to train,

2:10:37.420 --> 2:10:39.420
 but to also do inference on.

2:10:39.420 --> 2:10:40.460
 Sure.

2:10:40.460 --> 2:10:43.420
 Well, I mean, it depends on what you're speaking to there.

2:10:43.420 --> 2:10:45.300
 But I mean, I think that there's been

2:10:45.300 --> 2:10:48.380
 a pretty well understood maximum in deep learning

2:10:48.380 --> 2:10:49.660
 that if you make the model bigger

2:10:49.660 --> 2:10:51.380
 and you shove more data into it,

2:10:51.380 --> 2:10:52.420
 assuming you train it right

2:10:52.420 --> 2:10:54.020
 and you have a good model architecture,

2:10:54.020 --> 2:10:55.820
 that you'll get a better model out.

2:10:55.820 --> 2:10:59.740
 And so on one hand, GPT3 was not that surprising.

2:10:59.740 --> 2:11:02.060
 On the other hand, a tremendous amount of engineering

2:11:02.060 --> 2:11:03.580
 went into making it possible.

2:11:04.740 --> 2:11:07.060
 The implications of it are pretty huge.

2:11:07.060 --> 2:11:08.980
 I think that when GPT2 came out,

2:11:08.980 --> 2:11:11.380
 there was a very provocative blog post from OpenAI

2:11:11.380 --> 2:11:13.660
 talking about, we're not gonna release it

2:11:13.660 --> 2:11:15.460
 because of the social damage it could cause

2:11:15.460 --> 2:11:18.660
 if it's misused.

2:11:18.660 --> 2:11:20.140
 I think that's still a concern.

2:11:20.140 --> 2:11:23.300
 I think that we need to look at how technology is applied

2:11:23.300 --> 2:11:26.900
 and well meaning tools can be applied in very horrible ways

2:11:26.900 --> 2:11:29.340
 and they can have very profound impact on that.

2:11:30.620 --> 2:11:34.020
 I think that GPT3 is a huge technical achievement.

2:11:34.020 --> 2:11:35.780
 And what will GPT4 be?

2:11:35.780 --> 2:11:38.540
 Well, it'll probably be bigger, more expensive to train.

2:11:38.540 --> 2:11:42.020
 Really cool architectural tricks.

2:11:42.020 --> 2:11:43.980
 What do you think, is there,

2:11:43.980 --> 2:11:46.460
 I don't know how much thought you've done

2:11:46.460 --> 2:11:48.700
 on distributed computing.

2:11:48.700 --> 2:11:52.940
 Is there some technical challenges that are interesting

2:11:52.940 --> 2:11:54.620
 that you're hopeful about exploring

2:11:54.620 --> 2:11:57.660
 in terms of a system that,

2:11:57.660 --> 2:12:02.660
 like a piece of code that with GPT4 that might have,

2:12:05.260 --> 2:12:09.340
 I don't know, hundreds of trillions of parameters

2:12:09.340 --> 2:12:11.580
 which have to run on thousands of computers.

2:12:11.580 --> 2:12:15.340
 Is there some hope that we can make that happen?

2:12:15.340 --> 2:12:18.940
 Yeah, well, I mean, today you can write a check

2:12:18.940 --> 2:12:21.780
 and get access to a thousand TPU cores

2:12:21.780 --> 2:12:23.940
 and do really interesting large scale training

2:12:23.940 --> 2:12:26.540
 and inference and things like that in Google Cloud,

2:12:26.540 --> 2:12:27.420
 for example, right?

2:12:27.420 --> 2:12:31.340
 And so I don't think it's a question about scale,

2:12:31.340 --> 2:12:33.220
 it's a question about utility.

2:12:33.220 --> 2:12:36.220
 And when I look at the transformer series of architectures

2:12:36.220 --> 2:12:38.780
 that the GPT series is based on,

2:12:38.780 --> 2:12:39.900
 it's really interesting to look at that

2:12:39.900 --> 2:12:42.940
 because they're actually very simple designs.

2:12:42.940 --> 2:12:44.740
 They're not recurrent.

2:12:44.740 --> 2:12:47.460
 The training regimens are pretty simple.

2:12:47.460 --> 2:12:51.700
 And so they don't really reflect like human brains, right?

2:12:51.700 --> 2:12:54.620
 But they're really good at learning language models

2:12:54.620 --> 2:12:55.740
 and they're unrolled enough

2:12:55.740 --> 2:12:59.020
 that you can simulate some recurrence, right?

2:12:59.020 --> 2:13:02.100
 And so the question I think about is,

2:13:02.100 --> 2:13:03.260
 where does this take us?

2:13:03.260 --> 2:13:05.140
 Like, so we can just keep scaling it,

2:13:05.140 --> 2:13:07.700
 have more parameters, more data, more things,

2:13:07.700 --> 2:13:09.460
 we'll get a better result for sure.

2:13:09.460 --> 2:13:11.820
 But are there architectural techniques

2:13:11.820 --> 2:13:15.300
 that can lead to progress at a faster pace, right?

2:13:15.300 --> 2:13:17.740
 This is when, you know, how do you get,

2:13:17.740 --> 2:13:20.660
 instead of just like making it a constant time bigger,

2:13:20.660 --> 2:13:23.380
 how do you get like an algorithmic improvement

2:13:23.380 --> 2:13:24.220
 out of this, right?

2:13:24.220 --> 2:13:25.780
 And whether it be a new training regimen,

2:13:25.780 --> 2:13:30.380
 if it becomes sparse networks, for example,

2:13:30.380 --> 2:13:33.660
 the human brain is sparse, all these networks are dense.

2:13:33.660 --> 2:13:36.140
 The connectivity patterns can be very different.

2:13:36.140 --> 2:13:38.260
 I think this is where I get very interested

2:13:38.260 --> 2:13:39.500
 and I'm way out of my league

2:13:39.500 --> 2:13:41.580
 on the deep learning side of this.

2:13:41.580 --> 2:13:43.700
 But I think that could lead to big breakthroughs.

2:13:43.700 --> 2:13:46.140
 When you talk about large scale networks,

2:13:46.140 --> 2:13:47.980
 one of the things that Jeff Dean likes to talk about

2:13:47.980 --> 2:13:50.940
 and he's given a few talks on

2:13:50.940 --> 2:13:54.220
 is this idea of having a sparsely gated mixture of experts

2:13:54.220 --> 2:13:57.420
 kind of a model where you have, you know,

2:13:57.420 --> 2:13:59.460
 different nets that are trained

2:13:59.460 --> 2:14:02.060
 and are really good at certain kinds of tasks.

2:14:02.060 --> 2:14:04.820
 And so you have this distributor across a cluster

2:14:04.820 --> 2:14:06.420
 and so you have a lot of different computers

2:14:06.420 --> 2:14:08.580
 that end up being kind of locally specialized

2:14:08.580 --> 2:14:09.740
 in different demands.

2:14:09.740 --> 2:14:11.060
 And then when a query comes in,

2:14:11.060 --> 2:14:13.740
 you gate it and you use learn techniques

2:14:13.740 --> 2:14:15.460
 to route to different parts of the network.

2:14:15.460 --> 2:14:18.020
 And then you utilize the compute resources

2:14:18.020 --> 2:14:20.660
 of the entire cluster by having specialization within it.

2:14:20.660 --> 2:14:23.700
 And I don't know where that goes

2:14:23.700 --> 2:14:25.540
 or when it starts to work,

2:14:25.540 --> 2:14:26.700
 but I think things like that

2:14:26.700 --> 2:14:28.380
 could be really interesting as well.

2:14:28.380 --> 2:14:30.060
 And on the data side too,

2:14:30.060 --> 2:14:33.700
 if you can think of data selection

2:14:33.700 --> 2:14:35.820
 as a kind of programming.

2:14:35.820 --> 2:14:36.660
 Yeah.

2:14:36.660 --> 2:14:37.980
 I mean, essentially, if you look at it,

2:14:37.980 --> 2:14:40.580
 like Karpathy talked about software 2.0,

2:14:40.580 --> 2:14:44.020
 I mean, in a sense, data is the program.

2:14:44.020 --> 2:14:44.860
 Yeah, yeah.

2:14:44.860 --> 2:14:48.340
 So let me try to summarize Andre's position really quick

2:14:48.340 --> 2:14:50.020
 before I disagree with it.

2:14:50.020 --> 2:14:51.140
 Yeah.

2:14:51.140 --> 2:14:53.420
 So Andre Karpathy is amazing.

2:14:53.420 --> 2:14:55.180
 So this is nothing personal with him.

2:14:55.180 --> 2:14:57.380
 He's an amazing engineer.

2:14:57.380 --> 2:14:59.220
 And also a good blog post writer.

2:14:59.220 --> 2:15:01.100
 Yeah, well, he's a great communicator.

2:15:01.100 --> 2:15:02.420
 You know, he's just an amazing person.

2:15:02.420 --> 2:15:03.720
 He's also really sweet.

2:15:03.720 --> 2:15:08.720
 So his basic premise is that software is suboptimal.

2:15:09.360 --> 2:15:11.040
 I think we can all agree to that.

2:15:11.040 --> 2:15:14.480
 He also points out that deep learning

2:15:14.480 --> 2:15:16.360
 and other learning based techniques are really great

2:15:16.360 --> 2:15:17.520
 because you can solve problems

2:15:17.520 --> 2:15:22.120
 in more structured ways with less like ad hoc code

2:15:22.120 --> 2:15:24.440
 that people write out and don't write test cases for

2:15:24.440 --> 2:15:25.280
 in some cases.

2:15:25.280 --> 2:15:27.800
 And so they don't even know if it works in the first place.

2:15:27.800 --> 2:15:32.320
 And so if you start replacing systems of imperative code

2:15:32.320 --> 2:15:37.320
 with deep learning models, then you get a better result.

2:15:37.400 --> 2:15:38.380
 Okay.

2:15:38.380 --> 2:15:40.680
 And I think that he argues that software 2.0

2:15:40.680 --> 2:15:44.120
 is a pervasively learned set of models

2:15:44.120 --> 2:15:45.920
 and you get away from writing code.

2:15:45.920 --> 2:15:49.040
 And he's given talks where he talks about, you know,

2:15:49.040 --> 2:15:50.960
 swapping over more and more and more parts of the code

2:15:50.960 --> 2:15:54.840
 to being learned and driven that way.

2:15:54.840 --> 2:15:56.640
 I think that works.

2:15:56.640 --> 2:15:59.280
 And if you're predisposed to liking machine learning,

2:15:59.280 --> 2:16:01.760
 then I think that that's definitely a good thing.

2:16:01.760 --> 2:16:04.720
 I think this is also good for accessibility in many ways

2:16:04.720 --> 2:16:06.800
 because certain people are not gonna write C code

2:16:06.800 --> 2:16:07.720
 or something.

2:16:07.720 --> 2:16:10.200
 And so having a data driven approach to do

2:16:10.200 --> 2:16:12.720
 this kind of stuff, I think can be very valuable.

2:16:12.720 --> 2:16:14.200
 On the other hand, there are huge trade offs.

2:16:14.200 --> 2:16:19.200
 It's not clear to me that software 2.0 is the answer.

2:16:19.200 --> 2:16:21.440
 And probably Andre wouldn't argue that it's the answer

2:16:21.440 --> 2:16:22.960
 for every problem either.

2:16:22.960 --> 2:16:26.760
 But I look at machine learning as not a replacement

2:16:26.760 --> 2:16:27.920
 for software 1.0.

2:16:27.920 --> 2:16:30.120
 I look at it as a new programming paradigm.

2:16:30.120 --> 2:16:35.120
 And so programming paradigms, when you look across demands,

2:16:35.140 --> 2:16:38.500
 is structured programming where you go from go tos

2:16:38.500 --> 2:16:42.300
 to if, then, else, or functional programming from Lisp.

2:16:42.300 --> 2:16:44.440
 And you start talking about higher order functions

2:16:44.440 --> 2:16:45.900
 and values and things like this.

2:16:45.900 --> 2:16:48.060
 Or you talk about object oriented programming.

2:16:48.060 --> 2:16:49.440
 You're talking about encapsulation,

2:16:49.440 --> 2:16:50.460
 subclassing, inheritance.

2:16:50.460 --> 2:16:52.640
 You start talking about generic programming

2:16:52.640 --> 2:16:54.460
 where you start talking about code reuse

2:16:54.460 --> 2:16:59.240
 through specialization and different type instantiations.

2:16:59.240 --> 2:17:01.740
 When you start talking about differentiable programming,

2:17:01.740 --> 2:17:04.500
 something that I am very excited about

2:17:04.500 --> 2:17:05.940
 in the context of machine learning,

2:17:05.940 --> 2:17:09.500
 talking about taking functions and generating variants,

2:17:09.500 --> 2:17:11.140
 like the derivative of another function.

2:17:11.140 --> 2:17:13.780
 Like that's a programming paradigm that's very useful

2:17:13.780 --> 2:17:16.220
 for solving certain classes of problems.

2:17:16.220 --> 2:17:17.660
 Machine learning is amazing

2:17:17.660 --> 2:17:19.180
 at solving certain classes of problems.

2:17:19.180 --> 2:17:21.940
 Like you're not gonna write a cat detector

2:17:21.940 --> 2:17:25.900
 or even a language translation system by writing C code.

2:17:25.900 --> 2:17:28.920
 That's not a very productive way to do things anymore.

2:17:28.920 --> 2:17:31.060
 And so machine learning is absolutely

2:17:31.060 --> 2:17:31.980
 the right way to do that.

2:17:31.980 --> 2:17:34.120
 In fact, I would say that learned models

2:17:34.120 --> 2:17:35.980
 are really one of the best ways to work

2:17:35.980 --> 2:17:38.220
 with the human world in general.

2:17:38.220 --> 2:17:40.320
 And so anytime you're talking about sensory input

2:17:40.320 --> 2:17:41.360
 of different modalities,

2:17:41.360 --> 2:17:44.300
 anytime that you're talking about generating things

2:17:44.300 --> 2:17:45.780
 in a way that makes sense to a human,

2:17:45.780 --> 2:17:48.900
 I think that learned models are really, really useful.

2:17:48.900 --> 2:17:50.580
 And that's because humans are very difficult

2:17:50.580 --> 2:17:52.620
 to characterize, okay?

2:17:52.620 --> 2:17:55.220
 And so this is a very powerful paradigm

2:17:55.220 --> 2:17:57.120
 for solving classes of problems.

2:17:57.120 --> 2:17:59.700
 But on the other hand, imperative code is too.

2:17:59.700 --> 2:18:03.020
 You're not gonna write a bootloader for your computer

2:18:03.020 --> 2:18:04.060
 with a deep learning model.

2:18:04.060 --> 2:18:07.060
 Deep learning models are very hardware intensive.

2:18:07.060 --> 2:18:08.980
 They're very energy intensive

2:18:08.980 --> 2:18:11.060
 because you have a lot of parameters

2:18:11.060 --> 2:18:14.520
 and you can provably implement any function

2:18:14.520 --> 2:18:17.700
 with a learned model, like this has been shown,

2:18:17.700 --> 2:18:20.060
 but that doesn't make it efficient.

2:18:20.060 --> 2:18:22.300
 And so if you're talking about caring about a few orders

2:18:22.300 --> 2:18:24.100
 of magnitudes worth of energy usage,

2:18:24.100 --> 2:18:26.940
 then it's useful to have other tools in the toolbox.

2:18:26.940 --> 2:18:28.420
 There's also robustness too.

2:18:28.420 --> 2:18:29.260
 I mean, as a...

2:18:29.260 --> 2:18:30.100
 Yeah, exactly.

2:18:30.100 --> 2:18:32.500
 All the problems of dealing with data and bias in data,

2:18:32.500 --> 2:18:35.100
 all the problems of software 2.0.

2:18:35.100 --> 2:18:39.340
 And one of the great things that Andre is arguing towards,

2:18:39.340 --> 2:18:40.940
 which I completely agree with him,

2:18:40.940 --> 2:18:43.820
 is that when you start implementing things

2:18:43.820 --> 2:18:46.220
 with deep learning, you need to learn from software 1.0

2:18:46.220 --> 2:18:49.060
 in terms of testing, continuous integration,

2:18:49.060 --> 2:18:51.220
 how you deploy, how do you validate,

2:18:51.220 --> 2:18:53.980
 all these things and building systems around that

2:18:53.980 --> 2:18:55.020
 so that you're not just saying like,

2:18:55.020 --> 2:18:58.460
 oh, it seems like it's good, ship it, right?

2:18:58.460 --> 2:18:59.840
 Well, what happens when I regress something?

2:18:59.840 --> 2:19:02.500
 What happens when I make a classification that's wrong

2:19:02.500 --> 2:19:05.540
 and now I hurt somebody, right?

2:19:05.540 --> 2:19:07.380
 I mean, all these things you have to reason about.

2:19:07.380 --> 2:19:08.380
 Yeah, but at the same time,

2:19:08.380 --> 2:19:11.860
 the bootloader that works for us humans

2:19:12.980 --> 2:19:15.700
 looks awfully a lot like a neural network, right?

2:19:15.700 --> 2:19:16.540
 Yeah.

2:19:16.540 --> 2:19:18.520
 It's messy and you can cut out

2:19:18.520 --> 2:19:19.780
 different parts of the brain.

2:19:19.780 --> 2:19:22.400
 There's a lot of this neuroplasticity work

2:19:22.400 --> 2:19:24.100
 that shows that it's gonna adjust.

2:19:24.100 --> 2:19:26.900
 It's a really interesting question,

2:19:26.900 --> 2:19:29.700
 how much of the world's programming

2:19:29.700 --> 2:19:31.780
 could be replaced by software 2.0?

2:19:31.780 --> 2:19:32.620
 Like with...

2:19:32.620 --> 2:19:35.180
 Oh, well, I mean, it's provably true

2:19:35.180 --> 2:19:37.540
 that you could replace all of it.

2:19:37.540 --> 2:19:39.220
 Right, so then it's a question of the trade offs.

2:19:39.220 --> 2:19:40.940
 Anything that's a function, you can.

2:19:40.940 --> 2:19:42.940
 So it's not a question about if.

2:19:42.940 --> 2:19:44.900
 I think it's a economic question.

2:19:44.900 --> 2:19:47.740
 It's a, what kind of talent can you get?

2:19:47.740 --> 2:19:50.460
 What kind of trade offs in terms of maintenance, right?

2:19:50.460 --> 2:19:51.680
 Those kinds of questions, I think.

2:19:51.680 --> 2:19:53.280
 What kind of data can you collect?

2:19:53.280 --> 2:19:55.120
 I think one of the reasons that I'm most interested

2:19:55.120 --> 2:19:58.580
 in machine learning as a programming paradigm

2:19:58.580 --> 2:20:00.340
 is that one of the things that we've seen

2:20:00.340 --> 2:20:02.340
 across computing in general is that

2:20:02.340 --> 2:20:04.680
 being laser focused on one paradigm

2:20:04.680 --> 2:20:07.540
 often puts you in a box that's not super great.

2:20:07.540 --> 2:20:10.420
 And so you look at object oriented programming,

2:20:10.420 --> 2:20:12.060
 like it was all the rage in the early 80s

2:20:12.060 --> 2:20:13.520
 and like everything has to be objects.

2:20:13.520 --> 2:20:15.620
 And people forgot about functional programming

2:20:15.620 --> 2:20:17.380
 even though it came first.

2:20:17.380 --> 2:20:19.820
 And then people rediscovered that,

2:20:19.820 --> 2:20:21.820
 hey, if you mix functional and object oriented

2:20:21.820 --> 2:20:24.300
 in structure, like you mix these things together,

2:20:24.300 --> 2:20:25.820
 you can provide very interesting tools

2:20:25.820 --> 2:20:28.460
 that are good at solving different problems.

2:20:28.460 --> 2:20:30.800
 And so the question there is how do you get

2:20:30.800 --> 2:20:32.660
 the best way to solve the problems?

2:20:32.660 --> 2:20:36.020
 It's not about whose tribe should win, right?

2:20:36.020 --> 2:20:38.780
 It's not about, you know, that shouldn't be the question.

2:20:38.780 --> 2:20:40.060
 The question is how do you make it

2:20:40.060 --> 2:20:42.180
 so that people can solve those problems the fastest

2:20:42.180 --> 2:20:44.340
 and they have the right tools in their box

2:20:44.340 --> 2:20:47.180
 to build good libraries and they can solve these problems.

2:20:47.180 --> 2:20:49.100
 And when you look at that, that's like, you know,

2:20:49.100 --> 2:20:50.340
 you look at reinforcement learning

2:20:50.340 --> 2:20:52.660
 as one really interesting subdomain of this.

2:20:52.660 --> 2:20:55.080
 Reinforcement learning, often you have to have

2:20:55.080 --> 2:20:57.660
 the integration of a learned model

2:20:57.660 --> 2:21:00.820
 combined with your Atari or whatever the other scenario

2:21:00.820 --> 2:21:02.880
 it is that you're working in.

2:21:02.880 --> 2:21:05.700
 You have to combine that thing with the robot control

2:21:05.700 --> 2:21:07.660
 for the arm, right?

2:21:07.660 --> 2:21:11.960
 And so now it's not just about that one paradigm,

2:21:11.960 --> 2:21:14.600
 it's about integrating that with all the other systems

2:21:14.600 --> 2:21:17.100
 that you have, including often legacy systems

2:21:17.100 --> 2:21:18.160
 and things like this, right?

2:21:18.160 --> 2:21:21.500
 And so to me, I think that the interesting thing to say

2:21:21.500 --> 2:21:23.820
 is like, how do you get the best out of this domain

2:21:23.820 --> 2:21:25.820
 and how do you enable people to achieve things

2:21:25.820 --> 2:21:27.340
 that they otherwise couldn't do

2:21:27.340 --> 2:21:29.720
 without excluding all the good things

2:21:29.720 --> 2:21:31.300
 we already know how to do?

2:21:31.300 --> 2:21:35.340
 Right, but okay, this is a crazy question,

2:21:35.340 --> 2:21:38.860
 but we talked a little bit about GPT3,

2:21:38.860 --> 2:21:42.340
 but do you think it's possible that these language models

2:21:42.340 --> 2:21:47.340
 that in essence, in the language domain,

2:21:47.340 --> 2:21:51.820
 Software 2.0 could replace some aspect of compilation,

2:21:51.820 --> 2:21:54.260
 for example, or do program synthesis,

2:21:54.260 --> 2:21:56.900
 replace some aspect of programming?

2:21:56.900 --> 2:21:57.740
 Yeah, absolutely.

2:21:57.740 --> 2:22:00.380
 So I think that learned models in general

2:22:00.380 --> 2:22:01.580
 are extremely powerful,

2:22:01.580 --> 2:22:03.700
 and I think that people underestimate them.

2:22:04.740 --> 2:22:07.180
 Maybe you can suggest what I should do.

2:22:07.180 --> 2:22:11.380
 So if I have access to the GPT3 API,

2:22:11.380 --> 2:22:14.260
 would I be able to generate Swift code, for example?

2:22:14.260 --> 2:22:16.060
 Do you think that could do something interesting

2:22:16.060 --> 2:22:17.420
 and would work?

2:22:17.420 --> 2:22:21.140
 So GPT3 is probably not trained on the right corpus,

2:22:21.140 --> 2:22:23.700
 so it probably has the ability to generate some Swift.

2:22:23.700 --> 2:22:25.220
 I bet it does.

2:22:25.220 --> 2:22:27.280
 It's probably not gonna generate a large enough body

2:22:27.280 --> 2:22:28.340
 of Swift to be useful,

2:22:28.340 --> 2:22:30.580
 but take it a next step further.

2:22:30.580 --> 2:22:33.980
 Like if you had the goal of training something like GPT3

2:22:33.980 --> 2:22:38.020
 and you wanted to train it to generate source code, right?

2:22:38.020 --> 2:22:39.780
 It could definitely do that.

2:22:39.780 --> 2:22:42.640
 Now the question is, how do you express the intent

2:22:42.640 --> 2:22:44.300
 of what you want filled in?

2:22:44.300 --> 2:22:47.060
 You can definitely write scaffolding of code

2:22:47.060 --> 2:22:48.940
 and say, fill in the hole,

2:22:48.940 --> 2:22:50.300
 and sort of put in some for loops,

2:22:50.300 --> 2:22:51.540
 or put in some classes or whatever.

2:22:51.540 --> 2:22:53.700
 And the power of these models is impressive,

2:22:53.700 --> 2:22:56.940
 but there's an unsolved question, at least unsolved to me,

2:22:56.940 --> 2:22:59.700
 which is, how do I express the intent of what to fill in?

2:22:59.700 --> 2:23:01.000
 Right?

2:23:01.000 --> 2:23:03.180
 And kind of what you'd really want to have,

2:23:03.180 --> 2:23:06.340
 and I don't know that these models are up to the task,

2:23:06.340 --> 2:23:08.300
 is you wanna be able to say,

2:23:08.300 --> 2:23:09.660
 here's the scaffolding,

2:23:09.660 --> 2:23:12.460
 and here are the assertions at the end.

2:23:12.460 --> 2:23:14.020
 And the assertions always pass.

2:23:14.020 --> 2:23:16.460
 And so you want a generative model on the one hand, yes.

2:23:16.460 --> 2:23:17.580
 Oh, that's fascinating, yeah.

2:23:17.580 --> 2:23:20.420
 Right, but you also want some loop back,

2:23:20.420 --> 2:23:23.180
 some reinforcement learning system or something,

2:23:23.180 --> 2:23:24.660
 where you're actually saying like,

2:23:24.660 --> 2:23:26.580
 I need to hill climb towards something

2:23:26.580 --> 2:23:28.500
 that is more correct.

2:23:28.500 --> 2:23:29.720
 And I don't know that we have that.

2:23:29.720 --> 2:23:33.640
 So it would generate not only a bunch of the code,

2:23:33.640 --> 2:23:35.940
 but like the checks that do the testing.

2:23:35.940 --> 2:23:37.100
 It would generate the tests.

2:23:37.100 --> 2:23:38.860
 I think the humans would generate the tests, right?

2:23:38.860 --> 2:23:39.700
 Oh, okay.

2:23:39.700 --> 2:23:41.340
 But it would be fascinating if...

2:23:41.340 --> 2:23:43.060
 Well, the tests are the requirements.

2:23:43.060 --> 2:23:44.260
 Yes, but the, okay, so...

2:23:44.260 --> 2:23:45.940
 Because you have to express to the model

2:23:45.940 --> 2:23:47.100
 what you want to...

2:23:47.100 --> 2:23:49.020
 You don't just want gibberish code.

2:23:49.020 --> 2:23:51.340
 Look at how compelling this code looks.

2:23:51.340 --> 2:23:54.800
 You want a story about four horned unicorns or something.

2:23:54.800 --> 2:23:55.980
 Well, okay, so exactly.

2:23:55.980 --> 2:23:57.720
 But that's human requirements.

2:23:57.720 --> 2:24:00.220
 But then I thought it's a compelling idea

2:24:00.220 --> 2:24:05.220
 that the GPT4 model could generate checks

2:24:06.980 --> 2:24:11.980
 that are more high fidelity that check for correctness.

2:24:11.980 --> 2:24:14.680
 Because the code it generates,

2:24:14.680 --> 2:24:18.400
 like say I ask it to generate a function

2:24:18.400 --> 2:24:21.620
 that gives me the Fibonacci sequence.

2:24:21.620 --> 2:24:22.460
 Sure.

2:24:22.460 --> 2:24:24.340
 I don't like...

2:24:24.340 --> 2:24:25.640
 So decompose the problem, right?

2:24:25.640 --> 2:24:26.980
 So you have two things.

2:24:26.980 --> 2:24:29.360
 You have, you need the ability to generate

2:24:29.360 --> 2:24:33.080
 syntactically correct Swift code that's interesting, right?

2:24:33.080 --> 2:24:37.560
 I think GPT series of model architectures can do that.

2:24:37.560 --> 2:24:41.320
 But then you need the ability to add the requirements.

2:24:41.320 --> 2:24:43.360
 So generate Fibonacci.

2:24:43.360 --> 2:24:46.040
 The human needs to express that goal.

2:24:46.040 --> 2:24:49.160
 We don't have that language that I know of.

2:24:49.160 --> 2:24:50.840
 No, I mean, it can generate stuff.

2:24:50.840 --> 2:24:52.840
 Have you seen what GPT3 can generate?

2:24:52.840 --> 2:24:55.760
 You can say, I mean, there's a interface stuff

2:24:55.760 --> 2:24:58.360
 like it can generate HTML.

2:24:58.360 --> 2:25:02.000
 It can generate basic for loops that give you like...

2:25:02.000 --> 2:25:02.880
 Right, but pick HTML.

2:25:02.880 --> 2:25:05.100
 How do I say I want google.com?

2:25:06.080 --> 2:25:07.800
 Well, no, you could say...

2:25:07.800 --> 2:25:09.360
 Or not literally google.com.

2:25:09.360 --> 2:25:10.520
 How do I say I want a webpage

2:25:10.520 --> 2:25:13.160
 that's got a shopping cart and this and that?

2:25:13.160 --> 2:25:14.000
 It does that.

2:25:14.000 --> 2:25:14.840
 I mean, so, okay.

2:25:14.840 --> 2:25:17.680
 So just, I don't know if you've seen these demonstrations

2:25:17.680 --> 2:25:20.340
 but you type in, I want a red button

2:25:20.340 --> 2:25:22.440
 with the text that says hello.

2:25:22.440 --> 2:25:24.160
 And you type that in natural language

2:25:24.160 --> 2:25:26.120
 and it generates the correct HTML.

2:25:26.120 --> 2:25:27.600
 I've done this demo.

2:25:27.600 --> 2:25:29.000
 It's kind of compelling.

2:25:29.000 --> 2:25:33.280
 So you have to prompt it with similar kinds of mappings.

2:25:33.280 --> 2:25:35.640
 Of course, it's probably handpicked.

2:25:35.640 --> 2:25:37.940
 I got to experiment that probably,

2:25:37.940 --> 2:25:39.520
 but the fact that you can do that once

2:25:39.520 --> 2:25:43.200
 even out of like 20 is quite impressive.

2:25:43.200 --> 2:25:45.200
 Again, that's very basic.

2:25:45.200 --> 2:25:48.440
 Like the HTML is kind of messy and bad.

2:25:48.440 --> 2:25:49.960
 But yes, the intent is...

2:25:49.960 --> 2:25:53.320
 The idea is the intent is specified in natural language.

2:25:53.320 --> 2:25:54.400
 Yeah, so I have not seen that.

2:25:54.400 --> 2:25:55.240
 That's really cool.

2:25:55.240 --> 2:25:56.560
 Yeah.

2:25:56.560 --> 2:25:59.840
 Yeah, but the question is the correctness of that.

2:25:59.840 --> 2:26:02.840
 Like visually you can check, oh, the button is red,

2:26:02.840 --> 2:26:09.840
 but for more complicated functions

2:26:10.160 --> 2:26:12.080
 where the intent is harder to check.

2:26:12.080 --> 2:26:15.460
 This goes into like NP completeness kind of things.

2:26:15.460 --> 2:26:18.120
 Like I want to know that this code is correct

2:26:18.120 --> 2:26:20.720
 and generates a giant thing

2:26:20.720 --> 2:26:23.680
 that does some kind of calculation.

2:26:23.680 --> 2:26:25.400
 It seems to be working.

2:26:25.400 --> 2:26:27.880
 It's interesting to think like,

2:26:27.880 --> 2:26:30.720
 should the system also try to generate checks

2:26:30.720 --> 2:26:32.080
 for itself for correctness?

2:26:32.080 --> 2:26:33.000
 Yeah, I don't know.

2:26:33.000 --> 2:26:35.960
 And this is way beyond my experience.

2:26:35.960 --> 2:26:39.200
 The thing that I think about is that

2:26:39.200 --> 2:26:41.120
 there doesn't seem to be a lot of

2:26:41.120 --> 2:26:43.480
 equational reasoning going on.

2:26:43.480 --> 2:26:45.280
 There's a lot of pattern matching and filling in

2:26:45.280 --> 2:26:47.560
 and kind of propagating patterns

2:26:47.560 --> 2:26:49.220
 that have been seen before into the future

2:26:49.220 --> 2:26:50.680
 and into the generator result.

2:26:50.680 --> 2:26:53.240
 And so if you want to get correctness,

2:26:53.240 --> 2:26:55.180
 you kind of need theorem proving kind of things

2:26:55.180 --> 2:26:57.320
 and like higher level logic.

2:26:57.320 --> 2:26:58.600
 And I don't know that...

2:26:58.600 --> 2:27:00.520
 You could talk to Jan about that

2:27:00.520 --> 2:27:03.560
 and see what the bright minds

2:27:03.560 --> 2:27:04.720
 are thinking about right now,

2:27:04.720 --> 2:27:08.180
 but I don't think the GPT is in that vein.

2:27:08.180 --> 2:27:09.240
 It's still really cool.

2:27:09.240 --> 2:27:11.880
 Yeah, and surprisingly, who knows,

2:27:11.880 --> 2:27:13.960
 maybe reasoning is...

2:27:13.960 --> 2:27:14.780
 Is overrated.

2:27:14.780 --> 2:27:15.620
 Yeah, is overrated.

2:27:15.620 --> 2:27:17.320
 Right, I mean, do we reason?

2:27:17.320 --> 2:27:18.160
 Yeah.

2:27:18.160 --> 2:27:18.980
 How do you tell, right?

2:27:18.980 --> 2:27:20.560
 Are we just pattern matching based on what we have

2:27:20.560 --> 2:27:22.960
 and then reverse justifying to ourselves?

2:27:22.960 --> 2:27:24.280
 Exactly, the reverse.

2:27:24.280 --> 2:27:26.920
 So like I think what the neural networks are missing

2:27:26.920 --> 2:27:29.820
 and I think GPT4 might have

2:27:29.820 --> 2:27:33.800
 is to be able to tell stories to itself about what it did.

2:27:33.800 --> 2:27:34.920
 Well, that's what humans do, right?

2:27:34.920 --> 2:27:38.240
 I mean, you talk about like network explainability, right?

2:27:38.240 --> 2:27:40.720
 And we give, no, that's a hard time about this,

2:27:40.720 --> 2:27:42.420
 but humans don't know why we make decisions.

2:27:42.420 --> 2:27:43.800
 We have this thing called intuition

2:27:43.800 --> 2:27:45.240
 and then we try to like say,

2:27:45.240 --> 2:27:47.360
 this feels like the right thing, but why, right?

2:27:47.360 --> 2:27:49.120
 And you wrestle with that

2:27:49.120 --> 2:27:50.320
 when you're making hard decisions

2:27:50.320 --> 2:27:52.200
 and is that science?

2:27:52.200 --> 2:27:53.120
 Not really.

2:27:54.400 --> 2:27:57.400
 Let me ask you about a few high level questions, I guess.

2:27:57.400 --> 2:28:02.400
 Because you've done a million things in your life

2:28:02.400 --> 2:28:04.240
 and been very successful.

2:28:04.240 --> 2:28:07.000
 A bunch of young folks listen to this,

2:28:07.000 --> 2:28:10.720
 ask for advice from successful people like you.

2:28:11.720 --> 2:28:15.680
 If you were to give advice to somebody,

2:28:15.680 --> 2:28:17.080
 you know, another graduate student

2:28:17.080 --> 2:28:19.040
 or some high school student

2:28:19.040 --> 2:28:23.560
 about pursuing a career in computing

2:28:23.560 --> 2:28:25.600
 or just advice about life in general,

2:28:25.600 --> 2:28:28.880
 is there some words of wisdom you can give them?

2:28:28.880 --> 2:28:30.860
 So I think you come back to change

2:28:30.860 --> 2:28:34.160
 and profound leaps happen

2:28:34.160 --> 2:28:35.420
 because people are willing to believe

2:28:35.420 --> 2:28:36.520
 that change is possible

2:28:36.520 --> 2:28:39.200
 and that the world does change

2:28:39.200 --> 2:28:41.040
 and are willing to do the hard thing

2:28:41.040 --> 2:28:42.720
 that it takes to make change happen.

2:28:42.720 --> 2:28:45.920
 And whether it be implementing a new programming language

2:28:45.920 --> 2:28:47.120
 or employing a new system

2:28:47.120 --> 2:28:49.240
 or employing a new research paper,

2:28:49.240 --> 2:28:50.240
 designing a new thing,

2:28:50.240 --> 2:28:51.680
 moving the world forward in science

2:28:51.680 --> 2:28:53.540
 and philosophy, whatever,

2:28:53.540 --> 2:28:54.560
 it really comes down to somebody

2:28:54.560 --> 2:28:57.120
 who's willing to put in the work, right?

2:28:57.120 --> 2:29:00.320
 And you have, the work is hard

2:29:00.320 --> 2:29:01.560
 for a whole bunch of different reasons.

2:29:01.560 --> 2:29:06.560
 One of which is, it's work, right?

2:29:06.960 --> 2:29:08.840
 And so you have to have the space in your life

2:29:08.840 --> 2:29:09.880
 in which you can do that work,

2:29:09.880 --> 2:29:11.020
 which is why going to grad school

2:29:11.020 --> 2:29:13.320
 can be a beautiful thing for certain people.

2:29:14.720 --> 2:29:16.860
 But also there's a self doubt that happens.

2:29:16.860 --> 2:29:18.360
 Like you're two years into a project,

2:29:18.360 --> 2:29:20.320
 is it going anywhere, right?

2:29:20.320 --> 2:29:21.160
 Well, what do you do?

2:29:21.160 --> 2:29:23.320
 Do you just give up because it's hard?

2:29:23.320 --> 2:29:25.620
 No, no, I mean, some people like suffering.

2:29:26.720 --> 2:29:29.280
 And so you plow through it.

2:29:29.280 --> 2:29:31.960
 The secret to me is that you have to love what you're doing

2:29:31.960 --> 2:29:35.000
 and follow that passion

2:29:35.000 --> 2:29:37.080
 because when you get to the hard times,

2:29:37.080 --> 2:29:40.080
 that's when, if you love what you're doing,

2:29:40.080 --> 2:29:41.680
 you're willing to kind of push through.

2:29:41.680 --> 2:29:45.420
 And this is really hard

2:29:45.420 --> 2:29:48.640
 because it's hard to know what you will love doing

2:29:48.640 --> 2:29:50.200
 until you start doing a lot of things.

2:29:50.200 --> 2:29:51.640
 And so that's why I think that,

2:29:51.640 --> 2:29:53.280
 particularly early in your career,

2:29:53.280 --> 2:29:54.920
 it's good to experiment.

2:29:54.920 --> 2:29:55.920
 Do a little bit of everything.

2:29:55.920 --> 2:29:59.360
 Go take the survey class on

2:29:59.360 --> 2:30:03.760
 the first half of every class in your upper division lessons

2:30:03.760 --> 2:30:05.720
 and just get exposure to things

2:30:05.720 --> 2:30:07.120
 because certain things will resonate with you

2:30:07.120 --> 2:30:08.960
 and you'll find out, wow, I'm really good at this.

2:30:08.960 --> 2:30:10.080
 I'm really smart at this.

2:30:10.080 --> 2:30:13.040
 Well, it's just because it works with the way your brain.

2:30:13.040 --> 2:30:14.340
 And when something jumps out,

2:30:14.340 --> 2:30:15.620
 I mean, that's one of the things

2:30:15.620 --> 2:30:19.160
 that people often ask about is like,

2:30:19.160 --> 2:30:21.400
 well, I think there's a bunch of cool stuff out there.

2:30:21.400 --> 2:30:23.240
 Like how do I pick the thing?

2:30:23.240 --> 2:30:27.600
 Like how do you hook, in your life,

2:30:27.600 --> 2:30:30.440
 how did you just hook yourself in and stuck with it?

2:30:30.440 --> 2:30:31.680
 Well, I got lucky, right?

2:30:31.680 --> 2:30:34.800
 I mean, I think that many people forget

2:30:34.800 --> 2:30:38.760
 that a huge amount of it or most of it is luck, right?

2:30:38.760 --> 2:30:40.860
 So let's not forget that.

2:30:41.880 --> 2:30:44.800
 So for me, I fell in love with computers early on

2:30:44.800 --> 2:30:47.740
 because they spoke to me, I guess.

2:30:49.280 --> 2:30:50.740
 What language did they speak?

2:30:50.740 --> 2:30:51.580
 Basic.

2:30:51.580 --> 2:30:53.380
 Basic, yeah.

2:30:53.380 --> 2:30:56.960
 But then it was just kind of following

2:30:56.960 --> 2:30:58.200
 a set of logical progressions,

2:30:58.200 --> 2:31:01.400
 but also deciding that something that was hard

2:31:01.400 --> 2:31:04.080
 was worth doing and a lot of fun, right?

2:31:04.080 --> 2:31:06.240
 And so I think that that is also something

2:31:06.240 --> 2:31:08.080
 that's true for many other domains,

2:31:08.080 --> 2:31:10.360
 which is if you find something that you love doing

2:31:10.360 --> 2:31:13.440
 that's also hard, if you invest yourself in it

2:31:13.440 --> 2:31:14.960
 and add value to the world,

2:31:14.960 --> 2:31:17.120
 then it will mean something generally, right?

2:31:17.120 --> 2:31:19.120
 And again, that can be a research paper,

2:31:19.120 --> 2:31:20.400
 that can be a software system,

2:31:20.400 --> 2:31:22.040
 that can be a new robot,

2:31:22.040 --> 2:31:24.760
 that can be, there's many things that that can be,

2:31:24.760 --> 2:31:27.100
 but a lot of it is like real value

2:31:27.100 --> 2:31:29.320
 comes from doing things that are hard.

2:31:29.320 --> 2:31:33.840
 And that doesn't mean you have to suffer, but.

2:31:33.840 --> 2:31:34.680
 It's hard.

2:31:34.680 --> 2:31:36.360
 I mean, you don't often hear that message.

2:31:36.360 --> 2:31:38.000
 We talked about it last time a little bit,

2:31:38.000 --> 2:31:42.800
 but it's one of my, not enough people talk about this.

2:31:43.840 --> 2:31:47.400
 It's beautiful to hear a successful person.

2:31:47.400 --> 2:31:49.460
 Well, and self doubt and imposter syndrome,

2:31:49.460 --> 2:31:52.360
 these are all things that successful people

2:31:52.360 --> 2:31:53.960
 suffer with as well,

2:31:53.960 --> 2:31:55.120
 particularly when they put themselves

2:31:55.120 --> 2:31:56.660
 in a point of being uncomfortable,

2:31:56.660 --> 2:31:59.200
 which I like to do now and then

2:31:59.200 --> 2:32:02.060
 just because it puts you in learning mode.

2:32:02.060 --> 2:32:04.080
 Like if you wanna grow as a person,

2:32:04.080 --> 2:32:07.000
 put yourself in a room with a bunch of people

2:32:07.000 --> 2:32:09.160
 that know way more about whatever you're talking about

2:32:09.160 --> 2:32:11.520
 than you do and ask dumb questions.

2:32:11.520 --> 2:32:13.040
 And guess what?

2:32:13.040 --> 2:32:15.280
 Smart people love to teach often,

2:32:15.280 --> 2:32:16.800
 not always, but often.

2:32:16.800 --> 2:32:18.320
 And if you listen, if you're prepared to listen,

2:32:18.320 --> 2:32:19.180
 if you're prepared to grow,

2:32:19.180 --> 2:32:20.680
 if you're prepared to make connections,

2:32:20.680 --> 2:32:22.380
 you can do some really interesting things.

2:32:22.380 --> 2:32:25.360
 And I think a lot of progress is made by people

2:32:25.360 --> 2:32:28.000
 who kind of hop between domains now and then,

2:32:28.000 --> 2:32:32.480
 because they bring a perspective into a field

2:32:32.480 --> 2:32:34.760
 that nobody else has,

2:32:34.760 --> 2:32:38.280
 if people have only been working in that field themselves.

2:32:38.280 --> 2:32:41.380
 We mentioned that the universe is kind of like a compiler.

2:32:43.120 --> 2:32:44.880
 The entirety of it, the whole evolution

2:32:44.880 --> 2:32:46.720
 is kind of a kind of compilation.

2:32:46.720 --> 2:32:50.640
 Maybe us human beings are kind of compilers.

2:32:51.640 --> 2:32:53.560
 Let me ask the old sort of question

2:32:53.560 --> 2:32:54.920
 that I didn't ask you last time,

2:32:54.920 --> 2:32:57.740
 which is what's the meaning of it all?

2:32:57.740 --> 2:32:58.720
 Is there a meaning?

2:32:58.720 --> 2:33:00.820
 Like if you asked a compiler why,

2:33:01.680 --> 2:33:03.380
 what would a compiler say?

2:33:03.380 --> 2:33:04.600
 What's the meaning of life?

2:33:04.600 --> 2:33:06.800
 What's the meaning of life?

2:33:06.800 --> 2:33:08.840
 I'm prepared for it not to mean anything.

2:33:09.720 --> 2:33:14.200
 Here we are, all biological things programmed to survive

2:33:14.200 --> 2:33:17.500
 and propagate our DNA.

2:33:19.160 --> 2:33:21.400
 And maybe the universe is just a computer

2:33:21.400 --> 2:33:25.320
 and you just go until entropy takes over the universe

2:33:25.320 --> 2:33:26.320
 and then you're done.

2:33:27.440 --> 2:33:29.640
 I don't think that's a very productive way

2:33:29.640 --> 2:33:31.540
 to live your life, if so.

2:33:33.000 --> 2:33:34.760
 And so I prefer to bias towards the other way,

2:33:34.760 --> 2:33:37.960
 which is saying the universe has a lot of value.

2:33:37.960 --> 2:33:41.840
 And I take happiness out of other people.

2:33:41.840 --> 2:33:43.840
 And a lot of times part of that's having kids,

2:33:43.840 --> 2:33:46.920
 but also the relationships you build with other people.

2:33:46.920 --> 2:33:49.680
 And so the way I try to live my life is like,

2:33:49.680 --> 2:33:51.240
 what can I do that has value?

2:33:51.240 --> 2:33:52.480
 How can I move the world forward?

2:33:52.480 --> 2:33:54.540
 How can I take what I'm good at

2:33:54.540 --> 2:33:57.600
 and bring it into the world?

2:33:57.600 --> 2:34:00.640
 And I'm one of these people that likes to work really hard

2:34:00.640 --> 2:34:03.140
 and be very focused on the things that I do.

2:34:03.140 --> 2:34:05.040
 And so if I'm gonna do that,

2:34:05.040 --> 2:34:08.040
 how can it be in a domain that actually will matter?

2:34:08.040 --> 2:34:10.020
 Because a lot of things that we do,

2:34:10.020 --> 2:34:11.680
 we find ourselves in the cycle of like,

2:34:11.680 --> 2:34:12.880
 okay, I'm doing a thing.

2:34:12.880 --> 2:34:13.760
 I'm very familiar with it.

2:34:13.760 --> 2:34:15.400
 I've done it for a long time.

2:34:15.400 --> 2:34:16.680
 I've never done anything else,

2:34:16.680 --> 2:34:19.760
 but I'm not really learning, right?

2:34:19.760 --> 2:34:21.720
 I'm not really, I'm keeping things going,

2:34:21.720 --> 2:34:23.680
 but there's a younger generation

2:34:23.680 --> 2:34:24.640
 that can do the same thing,

2:34:24.640 --> 2:34:26.480
 maybe even better than me, right?

2:34:26.480 --> 2:34:28.000
 Maybe if I actually step out of this

2:34:28.000 --> 2:34:31.280
 and jump into something I'm less comfortable with,

2:34:31.280 --> 2:34:32.280
 it's scary.

2:34:32.280 --> 2:34:33.440
 But on the other hand,

2:34:33.440 --> 2:34:34.920
 it gives somebody else a new opportunity.

2:34:34.920 --> 2:34:37.480
 It also then puts you back in learning mode,

2:34:37.480 --> 2:34:38.960
 and that can be really interesting.

2:34:38.960 --> 2:34:41.280
 And one of the things I've learned is that

2:34:41.280 --> 2:34:42.360
 when you go through that,

2:34:42.360 --> 2:34:45.040
 that first you're deep into imposter syndrome,

2:34:45.040 --> 2:34:46.940
 but when you start working your way out,

2:34:46.940 --> 2:34:47.780
 you start to realize,

2:34:47.780 --> 2:34:49.980
 hey, well, there's actually a method to this.

2:34:49.980 --> 2:34:53.280
 And now I'm able to add new things

2:34:53.280 --> 2:34:54.680
 because I bring different perspective.

2:34:54.680 --> 2:34:57.280
 And this is one of the good things

2:34:57.280 --> 2:34:59.800
 about bringing different kinds of people together.

2:34:59.800 --> 2:35:01.880
 Diversity of thought is really important.

2:35:01.880 --> 2:35:04.440
 And if you can pull together people

2:35:04.440 --> 2:35:06.460
 that are coming at things from different directions,

2:35:06.460 --> 2:35:07.760
 you often get innovation.

2:35:07.760 --> 2:35:10.540
 And I love to see that, that aha moment

2:35:10.540 --> 2:35:12.760
 where you're like, oh, we've really cracked this.

2:35:12.760 --> 2:35:15.200
 This is something nobody's ever done before.

2:35:15.200 --> 2:35:16.760
 And then if you can do it in the context

2:35:16.760 --> 2:35:18.960
 where it adds value, other people can build on it,

2:35:18.960 --> 2:35:20.280
 it helps move the world,

2:35:20.280 --> 2:35:22.720
 then that's what really excites me.

2:35:22.720 --> 2:35:24.480
 So that kind of description

2:35:24.480 --> 2:35:26.480
 of the magic of the human experience,

2:35:26.480 --> 2:35:29.880
 do you think we'll ever create that in an AGI system?

2:35:29.880 --> 2:35:33.480
 Do you think we'll be able to create,

2:35:34.440 --> 2:35:38.040
 give AI systems a sense of meaning

2:35:38.040 --> 2:35:39.640
 where they operate in this kind of world

2:35:39.640 --> 2:35:41.800
 exactly in the way you've described,

2:35:41.800 --> 2:35:43.240
 which is they interact with each other,

2:35:43.240 --> 2:35:44.800
 they interact with us humans.

2:35:44.800 --> 2:35:45.640
 Sure, sure.

2:35:45.640 --> 2:35:50.640
 Well, so, I mean, why are you being so a speciest, right?

2:35:50.840 --> 2:35:54.640
 All right, so AGI versus Bionets,

2:35:54.640 --> 2:35:57.720
 or something like that versus biology, right?

2:35:57.720 --> 2:36:00.280
 You know, what are we but machines, right?

2:36:00.280 --> 2:36:02.900
 We're just programmed to run our,

2:36:02.900 --> 2:36:03.920
 we have our objective function

2:36:03.920 --> 2:36:06.440
 that we were optimized for, right?

2:36:06.440 --> 2:36:07.640
 And so we're doing our thing,

2:36:07.640 --> 2:36:10.000
 we think we have purpose, but do we really, right?

2:36:10.000 --> 2:36:13.760
 I'm not prepared to say that those newfangled AGI's

2:36:13.760 --> 2:36:16.840
 have no soul just because we don't understand them, right?

2:36:16.840 --> 2:36:20.120
 And I think that would be, when they exist,

2:36:20.120 --> 2:36:24.180
 that would be very premature to look at a new thing

2:36:24.180 --> 2:36:26.880
 through your own lens without fully understanding it.

2:36:28.200 --> 2:36:29.400
 You might be just saying that

2:36:29.400 --> 2:36:31.680
 because AI systems in the future

2:36:31.680 --> 2:36:33.080
 will be listening to this and then.

2:36:33.080 --> 2:36:34.080
 Oh yeah, exactly.

2:36:34.080 --> 2:36:34.920
 You don't wanna say anything.

2:36:34.920 --> 2:36:36.280
 Please be nice to me, you know,

2:36:36.280 --> 2:36:39.160
 when Skynet kills everybody, please spare me.

2:36:39.160 --> 2:36:42.600
 So wise look ahead thinking.

2:36:42.600 --> 2:36:44.760
 Yeah, but I mean, I think that people will spend

2:36:44.760 --> 2:36:46.320
 a lot of time worrying about this kind of stuff,

2:36:46.320 --> 2:36:48.140
 and I think that what we should be worrying about

2:36:48.140 --> 2:36:49.840
 is how do we make the world better?

2:36:49.840 --> 2:36:52.840
 And the thing that I'm most scared about with AGI's

2:36:52.840 --> 2:36:57.400
 is not that necessarily the Skynet

2:36:57.400 --> 2:36:58.920
 will start shooting everybody with lasers

2:36:58.920 --> 2:37:02.040
 and stuff like that to use us for our calories.

2:37:03.040 --> 2:37:05.360
 The thing that I'm worried about is that

2:37:05.360 --> 2:37:08.280
 humanity, I think, needs a challenge.

2:37:08.280 --> 2:37:11.600
 And if we get into a mode of not having a personal challenge,

2:37:11.600 --> 2:37:13.560
 not having a personal contribution,

2:37:13.560 --> 2:37:15.880
 whether that be like, you know, your kids

2:37:15.880 --> 2:37:18.800
 and seeing what they grow into and helping guide them,

2:37:18.800 --> 2:37:21.920
 whether it be your community that you're engaged in,

2:37:21.920 --> 2:37:23.920
 you're driving forward, whether it be your work

2:37:23.920 --> 2:37:25.040
 and the things that you're doing

2:37:25.040 --> 2:37:25.880
 and the people you're working with

2:37:25.880 --> 2:37:28.880
 and the products you're building and the contribution there,

2:37:28.880 --> 2:37:31.960
 if people don't have a objective,

2:37:31.960 --> 2:37:33.360
 I'm afraid what that means.

2:37:33.360 --> 2:37:37.840
 And I think that this would lead to a rise

2:37:37.840 --> 2:37:39.920
 of the worst part of people, right?

2:37:39.920 --> 2:37:42.240
 Instead of people striving together

2:37:42.240 --> 2:37:45.120
 and trying to make the world better,

2:37:45.120 --> 2:37:49.720
 it could degrade into a very unpleasant world.

2:37:49.720 --> 2:37:51.140
 But I don't know.

2:37:51.140 --> 2:37:53.600
 I mean, we hopefully have a long ways to go

2:37:53.600 --> 2:37:54.800
 before we discover that.

2:37:54.800 --> 2:37:57.680
 And fortunately, we have pretty on the ground problems

2:37:57.680 --> 2:37:58.660
 with the pandemic right now,

2:37:58.660 --> 2:38:01.520
 and so I think we should be focused on that as well.

2:38:01.520 --> 2:38:04.700
 Yeah, ultimately, just as you said, you're optimistic.

2:38:04.700 --> 2:38:07.360
 I think it helps for us to be optimistic.

2:38:07.360 --> 2:38:10.400
 So that's fake it until you make it.

2:38:10.400 --> 2:38:11.520
 Yeah, well, and why not?

2:38:11.520 --> 2:38:12.800
 What's the other side, right?

2:38:12.800 --> 2:38:17.500
 So, I mean, I'm not personally a very religious person,

2:38:17.500 --> 2:38:19.160
 but I've heard people say like,

2:38:19.160 --> 2:38:20.480
 oh yeah, of course I believe in God.

2:38:20.480 --> 2:38:23.360
 Of course I go to church, because if God's real,

2:38:23.360 --> 2:38:25.960
 you know, I wanna be on the right side of that.

2:38:25.960 --> 2:38:27.120
 If it's not real, it doesn't matter.

2:38:27.120 --> 2:38:27.960
 Yeah, it doesn't matter.

2:38:27.960 --> 2:38:32.200
 And so, you know, that's a fair way to do it.

2:38:32.200 --> 2:38:35.640
 Yeah, I mean, the same thing with nuclear deterrence,

2:38:35.640 --> 2:38:38.440
 all, you know, global warming, all these things,

2:38:38.440 --> 2:38:41.380
 all these threats, natural engineer pandemics,

2:38:41.380 --> 2:38:42.720
 all these threats we face.

2:38:42.720 --> 2:38:47.720
 I think it's paralyzing to be terrified

2:38:49.700 --> 2:38:52.540
 of all the possible ways we could destroy ourselves.

2:38:52.540 --> 2:38:56.560
 I think it's much better or at least productive

2:38:56.560 --> 2:38:59.840
 to be hopeful and to engineer defenses

2:38:59.840 --> 2:39:03.000
 against these things, to engineer a future

2:39:03.000 --> 2:39:06.640
 where like, you know, see like a positive future

2:39:06.640 --> 2:39:07.960
 and engineer that future.

2:39:07.960 --> 2:39:10.220
 Yeah, well, and I think that's another thing

2:39:10.220 --> 2:39:12.680
 to think about as, you know, a human,

2:39:12.680 --> 2:39:14.560
 particularly if you're young and trying to figure out

2:39:14.560 --> 2:39:18.120
 what it is that you wanna be when you grow up, like I am.

2:39:18.120 --> 2:39:19.840
 I'm always looking for that.

2:39:19.840 --> 2:39:23.380
 The question then is, how do you wanna spend your time?

2:39:24.300 --> 2:39:26.020
 And right now there seems to be a norm

2:39:26.020 --> 2:39:28.800
 of being a consumption culture.

2:39:28.800 --> 2:39:31.520
 Like I'm gonna watch the news and revel

2:39:31.520 --> 2:39:33.520
 in how horrible everything is right now.

2:39:33.520 --> 2:39:36.560
 I'm going to go find out about the latest atrocity

2:39:36.560 --> 2:39:38.840
 and find out all the details of like the terrible thing

2:39:38.840 --> 2:39:40.640
 that happened and be outraged by it.

2:39:41.960 --> 2:39:44.000
 You can spend a lot of time watching TV

2:39:44.000 --> 2:39:46.640
 and watching the news at home or whatever

2:39:46.640 --> 2:39:49.340
 people watch these days, I don't know.

2:39:49.340 --> 2:39:51.160
 But that's a lot of hours, right?

2:39:51.160 --> 2:39:53.400
 And those are hours that if you're turned

2:39:53.400 --> 2:39:56.960
 to being productive, learning, growing,

2:39:56.960 --> 2:39:59.600
 experiencing, you know, when the pandemic's over,

2:39:59.600 --> 2:40:03.600
 going exploring, right, it leads to more growth.

2:40:03.600 --> 2:40:06.400
 And I think it leads to more optimism and happiness

2:40:06.400 --> 2:40:08.620
 because you're building, right?

2:40:08.620 --> 2:40:10.960
 You're building yourself, you're building your capabilities,

2:40:10.960 --> 2:40:12.200
 you're building your viewpoints,

2:40:12.200 --> 2:40:13.400
 you're building your perspective.

2:40:13.400 --> 2:40:18.360
 And I think that a lot of the consuming

2:40:18.360 --> 2:40:19.960
 of other people's messages leads

2:40:19.960 --> 2:40:21.720
 to kind of a negative viewpoint,

2:40:21.720 --> 2:40:24.360
 which you need to be aware of what's happening

2:40:24.360 --> 2:40:25.680
 because that's also important,

2:40:25.680 --> 2:40:28.120
 but there's a balance that I think focusing

2:40:28.120 --> 2:40:32.000
 on creation is a very valuable thing to do.

2:40:32.000 --> 2:40:33.840
 Yeah, so what you're saying is people should focus

2:40:33.840 --> 2:40:37.320
 on working on the sexiest field of them all,

2:40:37.320 --> 2:40:38.440
 which is compiler design.

2:40:38.440 --> 2:40:39.680
 Exactly.

2:40:39.680 --> 2:40:41.160
 Hey, you could go work on machine learning

2:40:41.160 --> 2:40:43.640
 and be crowded out by the thousands of graduates

2:40:43.640 --> 2:40:45.620
 popping out of school that all want to do the same thing,

2:40:45.620 --> 2:40:48.560
 or you could work in the place that people overpay you

2:40:48.560 --> 2:40:51.260
 because there's not enough smart people working in it.

2:40:51.260 --> 2:40:53.480
 And here at the end of Moore's Law,

2:40:53.480 --> 2:40:55.480
 according to some people,

2:40:55.480 --> 2:40:57.480
 actually the software is the hard part too.

2:40:58.480 --> 2:41:02.280
 I mean, optimization is truly, truly beautiful.

2:41:02.280 --> 2:41:05.120
 And also on the YouTube side or education side,

2:41:07.920 --> 2:41:09.760
 it'd be nice to have some material

2:41:09.760 --> 2:41:12.160
 that shows the beauty of compilers.

2:41:12.160 --> 2:41:13.160
 Yeah, yeah.

2:41:13.160 --> 2:41:14.480
 That's something.

2:41:14.480 --> 2:41:17.440
 So that's a call for people to create

2:41:17.440 --> 2:41:18.920
 that kind of content as well.

2:41:18.920 --> 2:41:22.800
 Chris, you're one of my favorite people to talk to.

2:41:22.800 --> 2:41:25.560
 It's such a huge honor that you would waste your time

2:41:25.560 --> 2:41:26.560
 talking to me.

2:41:26.560 --> 2:41:27.760
 I've always appreciated it.

2:41:27.760 --> 2:41:29.600
 Thank you so much for talking to me.

2:41:29.600 --> 2:41:32.320
 The truth of it is you spent a lot of time talking to me

2:41:32.320 --> 2:41:34.440
 just on walks and other things like that,

2:41:34.440 --> 2:41:35.640
 so it's great to catch up with.

2:41:35.640 --> 2:41:37.200
 Thanks, man.

2:41:37.200 --> 2:41:39.240
 Thanks for listening to this conversation

2:41:39.240 --> 2:41:42.360
 with Chris Latner, and thank you to our sponsors.

2:41:42.360 --> 2:41:45.200
 Blinkist, an app that summarizes key ideas

2:41:45.200 --> 2:41:46.600
 from thousands of books.

2:41:46.600 --> 2:41:49.640
 Neuro, which is a maker of functional gum and mints

2:41:49.640 --> 2:41:51.440
 that supercharge my mind.

2:41:51.440 --> 2:41:55.480
 Masterclass, which are online courses from world experts.

2:41:55.480 --> 2:41:57.840
 And finally, Cash App, which is an app

2:41:57.840 --> 2:42:00.200
 for sending money to friends.

2:42:00.200 --> 2:42:02.360
 Please check out these sponsors in the description

2:42:02.360 --> 2:42:06.120
 to get a discount and to support this podcast.

2:42:06.120 --> 2:42:08.440
 If you enjoy this thing, subscribe on YouTube,

2:42:08.440 --> 2:42:10.600
 review it with five stars on Apple Podcast,

2:42:10.600 --> 2:42:13.280
 follow on Spotify, support it on Patreon,

2:42:13.280 --> 2:42:16.320
 connect with me on Twitter at Lex Friedman.

2:42:16.320 --> 2:42:19.080
 And now, let me leave you with some words from Chris Latner.

2:42:19.080 --> 2:42:21.760
 So much of language design is about tradeoffs,

2:42:21.760 --> 2:42:23.720
 and you can't see those tradeoffs

2:42:23.720 --> 2:42:25.640
 unless you have a community of people

2:42:25.640 --> 2:42:28.560
 that really represent those different points.

2:42:28.560 --> 2:42:47.560
 Thank you for listening, and hope to see you next time.

